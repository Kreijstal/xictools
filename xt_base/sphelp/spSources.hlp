
!!  ---------------------------------------------------------------
!!  Xic/WRspice Help System Database
!!  $Id: spSources.hlp,v 1.22 2017/02/22 01:53:00 stevew Exp $
!!  Copyright (C) Whiteley Research Inc. 2003.  All Rights Reserved
!!  ---------------------------------------------------------------

!!TAG WRspice
!! This file in sync with manual.

!!KEYWORD
spSources.hlp
!!TITLE
spSources.hlp
!!HTML 

!!SUBTOPICS
src
devexpr 
polyexpr 
tranfuncs 
texp
tgauss
interp
pulse
gpulse
pwl
sffm
am
tsin
spulse 
table 
depsource
vccs
vcvs
cccs
ccvs


!! elements.tex 012509
!!KEYWORD
src isrc vsrc arbsource
!!TITLE
General I and V Sources
!!HTML 
    General form:
    <blockquote>
        <tt>v</tt><i>name</i> <i>n+ n-</i> [<i>expr</i>]
          [[<tt>dc</tt>] <i>dcvalue</i>]<br>
          &nbsp;&nbsp; [<tt>ac</tt> [<i>acmag</i> [<i>acphase</i>]] |
           <tt>table</tt>(<i>name</i>)]<br>
          &nbsp;&nbsp; [<tt>distof1</tt> [<i>f1mag</i> [<i>f1phase</i>]]] 
          [<tt>distof2</tt> [<i>f2mag</i> [<i>f2phase</i>]]]<br>
        <tt>i</tt><i>name</i> <i>n+ n-</i> [<i>expr</i>]
          [[<tt>dc</tt>] <i>dcvalue</i>]<br>
          &nbsp;&nbsp; [<tt>ac</tt> [<i>acmag</i> [<i>acphase</i>]] |
           <tt>table</tt>(<i>name</i>)]<br>
          &nbsp;&nbsp; [<tt>distof1</tt> [<i>f1mag</i> [<i>f1phase</i>]]] 
          [<tt>distof2</tt> [<i>f2mag</i> [<i>f2phase</i>]]]<br>
        <tt>a</tt><i>name</i> <i>n+ n-</i> v|I = <i>expr</i>
          [[<tt>dc</tt>] <i>dcvalue</i>]<br>
          &nbsp;&nbsp; [<tt>ac</tt> [<i>acmag</i> [<i>acphase</i>]] |
           <tt>table</tt>(<i>name</i>)]<br>
          &nbsp;&nbsp; [<tt>distof1</tt> [<i>f1mag</i> [<i>f1phase</i>]]] 
          [<tt>distof2</tt> [<i>f2mag</i> [<i>f2phase</i>]]]
    </blockquote>

    <p>
    Examples:
    <blockquote><tt>
        vcc 10 0 dc 6<br>
        vin 13 2 0.001 ac 1 sin(0 1 1meg)<br>
        v2 10 1 ac table(acvals)<br>
        isrc 23 21 ac 0.333 45.0 sffm(0 1 10k 5 1k)<br>
        vmeas 12 9<br>
        vin 1 0 2*v(2)+v(3)<br>
        azz 2 0 v=.5*exp(v(2))<br>
        ixx 2 4 pulse(0 1 1n 10n 10n) + pulse(0 1 40n 10n 10n)<br>
    </tt></blockquote>

    In <i>WRspice</i>, the specification of an "independent" source is
    completely general, as the output can be governed by an arbitrary
    <a href="devexpr">expression</a> containing functions of other
    circuit variables.  The syntax is a superset of the notation used
    in previous versions of SPICE, which separately keyed independent
    and dependent sources.

    <p>
    The leading letter "<tt>v</tt>" keys a voltage source, and
    "<tt>i</tt>" keys a current source.  In addition, the "arbitrary
    source" used in SPICE3 is retained, but is keyed by "<tt>a</tt>",
    rather than "<tt>b</tt>" ("<tt>b</tt>" is used for Josephson
    junctions in <i>WRspice</i>).  This is a special case of the
    general source specification included for backward compatibility.

    <p>
    The <i>n+</i> and <i>n-</i> are the positive and negative nodes,
    respectively.  Note that voltage sources need not be grounded. 
    Positive current is assumed to flow from the positive node,
    through the source, to the negative node.  A current source of
    positive value, will force current to flow in to the <i>n+</i>
    node, through the source, and out of the <i>n-</i> node.  Voltage
    sources, in addition to being used for circuit excitation, are
    often used as 'ammeters' in <i>WRspice</i>, that is, zero valued
    voltage sources may be inserted into the circuit for the purpose
    of measuring current (in <i>WRspice</i>, an inductor can be used
    for this purpose as well).  Zero-value voltage sources will, of
    course, have no effect on circuit operation since they represent
    short-circuits, however they add complexity which might slightly
    affect simulation speed.

    <p>
    In <a href=".tran">transient</a> and <a href=".dc">dc</a>
    analysis, sources can in general have complex definitions which
    involve the dependent variable (e.g., time in transient analysis)
    and other circuit variables.  There are built-in <a
    href="tranfuncs">functions</a> (<tt>pulse</tt>, <tt>pwl</tt>, etc)
    which can be included in the <i>expr</i>.

    <p>
    Constant values associated with the source are specified by
    the following option keywords:

    <dl>
    <dt><tt>dc</tt> <i>dcvalue</i><dd>
    This specifies a fixed dc analysis value for the source, and
    enables the source to be used in a <a href=".dc">dc sweep</a> if
    the <i>expr</i> is given.  If the <i>expr</i> is not given, the
    source is available for use in a dc sweep whether or not the
    <tt>dc</tt> keyword is given.  If an <i>expr</i> is present
    without "<tt>dc</tt> <i>dcvalue</i>", the time=0 value of the
    <i>expr</i> is used in dc analysis.  If the source value is zero
    for both dc and transient analyses, this value and the <i>expr</i>
    may be omitted.  If the source is the same constant value in dc
    and transient analysis, the keyword "<tt>dc</tt>" and the value
    can be omitted.
    </dl>

    <dl>
    <dt><tt>ac</tt> [[<i>acmag</i>
      [<i>acphase</i>]] | <tt>table</tt>(<i>name</i>)]<dd>
    The parameter <i>acmag</i> is the ac magnitude and <i>acphase</i>
    is the ac phase.  The source is set to this value in the ac
    analysis.  If <i>acmag</i> is omitted following the keyword
    <tt>ac</tt>, a value of unity is assumed.  If <i>acphase</i> is
    omitted, a value of zero is assumed.  If the source is not an ac
    small-signal input, the keyword <tt>ac</tt> and the ac values are
    omitted.  Alternatively, a table can be specified, which contains
    complex values at different frequency points.  In ac analysis the
    source value will be derived from the table.  The table with the
    given <i>name</i> should be specified in a <a
    href=".table"><tt>.table</tt></a> line, with the <tt>ac</tt>
    keyword present.  The values in the table are the real and
    imaginary components, and <i>not</i> magnitude and phase.
    </dl>

    <dl>
    <dt><tt>distof1</tt> and <tt>distof2</tt><dd>
    These are the keywords that specify that the independent source
    has distortion inputs at the frequencies <i>f1</i> and <i>f2</i>
    respectively for <a href=".disto">distortion analysis</a>.  The
    keywords may be followed by an optional magnitude and phase.  The
    default values of the magnitude and phase are 1.0 and 0.0
    respectively.
    </dl>
  
    <p>
    The <a href="devexpr"><i>expr</i></a> is used to assign a
    time-dependent value for transient analysis and to supply a
    functional dependence for dc analysis.  If a source is assigned a
    time-dependent value, the time-zero value is used for dc analysis,
    unless a dc value is also provided.
!!LATEX src elements.tex
\spgen{
v{\it name\/} {\it n\/}+ {\it n\/}- [{\it expr\/}]
 [[dc] {\it dcvalue\/}]
 [ac [{\it acmag\/} [{\it acphase\/}]] | table({\it name\/})]\\
 \hspace*{5mm} [distof1 [{\it f1mag\/} [{\it f1phase\/}]]]
 [distof2 [{\it f2mag\/} [{\it f2phase\/}]]]\\
i{\it name\/} {\it n\/}+ {\it n\/}- [{\it expr\/}]
 [[dc] {\it dcvalue\/}]
 [ac [{\it acmag\/} [{\it acphase\/}]] | table({\it name\/})]\\
 \hspace*{5mm} [distof1 [{\it f1mag\/} [{\it f1phase\/}]]]
 [distof2 [{\it f2mag\/} [{\it f2phase\/}]]]\\
a{\it name\/} {\it n\/}+ {\it n\/}- V|I = {\it expr\/}
 [[dc] {\it dcvalue\/}] [ac [{\it acmag\/}
 [{\it acphase\/}]] | table({\it name\/})]\\
 \hspace*{5mm} [distof1 [{\it f1mag\/} [{\it f1phase\/}]]]
 [distof2 [{\it f2mag\/} [{\it f2phase\/}]]]}
\spexamp{vcc 10 0 dc 6\\
vin 13 2 0.001 ac 1 sin(0 1 1meg)\\
v2 10 1 ac table(acvals)\\
isrc 23 21 ac 0.333 45.0 2*sffm(0 1 10k 5 1k)\\
vmeas 12 9\\
vin 1 0 2*v(2)+v(3)\\
azz 2 0 v=.5*exp(v(2))\\
ixx 2 4 pulse(0 1 1n 10n 10n) + pulse(0 1 40n 10n 10n)}

In {\WRspice}, the specification of an ``independent'' source is
completely general, as the output can be governed by an arbitrary
expression containing functions of other circuit variables.  The
syntax is a superset of the notation used in previous versions of
SPICE, which separately keyed independent and dependent sources.

The leading letter ``{\vt v}'' keys a voltage source, and ``{\vt i}''
keys a current source.  In addition, the ``arbitrary source'' used in
SPICE3 is retained, but is keyed by ``{\vt a}'', rather than ``{\vt
b}'' (``{\vt b}'' is used for Josephson junctions in {\WRspice}). 
This is a special case of the general source specification included
for backward compatibility.

The {\it n\/}{\vt +} and {\it n\/}{\vt -} are the positive and
negative nodes, respectively.  Note that voltage sources need not be
grounded.  Positive current is assumed to flow from the positive
node, through the source, to the negative node.  A current source of
positive value will force current to flow in to the {\it n\/}{\vt +}
node, through the source, and out of the {\it n\/}{\vt -} node. 
Voltage sources, in addition to being used for circuit excitation,
are often used as ``ammeters'' in {\WRspice}, that is, zero valued
voltage sources may be inserted into the circuit for the purpose of
measuring current (in {\WRspice}, an inductor can be used for this
purpose as well).  Zero-valued voltage sources will, of course, have
no effect on circuit operation since they represent short-circuits,
however they add complexity which might slightly affect simulation
speed.

In transient and dc analysis, sources can in general have complex
definitions which involve the dependent variable (e.g., time in
transient analysis) and other circuit variables.  There are built-in
functions ({\vt pulse}, {\vt pwl}, etc.) which can be included in the
{\it expr}.

Constant values associated with the source are specified by
the following option keywords:

\begin{description}
\item{{\vt dc} {\it dcvalue}}\\
This specifies a fixed dc analysis value for the source, and enables
the source to be used in a dc sweep if the {\it expr} is given.  If
the {\it expr} is not given, the source is available for use in a dc
sweep whether or not the {\vt dc} keyword is given.  If an {\it expr}
is present without ``{\vt dc} {\it dcvalue\/}'', the time=0 value of
the {\it expr} is used for dc analysis.  If the source value is zero
for both dc and transient analyses, this value and the {\it expr\/}
may be omitted.  If the source is the same constant value in dc and
transient analysis, the keyword ``{\vt dc}'' and the value can be
omitted.

\item{{\vt ac} [[{\it acmag} [{\it acphase}]] $|$ table({\it name\/})]}\\
The parameter {\it acmag} is the ac magnitude and {\it acphase} is the
ac phase.  The source is set to this value in ac analysis.  If {\it
acmag} is omitted following the keyword {\vt ac}, a value of unity is
assumed.  If {\it acphase} is omitted, a value of zero is assumed.  If
the source is not an ac small-signal input, the keyword {\vt ac} and
the ac values are omitted.  Alternatively, a table can be specified,
which contains complex values at different frequency points.  In ac
analysis the source value will be derived from the table.  The table
with the given {\it name} should be specified in a {\vt .table} line,
with the {\vt ac} keyword present.  The values in the table are the
real and imaginary components, and {\it not} magnitude and phase.

\item{{\vt distof1} and {\vt distof2}}\\
These are the keywords that specify that the independent source has
distortion inputs at the frequencies f1 and f2 respectively for
distortion analysis.  The keywords may be followed by an optional
magnitude and phase.  The default values of the magnitude and phase
are 1.0 and 0.0 respectively.
\end{description}

The {\it expr} is used to assign a time-dependent value for
transient analysis and to supply a functional dependence for dc
analysis.  If a source is assigned a time-dependent value, the
time-zero value is used for dc analysis, unless a dc value is also
provided.

!!SEEALSO
depsource
elements
devexpr 

!! elements.tex 032120
!!KEYWORD
devexpr 
!!TITLE
Device Expressions
!!HTML 
    <i>WRspice</i> contains a separate expression handling system for
    expressions found in device lines.  Voltage and current source
    lines may contain expressions, as can resistor and capacitor
    device lines.  These use the same syntax as is used in vector <a
    href="expressions">expressions</a> in <i>WRspice</i> shell
    commands, and in <a href="squote">single-quoted</a> expressions. 

    <p>
    Although the syntax and most of the function names are equivalent
    to vector expressions used in post-processing, the mathematics
    subsystems are completely different.  There are three main
    differences from ordinary vector expressions:

    <ol>
    <li>The expressions always resolve as scalars.  Before evaluation,
    all vectors in the current plot are "scalarized" so that they
    temporarily have unit length with the current value as the data
    item.

    <p>
    <li>All inputs and results are real values.

    <p>
    <li>In theory, expressions should be differentiable with respect
    to node voltages and branch current variables.  If not, lack of
    convergence might be seen.  Previous versions of <i>WRspice</i>
    were more strict about this than the present version, which allows
    relational and logic operators.  It is often very convenient to
    use these operators, and in general it seems that their use does
    not prevent convergence.  Your experience may be different,
    however.
    </ol>

    <p>
    The expression can contain vectors from the current plot or the <a
    href="constants"><tt>constants</tt></a> plot, and circuit
    parameters accessed through the <a
    href="specialvec">@<i>device</i>[<i>param</i>]</a> construct.  In
    addition, the variable "<tt>x</tt>", which can appear explicitly
    in the expression, is defined to be the controlling variable in <a
    href="depsource">dependent sources</a>, or is set to the scale
    variable in the analysis (e.g., <tt>time</tt> for transient
    analysis).

    <p>
    The functions which are used in the device description should be
    differentiable with respect to node voltages and branch currents
    to promote convergence.  Internally, the expressions are
    symbolically differentiated in order to calculate the Jacobian,
    which is used to set up the matrix which is solved during
    analysis.  This would seem to prevent use of the logical
    operators, modulus operator, relational operators (<tt>&#60;</tt>,
    <tt>></tt>, etc.), and the tri-conditional operator (<i>a</i>
    <tt>?</tt> <i>b</i> <tt>:</tt> <i>c</i>) in these expressions
    where an operand depends on a node voltage or branch current. 
    However, <i>WRspice</i> currently supports relational and logic
    operators in source expressions, by assuming identically zero
    derivatives for these operators when differentiating.  We find, in
    practice, that this rarely causes obvious convergence problems, at
    least if used in moderation.

    <p> In addition to the built-in functions, expressions used in
    devices can include user-defined functions, which must have been
    defined previously with the <a href="define"><b>define</b></a>
    command, or with a <a href=".param"><tt>.param</tt></a> line, or
    in a parameter definition list in a subcircuit call or definition. 
    These can be used with either math package.  Internally, they are
    saved in a data structure known as a parse tree.  When a
    user-defined function is called in the context of a device
    equation, checking is performed on the user-defined function parse
    tree to see if any of the non-differentiable operations are
    included.  If so, an error message is generated, and the equation
    setup fails.

    <p>
    This being said, the situation is actually a bit more complicated. 
    As the circuit is being set up, all device equations, after
    linking in the user-defined functions if any, are "simplified" by
    evaluating and collapsing all of the constant terms as far as
    possible.  This evaluation allows <b>all</b> of the operations. 
    In general, these equations can be very complex, with lots of
    parameters and conditional tests involving parameters.  However,
    after simplification, the equation typically reduces to a much
    simpler form, and the conditionals and other unsupported
    constructs will have disappeared.

    <p>
    The bottom line of all of this is that for equations that appear
    in a circuit description, the circuit variables (node voltages and
    branch currents) can't be used in tri-conditional and modulus
    sub-expressions.  For example consider the following:

    <blockquote>
    <tt>.param myabs(a) = 'a &#60; 0 ? -a : a'</tt><br>
    <tt>.param mymax(x,y) ='x > y ? x : y'</tt><br>
    <tt>E2 2 0 function myabs(v(1))</tt><br>
    <tt>E3 3 0 function mymax(v(1), 0)</tt>
    </blockquote>

    This will not work, as it specifically breaks the rules
    prohibiting tri-conditionals.  However, it really should be
    possible to simulate a circuit with behavior described as intended
    above, and it (usually) is.  One needs to find ways of expressing
    the behavior by using supported math.

    For example, either of these alternatives would be an acceptable
    alternative for <tt>myabs</tt>.
    <blockquote>
    <tt>.param myabs(a) = abs(a)</tt><br>
    <tt>.param myabs(a) = sqrt(a*a)</tt>
    </blockquote>
    For the special case of <tt>y = 0</tt>, an acceptable substitute
    for <tt>mymax</tt> would be
    <blockquote>
    <tt>.param mymax(x,y) = 0.5*(abs(x) + x)</tt>
    </blockquote>

    Thus, the following lines are equivalent to the original
    description, but will be accepted as <i>WRspice</i> input.
    <blockquote>
    <tt>.param myabs(a) = abs(a)</tt><br>
    <tt>.param mymax(x,y) = 0.5*(abs(x) + x)</tt><br>
    <tt>E2 2 0 function myabs(v(1))</tt><br>
    <tt>E3 3 0 function mymax(v(1), 0)</tt>
    </blockquote>

    <p>
    Although the lists of math functions available in the two packages
    are similar, the internal evaluation functions are different.  The
    shell math functions must operate on vectors of complex values,
    whereas the functions called in device expressions take scalar
    real values only.  Furthermore, the device expressions should be
    differentiable with respect to included node voltages and branch
    currents, as the derivative of the expression is computed as part
    of the iterative process of solving the circuit matrix equations. 
    We have seen that this limits the operations available, and it
    likewise puts restrictions on the functions.  The <tt>sgn</tt>
    function grossly violates the differentiability requirement, and
    many of the functions and/or their derivatives have restricted
    ranges or singularities.  These can easily lead to convergence
    problems unless some care is exercised.

    <p>
    As for all expressions, if an expression is enclosed in <a
    href="squote">single quotes</a>, it will be evaluated when the
    file is read, reducing to a constant.  However, if the expression
    contains references to circuit variables such as node voltages or
    branch currents, it will be left as an expression, to be evaluated
    during the simulation.

    <p>
    The following math functions are available in device expressions
    on most systems:

    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th align="left"><tt>abs</tt></th>
       <td> absolute value</td></tr>
    <tr><th align="left"><tt>acos</tt></th>
       <td> arc-cosine</td></tr>
    <tr><th align="left"><tt>acosh</tt></th>
       <td> arc-hyperbolic cosine</td></tr>
    <tr><th align="left"><tt>asin</tt></th>
       <td> arc-sine</td></tr>
    <tr><th align="left"><tt>asinh</tt></th>
       <td> arc-hyperbolic sine</td></tr>
    <tr><th align="left"><tt>atan</tt></th>
       <td> arc-tangent</td></tr>
    <tr><th align="left"><tt>atanh</tt></th>
       <td> arc-hyperbolic tangent</td></tr>
    <tr><th align="left"><tt>cbrt</tt></th>
       <td> cube root</td></tr>
    <tr><th align="left"><tt>cos</tt></th>
       <td> cosine</td></tr>
    <tr><th align="left"><tt>cosh</tt></th>
       <td> hyperbolic cosine</td></tr>
    <tr><th align="left"><tt>deriv</tt></th>
       <td> derivative</td></tr>
    <tr><th align="left"><tt>erf</tt></th>
       <td> error function</td></tr>
    <tr><th align="left"><tt>erfc</tt></th>
       <td> complementary error function</td></tr>
    <tr><th align="left"><tt>exp</tt></th>
       <td> exponential (e raised to power)</td></tr>
    <tr><th align="left"><tt>j0</tt></th>
       <td> Bessel function, zero order</td></tr>
    <tr><th align="left"><tt>j1</tt></th>
       <td> Bessel function, first order</td></tr>
    <tr><th align="left"><tt>jn</tt></th>
       <td> Bessel function, n'th order</td></tr>
    <tr><th align="left"><tt>ln</tt></th>
       <td> natural log</td></tr>
    <tr><th align="left"><tt>log</tt></th>
       <td> natural log</td></tr>
    <tr><th align="left"><tt>log10</tt></th>
       <td>log base 10</td></tr>
    <tr><th align="left"><tt>pow</tt></th>
       <td>x to power y</td></tr>
    <tr><th align="left"><tt>pwr</tt></th>
       <td>x to power y</td></tr>
    <tr><th align="left"><tt>sgn</tt></th>
       <td> sign (+1,0,-1)</td></tr>
    <tr><th align="left"><tt>sin</tt></th>
       <td> sine</td></tr>
    <tr><th align="left"><tt>sinh</tt></th>
       <td> hyperbolic sine</td></tr>
    <tr><th align="left"><tt>sqrt</tt></th>
       <td> square root</td></tr>
    <tr><th align="left"><tt>tan</tt></th>
       <td> tangent</td></tr>
    <tr><th align="left"><tt>tanh</tt></th>
       <td> hyperbolic tangent</td></tr>
    <tr><th align="left"><tt>y0</tt></th>
       <td> Neumann function, zero order</td></tr>
    <tr><th align="left"><tt>y1</tt></th>
       <td> Neumann function, first order</td></tr>
    <tr><th align="left"><tt>yn</tt></th>
       <td> Neumann function, n'th order</td></tr>
    </table>
    </blockquote>

    <p>
    Most functions take a single argument.  Exceptions are <tt>jn</tt>
    and <tt>yn</tt> which require two arguments.  The first argument
    is an integer value for the order, and the second argument is the
    function input.  The <tt>pow</tt> and functionally identical
    <tt>pwr</tt> functions also require two arguments, the first
    argument being the base, and the second being the exponent.  The
    <tt>deriv</tt> function will differentiate the parse tree of the
    argument with respect to the <tt>x</tt> variable (whether implicit
    or explicit).  This is completely unlike the <tt>deriv</tt>
    function for vectors, which performs a numerical differentiation
    with respect to some scale.  Differentiating the parse tree gives
    an analytic result which is generally more accurate.

    <p>
    In addition, there are special <a href="tranfuncs">tran
    functions</a> which produce specified output in transient
    analysis.  <i>WRspice</i> recognizes by context functions and tran
    functions with the same name (<tt>exp, sin, gauss</tt>).  An
    unrecognized function is assumed to be a table reference
    (specified with a <a href=".table"><tt>.table</tt></a> line).

    <p>
    After simplification by collapsing all of the constant terms,
    the following tokens are recognized in a device function.
    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th align="left"><tt>+,*,/</tt></th>
     <td> binary: add, multiply, divide</td></tr>
    <tr><th align="left"><tt>-</tt></th>
     <td> unary or binary: negate or subtract</td></tr>
    <tr><th align="left"><tt>^</tt></th>
     <td> binary: exponentiation</td></tr>
    <tr><th align="left"><tt>()</tt></th>
     <td>association</td></tr>
    <tr><th align="left"><tt>,</tt></th>
     <td> argument separator</td></tr>
    <tr><th align="left"><tt>x</tt></th>
     <td> independent variable</td></tr>
    <tr><th align="left"><i>number</i></th>
     <td> a floating point number</td></tr>
    <tr><th align="left"><i>string</i></th>
     <td> a library function, table, or circuit vector</td></tr>
    </table>
    </blockquote>

    <p>
    Additionally, the following relational and logical operators are
    available.  Use of these operators may impede convergence.  The
    operators evaluate to 1.0 when true, 0.0 otherwise.  Inputs to
    logical operators are true if integer-converted values are
    nonzero.
    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th align="left"><tt>=,==,eq</tt></th>
     <td>  equality</td></tr>
    <tr><th align="left"><tt>!=,&#60;>,>&#60;,ne</tt></th>
     <td>  inequality</td></tr>
    <tr><th align="left"><tt>>,gt</tt></th>
     <td>  greater than</td></tr>
    <tr><th align="left"><tt>&#60;,lt</tt></th>
     <td>  less than</td></tr>
    <tr><th align="left"><tt>>=,ge</tt></th>
     <td>  greater than or equal</td></tr>
    <tr><th align="left"><tt>&#60;=,le</tt></th>
     <td>  less than or equal</td></tr>
    <tr><th align="left"><tt>&,&&,and</tt></th>
     <td>  logical and</td></tr>
    <tr><th align="left"><tt>|,||,or</tt></th>
     <td>  logical or</td></tr>
    <tr><th align="left"><tt>~,!,not</tt></th>
     <td>  logical not</td></tr>
    </table>
    </blockquote>

    <p>
    The independent variable <tt>x</tt> is context specific, and
    usually represents a global input variable.  It is the running
    variable in the current analysis (time in transient analysis, for
    example), or the input variable in <a href="depsource">dependent
    source</a> specifications.

    <p>
    In a chained analysis, the <tt>x</tt> variable will be that of
    core analysis.  Thus, for a chained transient analysis, <tt>x</tt>
    is time, as in the unchained case.  Since the functional
    dependence is inoperable in any kind of ac small-signal analysis
    (ac, noise, transfer function, pz, distortion, ac sensitivity)
    <tt>x</tt> is not set and never used.  In "op" analysis,
    <tt>x</tt> is always numerically zero.  The same is true in dc
    sensitivity analysis.

    <p>
    During a "pure" dc sweep analysis, for "independent" sources
    (keyed by <b>v</b>, <b>i</b>, or <b>a</b> and not <b>e</b>,
    <b>f</b>, <b>g</b>, or <b>h</b>) other than the swept ones, if an
    expression is given, the output of the source will be the result
    of the expression where the input <tt>x</tt> is the swept voltage
    (or the first sweep voltage if there are two), rather than time as
    when in transient analysis.  However, if the source line has a
    "dc" keyword and optional following constant value, during pure dc
    analysis the source will output the fixed value, or zero, if the
    value is omitted.  However, in pure dc analysis the tran functions
    generally return zero.  The exceptions are <tt>pwl</tt>,
    <tt>table</tt> and table references, and <tt>interp</tt>.  These
    functions return values, but with the swept voltage (<tt>x</tt>)
    as the input (in the case of <tt>table</tt> the input may be
    explicit anyway).  For "dependent" sources (keyed by <b>e</b>,
    <b>f</b>, <b>g</b>, or <b>h</b>) the <tt>x</tt> is the controlling
    voltage or current as in transient analysis.  Again, if a "dc"
    keyword appears, the output will be fixed at the given value,
    ignoring the controlling variable.

    <p>
    Since circuit "vector" names used in device expressions must be
    resolved before the actual vector is created, there is a potential
    for error not present in normal vector expressions.  In
    particular, name clashes between circuit node names and vectors in
    the <tt>constants</tt> plot can cause trouble.

    <p>
    In device expressions, if a string token starts with a backslash
    ('\') character, it will not be replaced with a value, should the
    name happen to match one of the named constants, or other
    potential substitution.  This will be needed, for example, if a
    node name matches one of the predefined constant names, and one
    needs to reference that node in a source expression.  The token
    should be double quoted to ensure this interpretation by the
    parser.

    <p>
    For example, suppose there is a node named "<tt>c</tt>", which is
    also the name of a vector in the <tt>constants</tt> plot.  Such a
    vector existed in earlier <i>WRspice</i> releases, as it was the
    speed of light constant.  This constant is now named
    "<tt>const_c</tt>" so a clash with this is unlikely.  However, the
    user can create a vector named "<tt>c</tt>" in the
    <tt>constants</tt> plot, so the possibility of a clash remains.

    <p>
    A source specification like

    <blockquote>
    <tt>vcon 1 2 5*v(c)</tt>
    </blockquote>

    will cause an error, possibly not until simulation time.  This
    can be avoided by use of the form described above.

    <blockquote>
    <tt>vcon 1 2 5*v("\c")</tt>
    </blockquote>
!!LATEX devexpr elements.tex
{\WRspice} contains a separate expression handling system for
expressions found in device lines.  Voltage and current source lines
may contain expressions, as can resistor and capacitor device lines. 
These use the same syntax as is used in vector expressions in
{\WRspice} shell commands (see \ref{vecexpr}), and in single-quoted
expressions.

Although the syntax and most of the function names are equivalent to
vector expressions used in post-processing, the mathematics subsystems
are completely different.  There are three main differences from
ordinary vector expressions:

\begin{enumerate}
\item{The expressions always resolve as scalars.  Before evaluation,
all vectors in the current plot are ``scalarized'' so that they temporarily
have unit length with the current value as the data item.}

\item{All inputs and results are real values.}

\item{In theory, expressions should be differentiable with respect to
node voltages and branch current variables.  If not, lack of
convergence might be seen.  Previous versions of {\WRspice} were more
strict about this than the present version, which allows relational
and logic operators.  It is often very convenient to use these
operators, and in general it seems that their use does not prevent
convergence.  Your experience may be different, however.}
\end{enumerate}

The expression can contain vectors from the current plot
or the {\vt constants} plot, and circuit parameters accessed through
the {\vt @{\it device\/}[{\it param\/}]} construct.  In addition, the
variable ``{\vt x}'', which can appear explicitly in the expression,
is defined to be the controlling variable in dependent sources, or is
set to the scale variable in the analysis (e.g., {\et time} for
transient analysis).

The functions which are used in the device description should be
differentiable with respect to node voltages and branch currents to
promote convergence.  Internally, the expressions are symbolically
differentiated in order to calculate the Jacobian, which is used to
set up the matrix which is solved during analysis.  This would seem to
prevent use of the logical operators, modulus operator, relational
operators ({\vt <}, {\vt >}, etc.), and the tri-conditional operator
({\it a} {\vt ?} {\it b} {\vt :} {\it c\/}) in these expressions where
an operand depends on a node voltage or branch current.  However,
{\WRspice} currently supports relational and logic operators in source
expressions, by assuming identically zero derivatives for these
operators when differentiating.  We find, in practice, that this
rarely causes obvious convergence problems, at least if used in
moderation.

In addition to the built-in functions, expressions used in devices can
include user-defined functions, which must have been defined
previously with the {\cb define} command, or with a {\vt .param} line,
or in a parameter definition list in a subcircuit call or definition. 
These can be used with either math package.  Internally, they are
saved in a data structure known as a parse tree.  When a user-defined
function is called in the context of a device equation, checking is
performed on the user-defined function parse tree to see if any of the
non-differentiable operations are included.  If so, an error message
is generated, and the equation setup fails.

This being said, the situation is actually a bit more complicated.  As
the circuit is being set up, all device equations, after linking in
the user-defined functions if any, are ``simplified'' by evaluating
and collapsing all of the constant terms as far as possible.  This
evaluation allows {\bf all} of the operations.  In general, these
equations can be very complex, with lots of parameters and conditional
tests involving parameters.  However, after simplification, the
equation typically reduces to a much simpler form, and the
conditionals and other unsupported constructs will have disappeared.

The bottom line of all of this is that for equations that appear in a
device description, the circuit variables (node voltages and branch
currents) can't be used in tri-conditional and modulus
sub-expressions.  For example consider the following:

\begin{quote}\vt
.param myabs(a) = 'a < 0 ? -a : a'\\
.param mymax(x,y) = 'x > y ? x : y'\\
E2 2 0 function myabs(v(1))\\
E3 3 0 function mymax(v(1), 0)
\end{quote}

This will not work, as it specifically breaks the rules prohibiting
tri-conditionals.  However, it really should be possible to simulate a
circuit with behavior described as intended above, and it (usually)
is.  One needs to find ways of expressing the behavior by using
supported math.

For example, either of these alternatives would be an acceptable
alternative for {\vt myabs}.
\begin{quote}\vt
.param myabs(a) = abs(a)\\
.param myabs(a) = sqrt(a*a)
\end{quote}
For the special case of {\vt y = 0}, an acceptable substitute
for {\vt mymax} would be
\begin{quote}\vt
.param mymax(x,y) = 0.5*(abs(x) + x)
\end{quote}

Thus, the following lines are equivalent to the original
description, but will be accepted as {\WRspice} input.
\begin{quote}\vt
.param myabs(a) = abs(a)\\
.param mymax(x,y) = 0.5*(abs(x) + x)\\
E2 2 0 function myabs(v(1))\\
E3 3 0 function mymax(v(1), 0)
\end{quote}

Although the lists of math functions available in the two packages are
similar, the internal evaluation functions are different.  The shell
math functions must operate on vectors of complex values, whereas the
functions called in device expressions take scalar real values only. 
Furthermore, the device expressions must be differentiable with
respect to included node voltages and branch currents, as the
derivative of the expression is computed as part of the iterative
process of solving the circuit matrix equations.  We have seen that
this limits the operations available, and it likewise puts
restrictions on the functions.  The {\vt sgn} function grossly
violates the differentiability requirement, and many of the functions
and/or their derivatives have restricted ranges or singularities. 
These can easily lead to convergence problems unless some care is
exercised.

As for all expressions, if an expression is enclosed in single quotes,
it will be evaluated when the file is read, reducing to a constant. 
However, if the expression contains references to circuit variables
such as node voltages or branch currents, it will be left as an
expression, to be evaluated during the simulation.

The following math functions are available in device expressions
on most systems:

\begin{quote}
\begin{tabular}{|l|l|}\hline
{\vt abs}   & absolute value\\ \hline
{\vt acos}  & arc cosine\\ \hline
{\vt acosh} & arc hyperbolic cosine\\ \hline
{\vt asin}  & arc sine\\ \hline
{\vt asinh} & arc hyperbolic sine\\ \hline
{\vt atan}  & arc tangent\\ \hline
{\vt atanh} & arc hyperbolic tangent\\ \hline
{\vt cbrt}  & cube root\\ \hline
{\vt cos}   & cosine\\ \hline
{\vt cosh}  & hyperbolic cosine\\ \hline
{\vt deriv} & derivative\\ \hline
{\vt erf}   & error function\\ \hline
{\vt erfc}  & error function complement\\ \hline
{\vt exp}   & exponential (e raised to power)\\ \hline
{\vt j0}    & Bessel order 0\\ \hline
{\vt j1}    & Bessel order 1\\ \hline
{\vt jn}    & Bessel order {\it n\/}\\ \hline
{\vt ln}    & natural log\\ \hline
{\vt log}   & natural log\\ \hline
{\vt log10} & log base 10\\ \hline
{\vt pow}   & x to power y\\ \hline
{\vt pwr}   & x to power y\\ \hline
{\vt sgn}   & sign (+1,0,-1)\\ \hline
{\vt sin}   & sine\\ \hline
{\vt sinh}  & hyperbolic sine\\ \hline
{\vt sqrt}  & square root\\ \hline
{\vt tan}   & tangent\\ \hline
{\vt tanh}  & hyperbolic tangent\\ \hline
{\vt y0}    & Neumann order 0\\ \hline
{\vt y1}    & Neumann order 1\\ \hline
{\vt yn}    & Neumann order {\it n\/}\\ \hline
\end{tabular}
\end{quote}

Most functions take a single argument.  Exceptions are {\vt jn} and
{\vt yn}, which require two arguments.  The first argument is an
integer value for the order, and the second argument is the function
input.  The {\vt pow} and functionally identical {\vt pwr} functions
also require two arguments, the first argument being the base, and the
second being the exponent.  The {\vt deriv} function will
differentiate the parse tree of the argument with respect to the
``{\vt x}'' variable (whether implicit or explicit).  This is
completely unlike the {\vt deriv} function for vectors, which performs
a numerical differentiation with respect to some scale. 
Differentiating the parse tree gives an analytic result which is
generally more accurate.

In addition, there are special ``tran functions'' (see
\ref{tranfuncs}) which produce specified output in transient analysis. 
{\WRspice} recognizes by context functions and tran functions with the
same name ({\vt exp}, {\vt sin}, {\vt gauss}).  An unrecognized
function is assumed to be a table reference (specified with a {\vt
.table line}).

After simplification by collapsing all of the constant terms,
the following tokens are recognized in a device function.
\begin{quote}
\begin{tabular}{|l|l|}\hline
{\vt +,*,/} & binary: add, multiply, divide\\ \hline
{\vt -} & unary or binary: negate or subtract\\ \hline
{\vt \symbol{94}} & binary: exponentiation\\ \hline
{\vt ()} & association\\ \hline
{\vt ,} & argument separator\\ \hline
{\vt x} & independent variable\\ \hline
{\it number} & a floating point number\\ \hline
{\it string} & a library function, table, or circuit vector\\ \hline
\end{tabular}
\end{quote}

Additionally, the following relational and logical operators are
available.  Use of these operators may impede convergence.  The
operators evaluate to 1.0 when true, 0.0 otherwise.  Inputs to logical
operators are true if integer-converted values are nonzero.

\begin{quote}
\begin{tabular}{|l|l|}\hline
{\vt =,==,eq} & equality\\ \hline
{\vt !=,<>,><,ne} & inequality\\ \hline
{\vt >,gt} & greater than\\ \hline
{\vt <,lt} & less than\\ \hline
{\vt >=,ge} & greater than or equal\\ \hline
{\vt <=,le} & less than or equal\\ \hline
{\vt \&,\&\&,and} & logical and\\ \hline
{\vt $|$,$||$,or} & logical or\\ \hline
{\vt \symbol{126},!,not} & logical not\\ \hline
\end{tabular}
\end{quote}

The independent variable {\vt x} is context specific, and usually represents
a global input variable.  It is the running variable in the current
analysis (time in transient analysis, for example), or the input
variable in dependent source specifications (see \ref{depsrc}).

In a chained analysis, the {\vt x} variable will be that of core
analysis.  Thus, for a chained transient analysis, {\vt x} is time, as
in the unchained case.  Since the functional dependence is inoperable
in any kind of ac small-signal analysis (ac, noise, transfer function,
pz, distortion, ac sensitivity) {\vt x} is not set and never used.  In
``op'' analysis, {\vt x} is always numerically zero.  The same is true
in dc sensitivity analysis.

During a ``pure'' dc sweep analysis, for ``independent'' sources
(keyed by {\vt v}, {\vt i}, or {\vt a} and not {\vt e}, {\vt f}, {\vt
g}, or {\vt h}) other than the swept ones, if an expression is given,
the output of the source will be the result of the expression where
the input {\vt x} is the swept voltage (or the first sweep voltage if
there are two), rather than time as when in transient anslysis. 
However, if the source line has a ``dc'' keyword and optional
following constant value, during pure dc analysis the source will
output the fixed value, or zero, if the value is omitted.  However, in
pure dc analysis the tran functions generally return zero.  The
exceptions are {\vt pwl}, {\vt table} and table references, and {\vt
interp}.  These functions return values, but with the swept voltage
({\vt x}) as the input (in the case of {\vt table} the input may be
explicit anyway).  For ``dependent'' sources (keyed by {\vt e}, {\vt
f}, {\vt g}, or {\vt h}) the {\vt x} is the controlling voltage or
current as in transient analysis.  Again, if a ``dc'' keyword appears,
the output will be fixed at the given value, ignoring the controlling
variable.

Since circuit ``vector'' names used in device expressions must be
resolved before the actual vector is created, there is a potential for
error not present in normal vector expressions.  In particular, name
clashes between circuit node names and vectors in the {\vt constants}
plot can cause trouble.

In a device expressions, if a string token starts with a backslash
('$\backslash$') character, it will not be replaced with a value,
should the name happen to match one of the named constants, or other
potential substitution.  This will be needed, for example, if a node
name matches one of the predefined constant names, and one needs to
reference that node in a source expression.  The token should be
double quoted to ensure this interpretation by the parser.

For example, suppose there is a node named ``{\vt c}'', which is also
the name of a vector in the {\vt constants} plot.  Such a vector
existed in earlier {\WRspice} releases, as it was the speed of
light constant.  This constant is now named ``{\vt const\_c}'' so a
clash with this is unlikely.  However, the user can create a vector
named ``{\vt c}'' in the {\vt constants} plot, so the possibility of a
clash remains.

A source specification like
\begin{quote}\vt
vcon 1 2 5*v(c)
\end{quote}
will cause an error, possibly not until simulation time.  This
can be avoided by use of the form described above.
\begin{quote}\vt
vcon 1 2 5*v("$\backslash$c")
\end{quote}

!!SEEALSO
tranfuncs
polyexpr 
src

!! elements.tex 012509
!!KEYWORD
polyexpr 
!!TITLE
POLY Expressions
!!HTML 
    In SPICE2, nonlinear polynomial dependencies are specified using a
    rather cumbersome syntax keyed by the word <tt>poly</tt>.  For
    compatibility, this syntax is recognized by the dependent sources
    in <i>WRspice</i>, making possible the use of the large number of
    behavioral models developed for SPICE2.

    <p>
    There are three polynomial equations which can be specified through the
    <tt>poly</tt>(<i>N</i>) parameter.

    <dl><dt><tt>poly(1)</tt><dd>One-dimensional equation</dl>
    <dl><dt><tt>poly(2)</tt><dd>Two-dimensional equation</dl>
    <dl><dt><tt>poly(3)</tt><dd>Three-dimensional equation</dl>

    <p>
    The dimensionality refers to the number of controlling variables;
    one, two, or three.  These parameters must immediately follow the
    <tt>poly</tt>(<i>N</i>) token.  The inputs must correspond to the
    type of the source, either pairs of nodes for voltage-controlled
    sources, or voltage source or inductor names for
    current-controlled sources.  Following the inputs is the list of
    polynomial coefficients which define the equation.  These are
    constants, and may be in any format recognized by <i>WRspice</i>.

    <p>
    The simplest case is one dimension, where the coefficients
    <tt>c0, c1, ...</tt> evaluate to  
    <blockquote>
     c0 + c1*x + c2*x<sup>2</sup> + c3*x<sup>3</sup> + ...
    </blockquote>

    <p>
    The number of terms is arbitrary.  If the number of terms is
    exactly one, it is assumed to be the linear term (<tt>c1</tt>) and
    not the constant term.  The following is an example of a
    voltage-controlled voltage source which utilizes <tt>poly(1)</tt>.
    <blockquote>
     <tt>epolysrc 1 0 poly(1) 3 2 0 2 0.25</tt>
    </blockquote>

    <p>
    The source output appears at node 1 to ground (note that
    <i>WRspice</i> can use arbitrary strings as node specifiers).  The
    input is the voltage difference between nodes 3 and 2.  The output
    voltage is twice the input voltage plus .25 times the square of
    the input voltage.

    In the two dimensional case, the coefficients are interpreted in
    the following order.
    <blockquote>
     c0 + c1*x + c2*y + c3*x<sup>2</sup> + c4*x*y + c5*y<sup>2</sup> +
     c6*x<sup>3</sup> + c7*x<sup>2</sup>*y + c8*x*y<sup>2</sup> +
     c9*y<sup>3</sup> + ...
    </blockquote>

    For example, to specify a source which produces
    3.5*v(3,4) + 1.29*v(8)*v(3,4), one has
    <blockquote>
        <tt>exx 1 0 poly(2) 3 4 8 0 0 3.5 0 0 1.29</tt>
    </blockquote>
    Note that any coefficients that are unspecified are taken as zero.

    <p>
    The three dimensional case has a coefficient ordering interpretation
    given by
    <blockquote>
     c0 + c1*x + c2*y + c3*z + c4*x<sup>2</sup> + c5*x*y + c6*x*z +
     c7*y<sup>2</sup> + c8*y*z + c9*z<sup>2</sup> + c10*x<sup>3</sup> +
     c11*x<sup>2</sup>*y + c12*x<sup>2</sup>*z * c13*x*y<sup>2</sup> +
     c14*x*y*z + c15*x*z<sup>2</sup> + c16*y<sup>3</sup> +
     c17*y<sup>2</sup>*z + c18*y*z<sup>2</sup> + c19*z<sup>3</sup> + ...
    </blockquote>
    which is rather complex but careful examination reveals the pattern.
!!LATEX polyexpr elements.tex
In SPICE2, nonlinear polynomial dependencies are specified using a
rather cumbersome syntax keyed by the word {\vt poly}.  For
compatibility, this syntax is recognized by the dependent sources in
{\WRspice}, making possible the use of the large number of behavioral
models developed for SPICE2.

There are three polynomial equations which can be specified through the
{\vt poly({\it N\/})} parameter.
\begin{description}
\item{\vt poly(1) \rm One-dimensional equation}
\item{\vt poly(2) \rm Two-dimensional equation}
\item{\vt poly(3) \rm Three-dimensional equation}
\end{description}
The dimensionality refers to the number of controlling variables; one,
two, or three.  These parameters must immediately follow the {\vt
poly({\it N\/})} token.  The inputs must correspond to the type of the
source, either pairs of nodes for voltage-controlled sources, or
voltage source or inductor names for current-controlled sources. 
Following the inputs is the list of polynomial coefficients which
define the equation.  These are constants, and may be in any format
recognized by {\WRspice}.

The simplest case is one dimension, where the coefficients {\vt c0, c1, ...}
evaluate to
\begin{displaymath}
c_0 + c_1x + c_2x^2 + c_3x^3 + ...
\end{displaymath}
The number of terms is arbitrary.  If the number of terms is exactly one,
it is assumed to be the linear term ({\vt c1}) and not the constant
term.  The following is an example of a voltage-controlled voltage source
which utilizes {\vt poly(1)}.
\begin{quote}\vt
epolysrc 1 0 poly(1) 3 2 0 2 0.25
\end{quote}
The source output appears at node 1 to ground (note that {\WRspice} can use
arbitrary strings as node specifiers).  The input is the voltage difference
between nodes 3 and 2.  The output voltage is twice the input voltage
plus .25 times the square of the input voltage.

In the two dimensional case, the coefficients are interpreted in the
following order.
\begin{displaymath}
c_0 + c_1x + c_2y + c_3x^2 + c_4xy + c_5y^2 + c_6x^3 + c_7x^2y +
c_8xy^2 + c_9y^3 + ...
\end{displaymath}
For example, to specify a source which produces
{\vt 3.5*v(3,4) + 1.29*v(8)*v(3,4)}, one has
\begin{quote}
exx 1 0 poly(2) 3 4 8 0 0 3.5 0 0 1.29
\end{quote}
Note that any coefficients that are unspecified are taken as zero.

The three dimensional case has a coefficient ordering interpretation
given by
\begin{displaymath}
c_0 + c_1x + c_2y + c_3z + c_4x^2 + c_5xy + c_6xz + c_7y^2 + c_8yz +
c_9z^2 + c_{10}x^3 + c_{11}x^2y + c_{12}x^2z +
\end{displaymath}
\begin{displaymath}
c_{13}xy^2 + c_{14}xyz + c_{15}xz^2 + c_{16}y^3 + c_{17}y^2z + c^{18}yz^2 +
c_{19}z^3 + ...
\end{displaymath}
which is rather complex but careful examination reveals the pattern.

!!SEEALSO
devexpr
depsource

!! elements.tex 031516
!!KEYWORD
tranfuncs 
!!TITLE
Tran Functions
!!HTML
    There are several built-in source functions, which are based on
    and extend the source specifications in SPICE2.  These generally
    produce time-dependent output for use in transient analysis.  For
    brevity, these functions are referred to as "tran functions".

    <p>
    The tran functions are listed in the table below.  If parameters
    other than source amplitudes are omitted, default values will be
    assumed.  The tran functions, which require multiple space or
    comma separated arguments in a particular order, are:

    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><td><a href="texp"><tt>exp</tt></a></td>
     <td>exponential specification</td></tr>
    <tr><td><a href="texp"><tt>texp</tt></a></td>
     <td>exponential specification</td></tr>
    <tr><td><a href="tgauss"><tt>gauss</tt></a></td>
     <td>gaussian noise specification</td></tr>
    <tr><td><a href="tgauss"><tt>tgauss</tt></a></td>
     <td>gaussian noise specification</td></tr>
    <tr><td><a href="interp"><tt>interp</tt></a></td>
     <td>interpolation specification</td></tr>
    <tr><td><a href="pulse"><tt>pulse</tt></a></td>
     <td>pulse specification</td></tr>
    <tr><td><a href="gpulse"><tt>gpulse</tt></a></td>
     <td>gaussian pulse specification</td></tr>
    <tr><td><a href="pwl"><tt>pwl</tt></a></td>
     <td>piecewise-linear specification</td></tr>
    <tr><td><a href="sffm"><tt>sffm</tt></a></td>
     <td>single frequency fm specification</td></tr>
    <tr><td><a href="am"><tt>am</tt></a></td>
     <td>amplitude modulated specification</td></tr>
    <tr><td><a href="tsin"><tt>sin</tt></a></td>
     <td>sinusoidal specification</td></tr>
    <tr><td><a href="tsin"><tt>tsin</tt></a></td>
     <td>sinusoidal specification</td></tr>
    <tr><td><a href="spulse"><tt>spulse</tt></a></td>
     <td>sinusoidal pulse specification</td></tr>
    <tr><td><a href="table"><tt>table</tt></a></td>
     <td>reference to a <tt>.table</tt> specification</td></tr>
    </table>
    </blockquote>

    <p>
    The the <tt>texp</tt>, <tt>tgauss</tt>, and <tt>tsin</tt> are
    aliases to <tt>exp</tt>, <tt>gauss</tt>, and <tt>sin</tt> tran
    functions that avoid possible ambiguity with math functions of the
    same name.

    <p>
    Unlike the math functions, the tran functions have variable-length
    argument lists.  If arguments are omitted, default values are
    assumed.

    <p>
    The tran functions are most often used to specify voltage/current
    source output, however in <i>WRspice</i> these can be used in
    general expressions.  The <tt>sin</tt>, <tt>exp</tt>,
    <tt>gauss</tt> tran functions have names that conflict with math
    functions.  There seems to be no way to absolutely reliably
    distinguish the tran vs.  math functions by context, nor is it
    possible to exclusively rename the functions without causing huge
    compatibility problems.

    <p>
    Although the <tt>sin</tt> and <tt>exp</tt> functions are generally
    distinguishable except for one unlikely case, with the additional
    arguments to the <tt>gauss</tt> function for <a
    href="hspicesim">HSPICE</a> compatibility in <i>WRspice</i>
    release 3.0.0, the problem is more acute.

    <p>
    It may be necessary to edit legacy <i>WRspice</i> input files to
    avoid this problem.

    <p>
    That being said, new intelligence has been added to differentiate
    between the two species.  As in older releases, the argument count
    will in many cases resolve ambiguity.

    <p>
    First of all, to guarantee that the tran functions are used in an
    expression, they can be called by the synonym names <tt>tsin</tt>,
    <tt>texp</tt>, and <tt>tgauss</tt>.

    <p>
    If <tt>sin</tt>, <tt>exp</tt>, or <tt>gauss</tt> use white-space
    delimiting in the argument list, then they will be called as tran
    functions.  The math functions always use commas to separate
    arguments.  Commas are also legal argument separators in tran
    functions, but (perhaps) are not as frequently used.  If comma
    argument separators are used, the math functions are assumed.

    <p>
    Note that almost all math functions (with the exception of
    <tt>gauss</tt> and a few others) take a single complex vector
    argument.  It is possible to give these functions multiple
    comma-separated "arguments", but in evaluation these are collapsed
    by evaluation of the comma operator:
    <blockquote>
    <tt>a,b = (a + j*b)</tt>
    </blockquote>
    So, <tt>sin(1,1)</tt> is equivalent to <tt>sin((1+j))</tt>, which
    returns a complex value.

    <p>
    In earlier <i>WRspice</i> releases, <tt>sin(a,b)</tt> was always
    interpreted as the tran <tt>sin</tt> function, which has a minimum
    of two arguments (and similar for <tt>exp</tt>).  Presently.
    <blockquote>
    <tt>sin(a,b)</tt> comma delimiter implies math<br>
    <tt>sin(a b)</tt> space delimiter implies tran
    </blockquote>

    <p>
    If ambiguity occurs in a function specification for a voltage or
    current source, the tran function is favored if the specification
    is ambiguous.

    <p>
    The tran functions implicitly use time as an independent variable,
    and generally return 0 in dc analysis.  Exceptions are the
    <tt>pwl</tt> and <tt>interp</tt> forms, which implicitly use the
    value of "<tt>x</tt>" which is <a
    href="devexpr">context-specific</a>.  In dependent sources, this
    is the controlling value of the source rather than time.  The
    <tt>table</tt> function takes its input directly from the second
    argument.

    <p>
    The tran functions can also be used in regular vector expressions. 
    They generate a vector corresponding to the current scale, which
    must exist, be real, and monotonically increasing.  The length of
    the returned vector is equal to the length of the scale.

    <p>
    For example:
    <blockquote>
        (do a tran analysis to establish a reasonable scale)<br>
        <tt>let a = pulse(0 1 10n 10n 10n 20n)</tt><br>
        <tt>plot a</tt>    (plots a pulse waveform)
    </blockquote>
    The construct can be used like any other token in a regular
    vector expression.

    <p>
    The tran functions (other than <tt>table</tt> and
    <tt>interp</tt>) take constant expressions as arguments.  The
    argument list consists of comma or space separated expressions. 
    Arguments are parsed as follows:

    <ol>
    <li>The outer parentheses, if these exist, are stripped from the
     list.  <i>WRspice</i> can recognize most instances where
     parentheses are not included, since these are optional in
     standard SPICE syntax for the tran functions.

    <p>
    <li>Commas that are not enclosed in parentheses or square brackets are
     converted to spaces.
    <p>
    <p>
    <li>Minus signs ('-') that are not enclosed in parentheses or
      square brackets, and are not followed by white space, and are
      preceded by white space, are assumed to be the start of a new
      token (argument).  An expression termination character
      (semicolon) is added to the end of the previous argument.

    <p>
    <li>The string is parsed into individual expression units, which are
      the arguments.  The separation is determined by context.
    </ol>

    <p>
    There is no provision for a unary '+', thus, <tt>func(a, +b)</tt>
    is taken as <tt>func(a+b)</tt>.  Parenthesis can be added to
    enforce precedence.  The minus sign handling implies that
    <tt>func(a, -b)</tt> and <tt>func(a -b)</tt> are taken as
    <tt>func((a), (-b))</tt>, whereas <tt>func(a-b)</tt>, <tt>func(a-
    b)</tt>, <tt>func(a - b)</tt>, etc.  are taken as
    <tt>func((a)-(b))</tt>.

    <p>
    In addition to the built-in functions, expressions used in sources
    can include user defined functions, which must have been defined
    previously with the <a href="define"><b>define</b></a> command. 
    These may be useful for encapsulating the tran functions.

    <p>
    Example:
    <blockquote>
      <tt>define mypulse(delay, width) pulse(0 1 delay 1n 1n width)</tt><br>
      ....<br>
      <tt>v1 1 0 mypulse(5n, 10n)</tt>
    </blockquote>

    <p>
    Recall that a line in the deck starting with "<tt>*@</tt>" will be
    executed before the deck is parsed.

    <blockquote><tt>
      title line<br>
      *@ define mypulse(delay, width) pulse(0 1 delay 1n 1n width)<br>
      v1 1 0 mypulse(5n, 10n)<br>
      r1 1 0 100<br>
      .end<br>
    </tt></blockquote>
!!LATEX tranfuncs elements.tex
There are several built-in source functions, which are based on and
extend the source specifications in SPICE2.  These generally produce
time-dependent output for use in transient analysis.  For brevity,
these functions are referred to as ``tran functions''.

The tran functions are listed in the table below.  If parameters other
than source amplitudes are omitted, default values will be assumed. 
The tran functions, which require multiple space or comma separated
arguments in a particular order, are:

\begin{quote}
\begin{tabular}{|l|l|}\hline
\vt exp    & exponential specification\\ \hline
\vt texp   & exponential specification\\ \hline
\vt gauss  & gaussian noise specification\\ \hline
\vt tgauss & gaussian noise specification\\ \hline
\vt interp & interpolation specification\\ \hline
\vt pulse  & pulse specification\\ \hline
\vt gpulse & gaussian pulse specification\\ \hline
\vt pwl    & piecewise-linear specification\\ \hline
\vt sffm   & single frequency fm specification\\ \hline
\vt am     & amplitude modulated specification\\ \hline
\vt sin    & sinusoidal specification\\ \hline
\vt tsin   & sinusoidal specification\\ \hline
\vt spulse & sinusoidal pulse specification\\ \hline
\vt table  & reference to a {\vt .table} specification\\ \hline
\end{tabular}
\end{quote}

The the {\vt texp}, {\vt tgauss}, and {\vt tsin} are aliases to {\vt
exp}, {\vt gauss}, and {\vt sin} tran functions that avoid possible
ambiguity with math functions of the same name.

Unlike the math functions, the tran functions have variable-length
argument lists.  If arguments are omitted, default values are assumed. 

The tran functions are most often used to specify voltage/current
source output, however in {\WRspice} these can be used in general
expressions.  The {\vt sin}, {\vt exp}, {\vt gauss} tran functions
have names that conflict with math functions.  There seems to be no
way to absolutely reliably distinguish the tran vs.  math functions by
context, nor is it possible to exclusively rename the functions
without causing huge compatibility problems.

Although the {\vt sin} and {\vt exp} functions are generally
distinguishable except for one unlikely case, with the additional
arguments to the {\vt gauss} function for HSPICE compatibility in
{\WRspice} release 3.0.0, the problem is more acute.

It may be necessary to edit legacy {\WRspice} input files to avoid
this problem.

That being said, new intelligence has been added to differentiate
between the two species.  As in older releases, the argument count
will in many cases resolve ambiguity.

First of all, to guarantee that the tran functions are used in an
expression, they can be called by the synonym names {\vt tsin}, {\vt
texp}, and {\vt tgauss}.

If {\vt sin}, {\vt exp}, or {\vt gauss} use white-space delimiting in
the argument list, then they will be called as tran functions.  The
math functions always use commas to separate arguments.  Commas are
also legal argument separators in tran functions, but (perhaps) are
not as frequently used.  If comma argument separators are used, the
math functions are assumed.

Note that almost all math functions (whith the exception of {\vt
gauss} and a few others) take a single complex vector argument.  It is
possible to give these functions multiple comma-separated
``arguments'', but in evaluation these are collapsed by evaluation of
the comma operator:
\begin{quote}\vt
a,b = (a + j*b)
\end{quote}
So, {\vt sin(1,1)} is equivalent to {\vt sin((1+j))}, which returns a
complex value.

In earlier {\WRspice} releases, {\vt sin(a,b)} was always interpreted
as the tran {\vt sin} function, which has a minimum of two arguments
(and similar for {\vt exp}).  Presently.
\begin{quote}
{\vt sin(a,b)}  comma delimiter implies math\\
{\vt sin(a b)}  space delimiter implies tran
\end{quote}

If ambiguity occurs in a function specification for a voltage or
current source, the tran function is favored if the specification is
ambiguous.

The tran functions implicitly use time as an independent variable, and
generally return 0 in dc analysis.  Exceptions are the {\vt pwl} and
{\vt interp} forms, which implicitly use the value of ``{\vt x}''
which is context-specific.  In dependent sources, this is the
controlling value of the source rather than time.  The {\vt table}
function takes its input directly from the second argument.

\index{tran functions, in expressions}
The tran functions can also be used in regular vector expressions. 
They generate a vector corresponding to the current scale, which must
exist, be real, and monotonically increasing.  The length of the
returned vector is equal to the length of the scale.
 
For example:
\begin{quote}
(do a tran analysis to establish a reasonable scale)\\
{\vt let a = pulse(0 1 10n 10n 10n 20n)}\\
{\vt plot a}\hspace{1cm}(plots a pulse waveform)\\
\end{quote}
The construct can be used like any other token in a regular vector
expression.

The tran functions (other than {\vt table} and {\vt interp}) take
constant expressions as arguments.  The argument list consists of
comma or space separated expressions.  Arguments are parsed as
follows:

\begin{enumerate}
\item{The outer parentheses, if these exist, are stripped from the list.
     {\WRspice} can recognize most instances where parentheses are not
     included, since these are optional in standard SPICE syntax for the
     tran functions.}
\item{Commas that are not enclosed in parentheses or square brackets are
     converted to spaces.}
\item{Minus signs (`{\vt -}') that are not enclosed in parentheses or square
      brackets, and are not followed by white space, and are preceded
      by white space, are assumed to be the start of a new token
      (argument).  An expression termination character (semicolon) is
      added to the end of the previous argument.}
\item{The string is parsed into individual expression units, which are
      the arguments.  The separation is determined by context.}
\end{enumerate}

There is no provision for a unary `{\vt +}', thus, {\vt func(a, +b)} is
taken as {\vt func(a+b)}.  Parenthesis can be added to enforce
precedence.  The minus sign handling implies that {\vt func(a, -b)} and
{\vt func(a -b)} are taken as {\vt func((a), (-b))}, whereas
{\vt f(a-b), f(a- b), f(a - b)}, etc are taken as {\vt func((a)-(b))}.

\index{user-defined functions}
In addition to the built-in functions, expressions used in sources can
include user defined functions, which must have been defined
previously with the {\cb define} command.  These may be useful for
encapsulating the tran functions.

\spexampo{
      define mypulse(delay, width) pulse(0 1 delay 1n 1n width)\\
      ...\\
      v1 1 0 mypulse(5n, 10n)}

Recall that a line in the deck starting with ``{\vt *@}" will be
executed before the deck is parsed.

\begin{quote}\vt
      title line\\
      {\vt *@} define mypulse(delay, width) pulse(0 1 delay 1n 1n width)\\
      v1 1 0 mypulse(5n, 10n)\\
      r1 1 0 100\\
      .end
\end{quote}

The following paragraphs describe the tran functions in detail.

!!SEEALSO
expressions
devexpr
spsource

!! elements.tex 060119
!!KEYWORD
texp
!!TITLE
Exponential
!!HTML 
    General forms:
    <blockquote>
        <tt>exp</tt>(<i>v1 v2</i> [<i>td1 tau1 td2 tau2</i>])
    </blockquote>

    <p>
    Examples:
    <blockquote>
        <tt>vin 3 0 exp(-4 -1 2ns 30ns 60ns 40ns)</tt>
    </blockquote>

    <p>
    This function can be called as <tt>texp</tt> to avoid possible
    conflict with the <a href="mathfuncs#exp"><tt>exp</tt></a> math
    function.

    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th>parameter</th><th>description</th>
        <th>default value</th><th>units</th></tr>
    <tr><td><i>v1</i></td> <td>initial value</td>
        <td>&nbsp;</td> <td>volts or amps</td></tr>
    <tr><td><i>v2</i></td> <td>pulsed value</td>
        <td>&nbsp;</td> <td>volts or amps</td></tr>
    <tr><td><i>td1</i></td> <td>rise delay time</td>
        <td><tt>0.0</tt></td> <td>seconds</td></tr>
    <tr><td><i>tau1</i></td> <td>rise time constant</td>
        <td><tt>tstep</tt></td> <td>seconds</td></tr>
    <tr><td><i>td2</i></td> <td>fall delay time</td>
        <td><i>td1</i><tt>+tstep</tt></td> <td>seconds</td></tr>
    <tr><td><i>tau2</i></td> <td>fall time constant</td>
        <td><tt>tstep</tt></td> <td>seconds</td></tr>
    </table>

    <p>
    The shape of the waveform is described by the following table:

    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th>time</th>  <th>value</th></tr>
    <tr><td><tt>0</tt> to <i>td1</i></td> <td><i>v1</i></tr>
    <tr><td><i>td1</i> to <i>td2</i></td>
        <td><i>v1</i>+(<i>v2</i>-<i>v1</i>)*(1-<tt>exp</tt>(-(<tt>time</tt>-<i>td1</i>)/<i>tau1</i>))</tt></td></tr>
    <tr><td><tt>td2</tt> to <tt>tstop</tt></td>
        <td><i>v1</i>+(<i>v2</i>-<i>v1</i>)*(1-<tt>exp</tt>(-(<tt>time</tt>-<i>td1</i>)/<i>tau1</i>))<br>
        +(<i>v1</i>-<i>v2</i>)*(1-<tt>exp</tt>(-(<tt>time</tt>-<i>td2</i>)/<i>tau2</i>))</td></tr>
    </table>
    </blockquote>
 
    <p>
    This function applies only to transient analysis, where time is
    the running variable.  When referring to default values,
    <tt>tstep</tt> is the printing increment and <tt>tstop</tt> is the
    final time in <a href=".tran"> transient analysis</a>.  The
    argument count is used to distinguish this function from the math
    function of the same name.

    <p>
    If this function is used bare and not part of an expression in a
    voltage or current source, then the general source instance
    parameters <tt>prm1</tt> etc.  map as below.  It is possible to
    read and alter these values using the special vector
    @<i>device</i>[<i>param</i>] construct, or with the <a
    href="alter"><b>alter</b></a> and <a href="sweep"><b>sweep</b></a>
    commands.  However, there is no sanity checking so bad numbers can
    cause wild behavior or worse.

    <blockquote>
    <table border=0 cellspacing=4>
    <tr><td>prm1</td><td>v1</td></tr>
    <tr><td>prm2</td><td>v2</td></tr>
    <tr><td>prm3</td><td>td1</td></tr>
    <tr><td>prm4</td><td>tau1</td></tr>
    <tr><td>prm5</td><td>td2</td></tr>
    <tr><td>prm6</td><td>tau2</td></tr>
    </table>
    </blockquote>
!!LATEX text elements.tex
\spgen{exp({\it v1 v2\/} [{\it td1 tau1 td2 tau2\/}])}
\spexampo{vin 3 0 exp(-4 -1 2ns 30ns 60ns 40ns)}

This function can be called as {\vt texp} to avoid possible conflict
with the {\vt exp} math function.

\begin{quote}
\begin{tabular}{|l|l|l|l|} \hline
{\bf parameter} & {\bf description} & {\bf default value} &
 {\bf units}\\ \hline\hline
{\it v1} & initial value & & volts or amps\\ \hline
{\it v2} & pulsed value & & volts or amps\\ \hline
{\it td1} & rise delay time & 0.0 & seconds\\ \hline
{\it tau1} & rise time constant & {\vt tstep} & seconds\\ \hline
{\it td2} & fall delay time & {\it td1} + {\vt tstep} & seconds\\ \hline
{\it tau2} & fall time constant & {\vt tstep} & seconds\\ \hline
\end{tabular}
\end{quote}

The shape of the waveform is described by the following table:

\begin{quote}
\begin{tabular}{ll}
{\bf time} & {\bf value}\\[0.5ex]
0 & {\it v1\/}\\
{\it td1\/} & {\it v1\/} $+$ ({\it v2\/}$-${\it v1\/})(1 $-$
 exp($-$(time$-${\it td1\/})/{\it tau1\/}))\\
{\it td2\/} & {\it v1\/} $+$ ({\it v2\/}$-${\it v1\/})(1 $-$
exp($-$(time$-${\it td1\/})/{\it tau1\/})) $+$\\
 & ({\it v1\/}$-${\it v2\/})(1 $-$ exp($-$(time$-${\it
 td2\/})/{\it tau2\/}))\\[2ex]
\end{tabular}
\end{quote}

This function applies only to transient analysis, where time is the
running variable.  When referring to default values, {\vt tstep} is
the printing increment and {\vt tstop} is the final time in transient
analysis, see \ref{tranline} for explanation.  The argument count is
used to distinguish this function from the math function of the same
name.

If this function is used bare and not part of an expression in a
voltage or current source, then the general source instance parameters
{\vt prm1} etc.  map as below.  It is possible to read and alter these
values using the special vector @{\it device}[{\it param\/}]
construct, or with the {\cb alter} and {\cb sweep} commands.  However,
there is no sanity checking so bad numbers can cause wild behavior or
worse.

\begin{quote}
\begin{tabular}{ll}
prm1 & v1\\
prm2 & v2\\
prm3 & td1\\
prm4 & tau1\\
prm5 & td2\\
prm6 & tau2\\
\end{tabular}
\end{quote}
 
!!SEEALSO
tranfuncs

!! elements.tex 060119
!!KEYWORD
tgauss
!!TITLE
Gaussian Random
!!HTML 
    General form:
    <blockquote>
        <tt>gauss</tt>(<i>stddev mean lattice</i> [<i>interp</i>])
    </blockquote>

    <p>
    Examples:
    <blockquote></tt>
        v1 1 0 gauss(.5 2 100n 1)<br>
        v2 1 0 gauss(.1 0 0)
    </tt></blockquote>

    <p>
    This function can be called as <tt>tgauss</tt> to avoid possible
    conflict with the <a href="hs_functions#gauss"><tt>gauss</tt></a>
    math function.

    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th>parameter</th><th>description</th>
        <th>default value</th><th>units</th></tr>
    <tr><td><i>stddev</i></td> <td>standard deviation</td>
        <td>-</td> <td>none</td></tr>
    <tr><td><i>mean</i></td> <td>mean value</td>
        <td>-</td> <td>none</td></tr>
    <tr><td><i>lattice</i></td> <td>sample period</td>
        <td>-</td> <td>seconds</td></tr>
    <tr><td><i>interp</i></td> <td>interpolation</td>
        <td>0</td> <td>none</td></tr>
    </table>

    <p>
    The <tt>gauss</tt> function can be used to generate correlated
    random output.  This function takes three or four arguments.

    <p>
    The parameter <i>lattice</i> is for use in transient analysis.  A
    new random value is computed at each time increment of
    <i>lattice</i>.  If <i>lattice</i> is 0, then no lattice is used,
    and an uncorrelated random number is returned for each call.  The
    <i>interp</i> parameter, used when <i>lattice</i> is nonzero, can
    have value 1 or 0.  If <i>interp</i> is nonzero, the value
    returned by the function is the (first order) interpolation of the
    random values at the lattice points which frame the time variable. 
    If <i>interp</i> is 0, the function returns the lattice cell's
    value for any time within the lattice cell, i.e., a random step
    with an amplitude change at every lattice point.

    <p>
    The first example above provides a random signal with standard
    deviation of .5V and mean of 2V, based on random samples taken
    every 100nS.

    <p>
    The <i>lattice</i> value should be on the order of the user print
    increment <tt>tstep</tt> in the <a href=".tran">transient
    analysis</a>.  It should not be less than the maximum internal
    time step, since the past history is not stored, and a rejected
    time point may back up the time across more than one lattice cell,
    thus destroying the correlation.

    <p>
    This function applies only to transient analysis, where time is
    the running variable.  The argument count is used to distinguish
    this function from the math function of the same name.

    <p>
    If this function is used bare and not part of an expression in a
    voltage or current source, then the general source instance
    parameters <tt>prm1</tt> etc.  map as below.  It is possible to
    read and alter these values using the special vector
    @<i>device</i>[<i>param</i>] construct, or with the <a
    href="alter"><b>alter</b></a> and <a href="sweep"><b>sweep</b></a>
    commands.  However, there is no sanity checking so bad numbers can
    cause wild behavior or worse.

    <blockquote>
    <table border=0 cellspacing=4>
    <tr><td>prm1</td><td>stddev</td></tr>
    <tr><td>prm2</td><td>mean</td></tr>
    <tr><td>prm3</td><td>lattice</td></tr>
    <tr><td>prm4</td><td>interp</td></tr>
    </table>
    </blockquote>

    <p>
    One important application of this function is to provide
    time-domain noise generation for <a href="refs#jeffery">noise
    modeling</a>.  For example, below is a circuit which simulates the
    thermal noise generated in a resistor at 4.2K.

    <blockquote><tt>
    *** noise demo<br>
    *@ define noise(r,t,dt,n) gauss(sqrt(2*boltz*t/(r*dt)), 0, dt, n)<br>
    r1 1 0 1.0<br>
    ir1 1 0 noise(1.0, 4.2, 0.5p, 1)<br>
    c1 1 0 1p<br>
    <br>
    .control<br>
    tran 1p 1n<br>
    plot v(1)<br>
    .endc<br>
    </tt></blockquote>

    The second line defines a function named "noise" that takes four
    arguments:  the resistance, temperature in Kelvin, the lattice
    time increment, and the interpolation method.  This is simply a
    wrapper around a <tt>gauss</tt> call, incorporating the standard
    noise equation for current through a resistor at a given
    temperature, and taking the inherent bandwidth to be one half of
    the reciprocal of the lattice time increment (per Nyquist).  The
    noise function is used in the specification for current source
    <tt>ir1</tt>.  In a more complicated case, each resistor in a
    circuit may have an associated noise current source similarly
    defined.  It may be possible to demonstrate errors due to thermal
    noise when simulating the circuit.
!!LATEX tgauss elements.hlp
\spgen{gauss({\it stddev\/} {\it mean\/} {\it lattice\/} [{\it interp\/}])}
\spexamp{v1 1 0 gauss(.5, 2, 100n, 1)\\
    v2 1 0 gauss(.1, 0, 0)}

This function can be called as {\vt tgauss} to avoid possible conflict
with the {\vt gauss} math function.

\begin{quote}
\begin{tabular}{|l|l|l|l|} \hline
{\bf parameter} & {\bf description} & {\bf default value} &
 {\bf units}\\ \hline\hline
{\it stddev\/} & standard deviation &  & none\\ \hline
{\it mean\/} & mean value &  & none\\ \hline
{\it lattice\/} & sample period &  & seconds\\ \hline
{\it interp\/} & interpolation & 0 & none\\ \hline
\end{tabular}
\end{quote}

The {\vt gauss} function can be used to generate correlated random
output.  This function takes three or four arguments.

The parameter {\it lattice} is for use in transient analysis.  A new
random value is computed at each time increment of {\it lattice}.  If
{\it lattice} is 0, then no lattice is used, and an uncorrelated
random value is returned for each call.  The {\it interp} parameter,
used when {\it lattice} is nonzero, can have value 1 or 0.  If {\it
interp} is nonzero, the value returned by the function is the (first
order) interpolation of the random values at the lattice points which
frame the time variable.  If {\it interp} is 0, the function returns
the lattice cell's value for any time within the lattice cell, i.e., a
random step with an amplitude change at every lattice point.

The first example above provides a random signal with standard
deviation of .5V and mean of 2V, based on random samples taken every
100nS.

The {\it lattice} value should be on the order of the user print
increment {\vt tstep} in the transient analysis.  It should not be
less than the maximum internal time step, since the past history is
not stored, and a rejected time point may back up the time across more
than one lattice cell, thus destroying the correlation.

This function applies only to transient analysis, where time is the
running variable.  The argument count is used to distinguish this
function from the math function of the same name.

If this function is used bare and not part of an expression in a
voltage or current source, then the general source instance parameters
{\vt prm1} etc.  map as below.  It is possible to read and alter these
values using the special vector @{\it device}[{\it param\/}]
construct, or with the {\cb alter} and {\cb sweep} commands.  However,
there is no sanity checking so bad numbers can cause wild behavior or
worse.

\begin{quote}
\begin{tabular}{ll}
prm1 & stddev\\
prm2 & mean\\
prm3 & lattice\\
prm4 & interp\\
\end{tabular}
\end{quote}

One important application of this function is to provide time-domain
noise generation for noise modeling\cite{jeffery}.  For example, below
is a circuit which simulates the thermal noise generated in a resistor
at 4.2K.
 
\begin{quote}\vt
*** noise demo\\
{\vt *@} define noise(r,t,dt,n) gauss(sqrt(2*boltz*t/(r*dt)), 0, dt, n)\\
r1 1 0 1.0\\
ir1 1 0 noise(1.0, 4.2, 0.5p, 1)\\
c1 1 0 1p\\
\\
.control\\
tran 1p 1n\\
plot v(1)\\
.endc\\
\end{quote}
 
The second line defines a function named ``noise'' that takes four
arguments:  the resistance, temperature in Kelvin, the lattice time
increment, and the interpolation method.  This is simply a wrapper
around a {\vt gauss} call, incorporating the standard noise equation
for current through a resistor at a given temperature, and taking the
inherent bandwidth to be one half of the reciprocal of the lattice
time increment (per Nyquist).  The noise function is used in the
specification for current source {\vt ir1}.  In a more complicated
case, each resistor in a circuit may have an associated noise current
source similarly defined.  It may be possible to demonstrate errors
due to thermal noise when simulating the circuit.

!!SEEALSO
tranfuncs

!! elements.tex 012509
!!KEYWORD
interp
!!TITLE
Interpolation 
!!HTML 
    General forms:
    <blockquote>
        <tt>interp</tt>(<i>vector</i>)
    </blockquote>

    <p>
    Example:
    <blockquote>
        <tt>vin 1 0 interp(tran1.v(1))</tt>
    </blockquote>

    <p>
    The output is <i>vector</i> interpolated to the scale of the current
    plot.  When used in a source, the output of the source is the
    interpolated vector, or the initial or final value for points off
    the ends of the original scale.

    <p>
    For example, say an amplifier produces vector <tt>v(1)</tt> (an
    output) in plot <tt>tran1</tt>.  One desires to apply this as
    input to another circuit.  This is achieved with a source
    specification like that shown in the example above.  This works in
    ordinary vector expressions as well.
!!LATEX interp elements.tex
\spgen{interp({\it vector})}
\spexampo{vin 1 0 interp(tran1.v(1))}

The output is {\it vector} interpolated to the scale of the current plot. 
When used in a source, the output of the source is the interpolated
vector, or the initial or final value for points off the ends of the
original scale.

For example, say an amplifier produces vector {\vt v(1)} (an output)
in plot {\vt tran1}.  One desires to apply this as input to another
circuit.  This is achieved with a source specification like that shown
in the example above.  This works in ordinary vector expressions as
well.

!!SEEALSO
tranfuncs

!!REDIRECT pattern      pulse#pattern

!! elements.tex 032220
!!KEYWORD
pulse
!!TITLE
Pulse
!!HTML 
    General forms:
    <blockquote>
        <tt>pulse</tt>(<i>v1 v2</i> [<i>td tr tf pw per td1 td2</i> ...]
      [<i>pattern_spec</i>])
    </blockquote>

    <p>
    Examples:
    <blockquote>
        <tt>vin 3 0 pulse(-1 1 2ns 2ns 2ns 50ns 100ns)</tt><br>
        <tt>vin1 1 0 pulse(0 1 2n .5n .5n 1n 0 6n 10n)</tt><br>
        <tt>v2 4 0 v(1)*pulse(0 1 5n 10n</tt>)
    </blockquote>

    <p>
    This function applies only to transient analysis, where time is
    the running variable.  When referring to default values,
    <tt>tstep</tt> is the printing increment and <tt>tstop</tt> is the
    final time in <a href=".tran"> transient analysis</a>.

    <p>
    The following are the numerical parameters, the
    <i>pattern_spec</i> is used to specify a patterned pulse train and
    the syntax will be described separately below.

    <p>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th>parameter</th><th>description</th>
        <th>default value</th><th>units</th></tr>
    <tr><td><i>v1</i></td> <td>initial value</td>
        <td>&nbsp;</td> <td>volts or amps</td></tr>
    <tr><td><i>v2</i></td> <td>pulsed value</td>
        <td>&nbsp;</td> <td>volts or amps</td></tr>
    <tr><td><i>td</i></td> <td>delay time</td>
        <td><tt>0.0</tt></td> <td>seconds</td></tr>
    <tr><td><i>tr</i></td> <td>rise time</td>
        <td><tt>tstep</tt></td> <td>seconds</td></tr>
    <tr><td><i>tf</i></td> <td>fall time</td>
        <td><tt>tstep</tt></td> <td>seconds</td></tr>
    <tr><td><i>pw</i></td> <td>pulse width</td>
        <td><tt>tstop</tt></td> <td>seconds</td></tr>
    <tr><td><i>per</i></td> <td>period</td>
        <td><tt>tstop</tt></td> <td>seconds</td></tr>
    </table>

    <p>
    The signal starts at value <i>v1</i> at <tt>time=0</tt>.  At time
    <i>td</i>, the pulse begins, the value arriving linearly at
    <i>v2</i> after the rise time <i>tr</i>.  The value <i>v2</i> is
    maintained for the pulse width time <i>pw</i>, then reverts
    linearly to value <i>v1</i> over the fall time <i>tf</i>.  If a
    period <i>per</i> is given and nonzero, a periodic train of pulses
    is produced, starting at <i>td</i>, with the second pulse starting
    at <i>td</i>+<i>per</i>, etc.  The minimum value for <i>per</i> is
    <i>tr</i>+<i>tf</i>+<i>pw</i>, which is silently enforced.

    <p>
    Numbers <i>td1</i>, <i>td2</i>, etc.  following <i>per</i> are
    taken as additional delay values (similar to <i>td</i>) and a
    pulse will start at each given value.  These will actually be
    superposed periodic pulse trains if <i>per</i> is nonzero (it must
    be given in any case when using the additional delays).

    <p>
    A single pulse so specified is described by the following table:

    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th>time</th>  <th>value</th></tr>
    <tr><td><tt>0</tt></td> <td><i>v1</i></td></tr>
    <tr><td><i>td</i></td> <td><i>v1</i></td></tr>
    <tr><td><i>td</i>+<i>tr</i></td> <td><i>v2</i></td></tr>
    <tr><td><i>td</i>+<i>tr</i>+<i>pw</i></td> <td><i>v2</i></td></tr>
    <tr><td><i>td</i>+<i>tr</i>+<i>pw</i>+<i>tf</i></td> <td><i>v1</i></td></tr>
    <tr><td><tt>tstop</tt></td> <td><i>v1</i></td></tr>
    </table>
    </blockquote>

    <p>
    Intermediate points are determined by linear interpolation.  It is
    not an error to omit unused parameters, for example the
    specification
    <blockquote>
    <tt>vxx 3 0 pulse(0 1 2n 2n)</tt>
    </blockquote>
    describes a voltage which, starting from 0, begins rising at 2
    nanoseconds, reaching 1 volt at 4 nanoseconds, and remains at
    that value.

    <p>
    If this function is used bare and not part of an expression in a
    voltage or current source, then the general source instance
    parameters <tt>prm1</tt> etc.  map as below.  It is possible to
    read and alter these values using the special vector
    @<i>device</i>[<i>param</i>] construct, or with the <a
    href="alter"><b>alter</b></a> and <a href="sweep"><b>sweep</b></a>
    commands.  However, there is no sanity checking so bad numbers can
    cause wild behavior or worse.

    <blockquote>
    <table border=0 cellspacing=4>
    <tr><td>prm1</td><td>v1</td></tr>
    <tr><td>prm2</td><td>v2</td></tr>
    <tr><td>prm3</td><td>td</td></tr>
    <tr><td>prm4</td><td>tr</td></tr>
    <tr><td>prm5</td><td>tf</td></tr>
    <tr><td>prm6</td><td>pw</td></tr>
    <tr><td>prm7</td><td>per</td></tr>
    </table>
    </blockquote>

    <a name="pattern"></a>
    <h4>Pattern Generation</h4>

    The transient <tt>pulse</tt> and <a
    href="gpulse"><tt>gpulse</tt></a> functions support a
    pattern-specification language borrowed from the pattern source of
    HSPICE.  This applies only when a period is given so that the
    source would provide periodic output.  The <i>pattern_spec</i>
    must appear after the additional delay numbers, if any.  The
    patterning enables the user to select in which periods a pulse is
    actually generated, and applies to all periodic trains if
    additional delays are given.

    <p>
    The <i>pattern_spec</i> consists of one or more "bstrings", each
    of which can have modifying options.
    <blockquote>
    <tt>b</tt><i>data</i> [<tt>r</tt>[=<i>rpt</i>]] [<tt>rb</tt>=<i>bit</i>] ...
    </blockquote>
    The first token is the bstring, which must start with the letter
    '<tt>b</tt>' (case insensitive) and continues for arbitrary length
    with 1 and 0 to indicate the presence or absence of a pulse in
    each period frame, traversing left to right.  Actually, the
    characters <tt>0,f,F,n,N</tt> are taken as '<tt>0</tt>', anything
    else is taken as '<tt>1</tt>'.  Note that the HSPICE <tt>m</tt>
    (intermediate value) and <tt>z</tt> (disconnected) are not
    currently supported.

    <p>
    A bstring can be followed by up to one each of two
    case-insensitive options.
    <dl>
    <dt><tt>r</tt> [= <i>rpt</i>]<dd>
    This provides a repetition count.  If an integer follows the
    literal '<tt>r</tt>', it is taken as the repetition count.  White
    space and an equal sign can be included, and will be ignored.  If
    no number is given, 1 is assumed, i.e., the pattern will repeat
    once.  If <tt>r</tt> is not given, there will be no repetition. 
    If the number given is negative, the pattern will continue
    repeating indefinitely.
    
    <p>
    <dt><tt>rb</tt> = <i>bit</i><dd>
    The <i>bit</i> is an integer ranging from 1 to the length of the
    bstring pattern, and indicates the start point for repetitions, if
    any.  If not given, the effective value is 1, indicating that the
    entire pattern repeats.  An integer must follow <tt>rb</tt>, white
    space and an equal sign will be ignored.

    <p>
    <dt><tt>bprbs</tt>[<i>N</i>]<dd>
    In <i>WRspice</i>, the bstring can also specify pseudo-random
    sequences through the syntax <tt>bprbs</tt>[<i>N</i>].  The
    <i>N</i> is an unsigned integer, defaulting to 6 if not given, and
    clipped to the range 6-12 if not in this range.  This is the
    degree of the pseudo-random sequence, i.e., the sequence length is
    2<sup><i>N</i></sup>-1.  This will accept the <tt>r</tt> and
    <tt>rb</tt> modifiers, however <tt>rb</tt> is treated a little
    differently.  With this form, it rotates the bit sequence, giving
    rotated output starting with the first pass.  The same degree with
    different <tt>rb</tt> values produces uncorrelated sequences. 
    </dl>

    <p>
    An arbitrary number of bstrings with options can appear in the
    specification, the result from each bstring with options will be
    concatenated.  If indefinite repetition is specified for a
    bstring, any bstrings that follow will be ignored.

    <p>
    Example:<br>
    <tt>b101101 r=1 rb=2 b000111</tt>
    <blockquote>
    <ul>
    <li>emit 101101
    <li>repeat once starting at bit 2: 01101
    <li>emit 000111
    </ul>
    </blockquote>
!!LATEX pulse elements.tex
\spgen{pulse({\it v1 v2} [{\it td tr tf pw per td1 td2} ...]
  [{\it pattern\_spec}])}
\spexamp{vin 3 0 pulse(-1 1 2ns 2ns 2ns 50ns 100ns)\\
vin1 1 0 pulse(0 1 2n .5n .5n 1n 0 6n 10n)\\
v2 4 0 v(1)*pulse(0 1 5n 10n)}

This function applies only to transient analysis, where time is the
running variable.  When referring to default values, {\vt tstep} is
the printing increment and {\vt tstop} is the final time in transient
analysis.

The following are the numerical parameters, the {\it pattern\_spec} is
used to specify a patterned pulse train and the syntax will be
described separately below.

\begin{quote}
\begin{tabular}{|l|l|l|l|} \hline
{\bf parameter} & {\bf description} & {\bf default value} &
  {\bf units}\\ \hline\hline
{\it v1} & initial value & & volts or amps\\ \hline
{\it v2} & pulsed value & & volts or amps\\ \hline
{\it td} & delay time & 0.0 & seconds\\ \hline
{\it tr} & rise time & {\vt tstep} & seconds\\ \hline
{\it tf} & fall time & {\vt tstep} & seconds\\ \hline
{\it pw} & pulse width & {\vt tstep} & seconds\\ \hline
{\it per} & period & {\vt tstop} & seconds\\ \hline
\end{tabular}
\end{quote}

The signal starts at value {\it v1} at {\vt time=0}.  At time {\it
td\/}, the pulse begins, the value arriving linearly at {\it v2} after
the rise time {\it tr\/}.  The value {\it v2} is maintained for the
pulse width time {\it pw\/}, then reverts linearly to value {\it v1}
over the fall time {\it tf\/}.  If a period {\it per} is given and
nonzero, a periodic train of pulses is produced, starting at {\it
td\/}, with the second pulse starting at {\it td\/}+{\it per\/}, etc. 
The minimum value for {\it per} is {\it tr\/}+{\it tf\/}+{\it pw\/},
which is silently enforced.

Numbers {\it td1\/}, {\it td2\/}, etc.  following {\it per} are taken
as additional delay values (similar to {\it td\/}) and a pulse will
start at each given value.  These will actually be superposed periodic
pulse trains if {\it per} is nonzero (it must be given in any case
when using the additional delays).

A single pulse so specified is described by the following table:
\begin{quote}
\begin{tabular}{ll}

{\bf time} & {\bf value}\\[0.5ex]
{\vt 0} & {\it v1}\\
{\it td} & {\it v1}\\
{\it td\/}+{\it tr} & {\it v2}\\
{\it td\/}+{\it tr\/}+{\it pw} & {\it v2}\\
{\it td\/}+{\it tr\/}+{\it pw\/}+{\it tf} & {\it v1\/}\\
{\vt tstop} & {\it v1}\\[2ex]
\end{tabular}
\end{quote}

Intermediate points are determined by linear interpolation.  It is not
an error to omit unused parameters, for example the specification
\begin{quote}
{\vt vxx 3 0 pulse(0 1 2n 2n)}
\end{quote}
describes a voltage which, starting from 0, begins rising at 2
nanoseconds, reaching 1 volt at 4 nanoseconds, and remains at that
value.

If this function is used bare and not part of an expression in a
voltage or current source, then the general source instance parameters
{\vt prm1} etc.  map as below.  It is possible to read and alter these
values using the special vector @{\it device}[{\it param\/}]
construct, or with the {\cb alter} and {\cb sweep} commands.  However,
there is no sanity checking so bad numbers can cause wild behavior or
worse.

\begin{quote}
\begin{tabular}{ll}
prm1 & v1\\
prm2 & v2\\
prm3 & td\\
prm4 & tr\\
prm5 & tf\\
prm6 & pw\\
prm7 & per\\
\end{tabular}
\end{quote}

\subsubsection{Pattern Generation}
\label{pattern}
\index{pattern specification}

The transient {\vt pulse} and {\vt gpulse} functions support a
pattern-specification language borrowed from the pattern source of
HSPICE.  This applies only when a period is given so that the source
would provide periodic output.  The {\it pattern\_spec} must appear
after the additional delay numbers, if any.  The patterning enables
the user to select in which periods a pulse is actually generated, and
applies to all periodic trains if additional delays are given.

The {\it pattern\_spec} consists of one or more ``bstrings'', each of
which can have modifying options.

\begin{quote}
{\vt b}{\it data} [{\vt r}[{\vt =}{\it rpt\/}]] [{\vt rb}{\vt =}{\it bit\/}] ...
\end{quote}

The first token is the bstring, which must start with the letter `{\vt
b}' (case insensitive) and continues for arbitrary length with 0 and 1
to indicate the presence or absence of a pulse in each period frame,
traversing left to right.  Actually, the characters {\vt 0,f,F,n,N}
are taken as `{\vt 0}', anything else is taken as '{\vt 1}'.  Note
that the HSPICE {\vt m} (intermediate value) and {\vt z}
(disconnected) are not currently supported.

A bstring can be followed by up to one each of two case-insensitive
options.
\begin{description}
\item{\vt r} [{\vt =} {\it rpt\/}]\\
This provides a repetition count.  If an integer follows the literal
`{\vt r}', it is taken as the repetition count.  White space and an
equal sign can be included, and will be ignored.  If no number is
given, 1 is assumed, i.e., the pattern will repeat once.  If {\vt r}
is not given, there will be no repetition.  If the number given is
negative, the pattern will continue repeating indefinitely.

\item{rb} {\vt =} {\it bit\/}\\
The {\it bit} is an integer ranging from 1 to the length of the
bstring pattern, and indicates the start point for repetitions, if
any.  If not given, the effective value is 1, indicating that the
entire pattern repeats.  An integer must follow {\vt rb}, white space
and an equal sign will be ignored.

\item{\vt bprbs}[{\it N\/}]\\
In {\WRspice}, the bstring can also specify pseudo-random sequences
through the syntax {\vt bprbs}[{\it N\/}].  The {\it N} is an unsigned
integer, defaulting to 6 if not given, and clipped to the range 6--12
if not in this range.  This is the degree of the pseudo-random
sequence, i.e., the sequence length is $2^N-1$.  This will accept the
{\vt r} and {\vt rb} modifiers, however {\vt rb} is treated a little
differently.  With this form, it rotates the bit sequence, giving
rotated output starting with the first pass.  The same degree with
different {\vt rb} values produces uncorrelated sequences.
\end{description}

An arbitrary number of bstrings with options can appear in the
specification, the result from each bstring with options will be
concatenated.  If indefinite repetition is specified for a bstring,
any bstrings that follow will be ignored.

Example:\\
{\vt b101101 r=1 rb=2 b000111}
\begin{quote}
\begin{itemize}
\item{emit 101101}
\item{repeat once starting at bit 2: 01101}
\item{emit 000111}
\end{itemize}
\end{quote}
 
!!SEEALSO
tranfuncs

!! elements.tex 060119
!!KEYWORD
gpulse
!!TITLE
Gaussian Pulse
!!HTML 
    General form:
    <blockquote>
        <tt>gpulse</tt>([<i>v1 v2 td pw per td1 td2</i> ...]
        [<i>pattern_spec</i>])
    </blockquote>

    <p>
    Examples:
    <blockquote>
        <tt>vsfq 3 0 gpulse(0 0 20p 2p 0 40p 60p)</tt><br>
        <tt>vpulse 1 0 gpulse(0 1 100p 5p 100p)</tt><br>
    </blockquote>

    <p>
    This generates a gaussian pulse signal, and as a special case, as
    a voltage source will generate single flux quantum (SFQ) pulses. 
    This function applies only to transient analysis, where time is
    the running variable.  The following are the numerical parameters,
    the <i>pattern_spec</i> is used to specify a patterned pulse train
    and the syntax is described in the <a
    href="pattern"><tt>pulse</tt></a> function topic.

    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th>parameter</th><th>description</th>
        <th>default value</th><th>units</th></tr>
    <tr><td><i>v1</i></td> <td>base value</td>
        <td><tt>0.0</tt></td> <td>volts or amps</td></tr>
    <tr><td><i>v2</i></td> <td>pulse peak value</td>
        <td><i>v1</i></td> <td>volts or amps</td></tr>
    <tr><td><i>td</i></td> <td>delay time</td>
        <td><tt>0.0</tt></td> <td>seconds</td></tr>
    <tr><td><i>pw</i></td> <td>pulse width</td>
        <td>see description</td> <td>seconds</td></tr>
    <tr><td><i>per</i></td> <td>period</td>
        <td><tt>0.0</tt></td> <td>seconds</td></tr>
    </table>

    <p>
    <b>Warning:</b> The pulse width is interpreted as the full-width
    half-maximum in release 4.3.3 and later.  In earlier releases,
    this was taken as the "variance" (width where amplitude is 1/e of
    the peak).  Presently, this interpretation can be coerced by
    giving a <b>negative</b> pulse width, the absolute value will be
    used as the variance.

    <p>
    The expression used to generate a pulse is<br>
    <tt>pw</tt> > 0:<br>
    <blockquote>
    <i>value</i> = <i>v1</i> + (<i>v2</i> -
      <i>v1</i>)*exp(-(4ln(2)(<i>time</i> - <i>td</i>)/<i>pw</i>)<sup>2</sup>)
    </blockquote>
    <tt>pw</tt> &#60; 0:<br>
    <blockquote>
    <i>value</i> = <i>v1</i> + (<i>v2</i> -
      <i>v1</i>)*exp(-((<i>time</i> - <i>td</i>)/<i>-pw</i>)<sup>2</sup>)
    </blockquote>
 
    The <i>td</i> delay value specifies the time of the initial pulse
    peak.  The <i>pw</i> defines the pulse width, as described above. 
    If the <i>per</i> is given a nonzero value larger than twice the
    <i>pw</i>, a train of pulses will be generated, the first being at
    <i>td</i> and at time increments of <i>per</i> thereafter.

    <p>
    Numbers found after the <i>per</i> are taken as additional delays,
    similar to <i>td</i>.  The output is a superposition of pulses
    found at each delay value (including <i>td</i>).  If the
    <i>per</i> is given a value 0.0, only one pulse per delay value is
    emitted.  If the <i>per</i> specifies a viable period, pulses are
    emitted at each delay value and increments of <i>per</i>.

    <p>
    If this function is used bare and not part of an expression in a
    voltage or current source, then the general source instance
    parameters <tt>prm1</tt> etc.  map as below.  It is possible to
    read and alter these values using the special vector
    @<i>device</i>[<i>param</i>] construct, or with the <a
    href="alter"><b>alter</b></a> and <a href="sweep"><b>sweep</b></a>
    commands.  However, there is no sanity checking so bad numbers can
    cause wild behavior or worse.

    <blockquote>
    <table border=0 cellspacing=4>
    <tr><td>prm1</td><td>v1</td></tr>
    <tr><td>prm2</td><td>v2</td></tr>
    <tr><td>prm3</td><td>td</td></tr>
    <tr><td>prm4</td><td>pw</td></tr>
    <tr><td>prm5</td><td>per</td></tr>
    </table>
    </blockquote>

    <p>
    Periodic pulses can be set to a pattern via the <a
    href="pattern"><i>pattern_spec</i></a>, which can appear following
    all delay values, if any.

    <p>
    A single flux quantum (SFQ) pulse, as a voltage applied across an
    inductor, will induce a single flux quantum of
    <blockquote>
    <i>phi0</i> = <i>h</i>/(2*<i>e</i>) = 2.06783fWb
    </blockquote>
    where <i>h</i> is Planck's constant, and <i>e</i> is the electron
    charge.  With superconductors, the flux that threads
    superconducting loops is quantized in increments of this value,
    due to the requirement that the superconducting wave function meet
    periodic boundary conditions around the loop.

    <p>
    If the <tt>pw</tt> is not given or given as zero, the source will
    be configured to produce an SFQ pulse with the given amplitude. 
    Thus, the actual pulse width will be computed internally, with
    amplitude not zero, as
    <blockquote>
    <i>pw</i> = 2*sqrt(ln(2))*phi0/(abs(<i>v2</i>-<i>v1</i>)*sqrt(pi))
    </blockquote>
    where <tt>phi0</tt> is the flux quantum whose value is given above.

    <p>
    Similarly, if the amplitude is set to zero, i.e., <i>v2</i> =
    <i>v1</i>, the amplitude will be computed from the pulse width to
    yield an SFQ pulse.  The computed amplitude is
    <blockquote>
    <i>v2</i> = <i>v1</i> + 2*sqrt(ln(2))*<tt>phi0</tt>/(<i>pw</i>*<tt>sqrt(pi)</tt>)
    </blockquote>

    <p>
    If both amplitude and pulse width are set to zero or not given,
    the full-width half-maximum SFQ pulse width is taken as the TSTEP
    transient analysis parameter, and the amplitude is computed as
    above.

    <p>
    In superconducting electronics, single flux quantum pulses are
    generated and received by logic circuits.  A generator of SFQ
    pulses is therefor a useful item when working with this
    technology.

    <p>
    Example
    <blockquote><td>
    * gaussian pulse<br>
    <br>
    v1 1 0 gpulse(0 0 20p 2p 0 40p)<br>
    l1 1 2 10p<br>
    b1 2 0 100 jj3 area=.2<br>
    r2 2 0 2<br>
    .tran .1p 100p uic<br>
    .plot tran v(1) v(2) i(l1) ysep<br>
    <br>
    * Nb 4500 A/cm2<br>
    .model jj3 jj(rtype=1, cct=1, icon=10m, vg=2.8m, delv=0.08m,<br>
    + icrit=1m, r0=30, rn=1.7, cap=1.31p)
    </tt></blockquote>

    <p>
    In the example, the generator produces two SFQ pulses.  The second
    pulse causes the Josephson junction to emit a flux quantum, the
    second one from the source is therefor expelled.  The inductor
    current shows the same value before and after the second pulse,
    as expected.
!!LATEX gpulse elements.tex
\spgen{gpulse([{\it v1 v2 td pw per td1 td2} ...]
 [{\it pattern\_spec\/}])}
\spexamp{vsfq 0 0 gpulse(0 0 20p 2p 0 40p 60p)\\
vpulse 1 0 gpulse(0 1 100p 5p 100p)}

This generates a gaussian pulse signal, and as a special case, as a
voltage source will generate single flux quantum (SFQ) pulses.  This
function applies only to transient analysis, where time is the running
variable.  The following are the numerical parameters, the {\it
pattern\_spec} is used to specify a patterned pulse train and the
syntax is described in \ref{pattern}.

\begin{quote}
\begin{tabular}{|l|l|l|l|} \hline
{\bf parameter} & {\bf description} & {\bf default value} &
  {\bf units}\\ \hline\hline
{\it v1} & base value & 0.0 & volts or amps\\ \hline
{\it v2} & pulse peak value & {\it v1} & volts or amps\\ \hline
{\it td} & delay time & 0.0 & seconds\\ \hline
{\it pw} & pulse width & see description & seconds\\ \hline
{\it per} & period & 0.0 & seconds\\ \hline
\end{tabular}
\end{quote}

{\bf Warning:} The pulse width is interpreted as the full-width
half-maximum in release 4.3.3 and later.  In earlier releases, this
was taken as the ``variance'' (width where amplitude is 1/e of the
peak).  Presently, this interpretation can be coerced by giving a {\bf
negative} pulse width, the absolute value will be used as the
variance.

The expression used to generate a pulse is\\
$pw > 0$:\\
\begin{quote}
{\it value} = $v1 + (v2 - v1){\cdot}exp(-(4\cdot\ln(2)\cdot(time-td)/pw)^2)$
\end{quote}
$pw < 0$:\\
\begin{quote}
{\it value} = $v1 + (v2 - v1){\cdot}exp(-((time-td)/-pw)^2)$
\end{quote}

The {\it td} delay value specifies the time of the initial pulse peak. 
The {\it pw} defines the pulse width, as described above.  If the {\it
per} is given a nonzero value larger than twice the {\it pw}, a train
of pulses will be generated, the first being at {\it td} and at time
increments of {\it per} thereafter.

Numbers found after the {\it per} are taken as additional delays,
similar to {\it td\/}.  The output is a superposition of pulses found
at each delay value (including {\it td\/}).  If the {\it per} is given
a value 0.0, only one pulse per delay value is emitted.  If the {\it
per} specifies a viable period, pulses are emitted at each delay value
and increments of {\it per\/}.

If this function is used bare and not part of an expression in a
voltage or current source, then the general source instance parameters
{\vt prm1} etc.  map as below.  It is possible to read and alter these
values using the special vector @{\it device}[{\it param\/}]
construct, or with the {\cb alter} and {\cb sweep} commands.  However,
there is no sanity checking so bad numbers can cause wild behavior or
worse.

\begin{quote}
\begin{tabular}{ll}
prm1 & v1\\
prm2 & v2\\
prm3 & td\\
prm4 & pw\\
prm5 & per\\
\end{tabular}
\end{quote}

Periodic pulses can be set to a pattern via the {\it pattern\_spec},
which can appear following all delay values, if any.  The syntax is
described in \ref{pattern}.

A single flux quantum (SFQ) pulse, as a voltage applied across an
inductor, will induce a single flux quantum of
\begin{quote}
 $\Phi_0$ = $h/(2e)$ = 2.06783fWb
\end{quote}
where {\it h} is Planck's constant, {\it e} is the electron charge. 
With superconductors, the flux that threads superconducting loops is
quantized in increments of this value, due to the requirement that the
superconducting wave function meet periodic boundary conditions around
the loop.

If the {\vt pw} is not given or given as zero, the source will be
configured to produce an SFQ pulse with the given amplitude.  Thus,
the actual pulse width will be computed internally, with amplitude not
zero, as
\begin{quote}
$pw = 2\sqrt{ln(2)}\Phi_0/(abs(v2-v1)\sqrt\pi)$
\end{quote}
where $\Phi_0$ is the flux quantum whose value is given above.

Similarly, if the amplitude is set to zero, i.e., {\it v2} = {\it
v1\/}, the amplitude will be computed from the pulse width to yield an
SFQ pulse.  The computed amplitude is
\begin{quote}
$v2 = v1 + 2\sqrt{ln(2)}\Phi_0/(pw\sqrt\pi)$
\end{quote}

If both amplitude and pulse width are set to zero or not given, the
full-width half-maximum SFQ pulse width is taken as the TSTEP
transient analysis parameter, and the amplitude is computed as above.

In superconducting electronics, single flux quantum pulses are
generated and received by logic circuits.  A generator of SFQ pulses
is therefor a useful item when working with this technology.

Example
\begin{quote}\vt
* gaussian pulse\\
\\
v1 1 0 gpulse(0 0 20p 2p 0 40p)\\
l1 1 2 10p\\
b1 2 0 100 jj3 area=.2\\
r2 2 0 2\\
.tran .1p 100p uic\\
.plot tran v(1) v(2) i(l1) ysep\\
\\
\vt * Nb 4500 A/cm2\\
.model jj3 jj(rtype=1, cct=1, icon=10m, vg=2.8m, delv=0.08m,\\
+ icrit=1m, r0=30, rn=1.7, cap=1.31p)
\end{quote}

In the example, the generator produces two SFQ pulses.  The second
pulse causes the Josephson junction to emit a flux quantum, the
second one from the source is therefor expelled.  The inductor
current shows the same value before and after the second pulse,
as expected.

!!SEEALSO
tranfuncs

!! elements.tex 022117
!!KEYWORD
pwl
!!TITLE
Piece-Wise Linear
!!HTML 
    General forms:
    <blockquote>
        <tt>pwl</tt>(<i>t1 v1</i> [<i>t2 v2 t3 v3 t4 v4</i> ...]
        [<tt>r</tt> [[=] <i>ti</i>]] [<tt>td</tt> [=] <i>delay</i>])<br>
        <tt>pwl</tt>(<i>vec1</i> [<i>vec2</i>]
        [<tt>r</tt> [[=] <i>ti</i>]] [<tt>td</tt> [=] <i>delay</i>])
    </blockquote>

    <p>
    Examples:
    <blockquote>
        <tt>vclock 7 5 pwl(0 -7 10ns -7 11ns -3 17ns -3 18ns -7 50ns -7)<br>
        vin 2 0 pwl(times amplitudes td=1ns)</tt>
    </blockquote>

    <p>
    Each pair of values (<i>ti</i>, <i>vi</i>) specifies that the
    value of the source is <i>vi</i> (in volts or amps) at time =
    <i>ti</i>.  The value of the source at intermediate values of time
    is determined by using linear interpolation on the input values. 
    For times before the initial time value, the return is the initial
    value, and for times after the final time value, the return is the
    final value.

    <p>
    In the second form, the values are provided in the named vectors,
    which must be in scope when the deck is parsed (which most often
    happens just before a simulation is run, and not when the file is
    read into <i>WRspice</i>).  If a single vector name is given, its
    values are expected to be the same as would be provided in the
    first form, i.e., an alternating sequence of times and amplitudes. 
    If two vector names are given, the first vector is expected to
    contain time values only, and the second vector contains the
    corresponding amplitudes.  If vectors are used, all values are
    obtained from the vectors, as it is presently not possible to mix
    vectors and explicit values.

    <p>
    In the example below, both voltage sources provide the same
    output.  Note that if the vectors are saved in the <a
    href="constants"><tt>constants</tt></a> plot, they will be
    resolved by name in any context.

    <p>
    Example
    <blockquote><tt>
    * PWL Test<br>
    <br>
    .exec<br>
    compose constants.pwlvals values 0 0 10p 0 20p 1 40p 1 50p 0<br>
    compose constants.tvals values 0 10p 20p 40p 50p<br>
    compose constants.xvals values 0 0 1 1 0<br>
    .endc<br>
    <br>
    v1 1 0 pwl(pwlvals)<br>
    v2 2 0 pwl(tvals xvals)</tt>
    </blockquote>

    <p>
    Use of vectors can simplify and make more efficient the handling
    of very long PWL lists.  For example, suppose that one has just
    run a long simulation of a circuit, and one would like to apply
    the output of this circuit to another circuit.  Suppose that the
    output is in vector <tt>v(1)</tt>.  First, save this vector as a
    binary rawfile.  The binary format is faster to read/write than
    the default ASCII.

    <blockquote><tt>
    set filetype=binary<br>
    write myfile.raw v(1)
    </tt></blockquote>

    Then, on a subsequent run, one can load the saved vectors (the
    vector and its scale are both saved), and for convenience add them
    to the <tt>constants</tt> plot.

    <blockquote><tt>
    load myfile.raw<br>
    let constants.tvals = time constants.xvals = v(1)
    </tt></blockquote>

    This needs to be done once only per session.  If the circuit file
    contains a line like

    <blockquote>
    <tt>vin 2 0 pwl(tvals xvals)</tt>
    </blockquote>

    Then one can run any number of simulations while avoiding the need
    to repeatedly parse and recreate the long PWL list from an input
    file.

    <p>
    The <tt>pwl</tt> function is currently the only tran function that
    takes parameters.  These parameters belong to the <tt>pwl</tt>
    function, and must be included inside the parentheses when
    parentheses are used.  The parameters are specified with an
    identifier, optionally followed by an equal sign, and a number. 
    The parameters must appear following the values list or vector
    names.

    <p>
    <dl>
    <dt><tt>r</tt><dd>
    The <tt>r</tt> (repeat) option forces the wave function to repeat
    periodically.  A time value can optionally follow <tt>r</tt>,
    which if given must be one of the <i>ti</i> given but not the
    final time value, or it can be zero.  If the time value is
    omitted, it is taken as zero.  This time value is "mapped" to the
    final time value when the sequence repeats.

    <p>
    For example, after the circuit time slightly exceeds the final
    time value given, the next output value will be the value
    following the time given with <tt>r</tt>, and its time will be the
    final time plus the difference between the <tt>r</tt> point time
    and the point that follows.

    <p>
    <dt><tt>td</tt><dd>
    The <tt>td</tt> parameter can be set to a delay time, that will be
    added to all time values, including those generated with the
    <tt>r</tt> parameter.
    </dl>

    <p>
    The two parameters are intended to behave in the same manner as
    similar parameters defined in <a href="hspicesim">HSPICE</a>. 
    There is one difference between <i>WRspice</i> and HSPICE
    <tt>pwl</tt> behavior:  if the first time value is nonzero, in
    HSPICE the time zero value will be the source <tt>dc</tt> value,
    in <i>WRspice</i> is will be the value at the first given time
    point.

    <p>
    In <a href="depsource">dependent sources</a> where the controlling
    input is specified, a <tt>pwl</tt> construct if used in the
    expression for the source will take as input the value of the
    controlling input, and not time.  This is one means by which a
    piecewise-linear transfer function can be implemented.  A similar
    capability exists through the <a href="table"><tt>table</tt></a>
    function.
 
    <p>
    Example:
    <blockquote>
        <tt>e1 1 0 2 0 pwl(-1 1 0 0 1 1)</tt>
    </blockquote>

    <p>
    The example above implements a perfect rectifier (absolute value
    generator) for voltages between -1 and 1V.  Outside this range, the
    output is clipped to 1V.

    <p>
    The <tt>r</tt> and <tt>td</tt> parameters work in this case as
    well, doing the same things, but with respect to the controlling
    input.  For example:
    <blockquote><tt>
    e1 1 0 2 0 pwl(0 0 .5 1 1 0 R)<br>
    v1 2 0 pwl(0 0 100p 5)
    </tt></blockquote>

    The output of <tt>e1</tt> is a periodic triangular wave, generated
    by linearly sweeping the periodic transfer function.
!!LATEX pwl elements.tex
\spgen{pwl({\it t1 v1\/} [{\it t2 v2 t3 v3 t4 v4 ...\/}]
 [{\vt r} [[=] {\it ti\/}]] [{\vt td} [=] {\it delay\/}]\\
pwl({\it vec1\/} [{\it vec2\/}]
 [{\vt r} [[=] {\it ti\/}]] [{\vt td} [=] {\it delay\/}]}
\spexampo{vclock 7 5 pwl(0 -7 10ns -7 11ns -3 17ns -3 18ns -7 50ns -7)\\
vin 2 0 pwl(times amplitudes td=1ns)}

Each pair of values ({\it ti\/}, {\it vi\/}) specifies that the value of the
source is {\it vi\/} (in volts or amps) at time = {\it ti\/}.  The
value of the source at intermediate values of time is determined by
using linear interpolation on the input values.  For times before the
initial time value, the return is the initial value, and for times
after the final time value, the return is the final value.

In the second form, the values are provided in the named vectors,
which must be in scope when the deck is parsed (which most often
happens just before a simulation is run, and not when the file is read
into {\WRspice}).  If a single vector name is given, its values are
expected to be the same as would be provided in the first form, i.e.,
an alternating sequence of times and amplitudes.  If two vector names
are given, the first vector is expected to contain time values only,
and the second vector contains the corresponding amplitudes.  If
vectors are used, all values are obtained from the vectors, as it is
presently not possible to mix vectors and explicit values.

In the example below, both voltage sources provide the same output. 
Note that if the vectors are saved in the {\vt constants} plot, they
will be resolved by name in any context.

Example
\begin{quote}\vt
* PWL Test\\
\\
.exec\\
compose constants.pwlvals values 0 0 10p 0 20p 1 40p 1 50p 0\\
compose constants.tvals values 0 10p 20p 40p 50p\\
compose constants.xvals values 0 0 1 1 0\\
.endc\\
\\
v1 1 0 pwl(pwlvals)\\
v2 2 0 pwl(tvals xvals)
\end{quote}

Use of vectors can simplify and make more efficient the handling of
very long PWL lists.  For example, suppose that one has just run a
long simulation of a circuit, and one would like to apply the output
of this circuit to another circuit.  Suppose that the output is in
vector {\vt v(1)}.  First, save this vector as a binary rawfile.  The
binary format is faster to read/write than the default ASCII.

\begin{quote}\vt
set filetype=binary\\
write myfile.raw v(1)
\end{quote}

Then, on a subsequent run, one can load the saved vectors (the vector
and its scale are both saved), and for convenience add them to the
{\vt constants} plot.

\begin{quote}\vt
load myfile.raw\\
let constants.tvals = time constants.xvals = v(1)
\end{quote}

This needs to be done once only per session.  If the circuit file
contains a line like

\begin{quote}\vt
vin 2 0 pwl(tvals xvals)
\end{quote}

Then one can run any number of simulations while avoiding the need to
repeatedly parse and recreate the long PWL list from an input file.

The {\vt pwl} function is currently the only tran function that takes
parameters.  These parameters belong to the {\vt pwl} function, and
must be included inside the parentheses when parentheses are used. 
The parameters are specified with an identifier, optionally followed
by an equal sign, and a number.  The parameters must appear following
the values list or vector names.

\begin{description}
\item{\vt r}\\
The {\vt r} (repeat) option forces the wave function to repeat
periodically.  A time value can optionally follow {\vt r}, which if
given must be one of the {\it ti} given but not the final time value,
or it can be zero.  If the time value is omitted, it is taken as zero. 
This time value is ``mapped'' to the final time value when the
sequence repeats.
 
For example, after the circuit time slightly exceeds the final time
value given, the next output value will be the value following the time
given with {\vt r}, and its time will be the final time plus the
difference between the {\vt r} point time and the point that follows.

\item{\vt td}\\
The {\vt td} parameter can be set to a delay time, that will be added
to all time values, including those generated with the {\vt r}
parameter.
\end{description}

The two parameters are intended to behave in the same manner as
similar parameters defined in HSPICE.  There is one difference between
{\WRspice} and HSPICE {\vt pwl} behavior:  if the first time value is
nonzero, in HSPICE the time zero value will be the source {\vt dc}
value, in {\WRspice} is will be the value at the first given time
point.
 
In dependent sources where the controlling input is specified, a {\vt
pwl} construct if used in the expression for the source will take as
input the value of the controlling input, and not time.  This is one
means by which a piecewise-linear transfer function can be
implemented.  A similar capability exists through the {\vt table}
function.

Example:
\begin{quote}
    {\vt e1 1 0 2 0 pwl(-1 1 0 0 1 1)}
\end{quote}

The example above implements a perfect rectifier (absolute value
generator) for voltages between -1 and 1V.  Outside this range, the
output is clipped to 1V.

The {\vt r} and {\vt td} parameters work in this case as well, doing
the same things, but with respect to the controlling input.  For
example:

\begin{quote}\vt
e1 1 0 2 0 pwl(0 0 .5 1 1 0 R)\\
v1 2 0 pwl(0 0 100p 5)
\end{quote}

The output of {\vt e1} is a periodic triangular wave, generated by
linearly sweeping the periodic transfer function.
 
!!SEEALSO
tranfuncs

!! elements.tex 060119
!!KEYWORD
sffm
!!TITLE
Single-Frequency FM
!!HTML 
    General forms:
    <blockquote>
        <tt>sffm</tt>(<i>vo va</i> [<i>fc mdi fs</i>])
    </blockquote>

    <p>
    Examples:
    <blockquote>
        <tt>v1 12 0 sffm(0 1m 20k 5 1k)</tt>
    </blockquote>

    <p>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th>parameter</th><th>description</th>
        <th>default value</th><th>units</th></tr>
    <tr><td><i>vo</i></td> <td>offset</td>
        <td>&nbsp;</td> <td>volts or amps</td></tr>
    <tr><td><i>va</i></td> <td>amplitude</td>
        <td>&nbsp;</td> <td>volts or amps</td></tr>
    <tr><td><i>fc</i></td> <td>carrier frequency</td>
        <td>1/<tt>tstop</tt></td> <td>hz</td></tr>
    <tr><td><i>mdi</i></td> <td>modulation index</td>
        <td>&nbsp;</td> <td>&nbsp;</td></tr>
    <tr><td><i>fs</i></td> <td>signal frequency</td>
        <td>1/<tt>tstop</tt></td> <td>hz</td></tr>
    </table>

    <p>
    The shape of the waveform is described by the following equation:
    <blockquote>
        <i>value</i> = <i>vo</i> + <i>va</i>*<tt>sin</tt>((2*<tt>pi</tt>*<i>fc</i>*<tt>time</tt>)
        + <i>mdi</i>*<tt>sin</tt>(2*<tt>pi</tt>*<i>fs</i>*<tt>time</tt>))
    </blockquote>

    <p>
    This function applies only to transient analysis, where time is
    the running variable.  When referring to default values,
    <tt>tstep</tt> is the printing increment and <tt>tstop</tt> is the
    final time in <a href=".tran"> transient analysis</a>.

    <p>
    If this function is used bare and not part of an expression in a
    voltage or current source, then the general source instance
    parameters <tt>prm1</tt> etc.  map as below.  It is possible to
    read and alter these values using the special vector
    @<i>device</i>[<i>param</i>] construct, or with the <a
    href="alter"><b>alter</b></a> and <a href="sweep"><b>sweep</b></a>
    commands.  However, there is no sanity checking so bad numbers can
    cause wild behavior or worse.

    <blockquote>
    <table border=0 cellspacing=4>
    <tr><td>prm1</td><td>vo</td></tr>
    <tr><td>prm2</td><td>va</td></tr>
    <tr><td>prm3</td><td>fc</td></tr>
    <tr><td>prm4</td><td>mdi</td></tr>
    <tr><td>prm5</td><td>fs</td></tr>
    </table>
    </blockquote>
!!LATEX sffm elements.tex
\spgen{sffm({\it vo va\/} [{\it fc mdi fs\/}])}
\spexampo{v1 12 0 sffm(0 1m 20k 5 1k)}

\begin{quote}
\begin{tabular}{|l|l|l|l|} \hline
{\bf parameter} & {\bf description} & {\bf default value} &
 {\bf units}\\ \hline\hline
{\it vo} & offset & & volts or amps\\ \hline
{\it va} & amplitude & & volts or amps\\ \hline
{\it fc} & carrier frequency & 1/{\vt tstop} & hz\\ \hline
{\it mdi} & modulation index & 0 &\\ \hline
{\it fs} & signal frequency & 1/{\vt tstop} & hz\\ \hline
\end{tabular}
\end{quote}

The shape of the waveform is described by the following equation:
\begin{quote}
value = {\it vo\/} + {\it va\/}$\cdot$sin((2$\pi\cdot${\it
fc\/}$\cdot$time)
 $+$ {\it mdi\/}$\cdot$sin(2$\pi\cdot${\it fs\/}$\cdot$time))
\end{quote}

This function applies only to transient analysis, where time is the
running variable.  When referring to default values, {\vt tstep} is
the printing increment and {\vt tstop} is the final time in transient
analysis, see \ref{tranline} for explanation.

If this function is used bare and not part of an expression in a
voltage or current source, then the general source instance parameters
{\vt prm1} etc.  map as below.  It is possible to read and alter these
values using the special vector @{\it device}[{\it param\/}]
construct, or with the {\cb alter} and {\cb sweep} commands.  However,
there is no sanity checking so bad numbers can cause wild behavior or
worse.

\begin{quote}
\begin{tabular}{ll}
prm1 & vo\\
prm2 & va\\
prm3 & fc\\
prm4 & mdi\\
prm5 & fs\\
\end{tabular}
\end{quote}
 
!!SEEALSO
tranfuncs

!! elements.tex 060119
!!KEYWORD
am
!!TITLE
Amplitude Modulation
!!HTML 
    General forms:
    <blockquote>
        <tt>am</tt>(<i>sa oc fm fc td</i>)
    </blockquote>

    <p>
    Examples:
    <blockquote>
        <tt>v1 12 0 am(10 1 10meg 100meg 10n)</tt>
    </blockquote>

    <p>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th>parameter</th><th>description</th>
        <th>default value</th><th>units</th></tr>
    <tr><td><i>sa</i></td> <td>signal amplitude</td>
        <td>0</td> <td>volts or amps</td></tr>
    <tr><td><i>oc</i></td> <td>offset constant</td>
        <td>0</td> <td>&nbsp;</td></tr>
    <tr><td><i>fm</i></td> <td>modulation frequency</td>
        <td>1/<tt>tstop</tt></td> <td>hz</td></tr>
    <tr><td><i>fc</i></td> <td>carrier frequency</td>
        <td>0</td> <td>hz</td></tr>
    <tr><td><i>td</i></td> <td>signal delay time</td>
        <td>0</tt></td> <td>seconds</td></tr>
    </table>

    <p>
    The shape of the waveform is described by the following table:
    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th>time</th>  <th>value</th></tr>
    <tr><td><tt>0</tt> to <i>td</i></td> <td>0</td></tr>
    <tr><td><i>td</i> to <tt>tstop</tt></td>
        <i>sa</i> * {<i>oc</i> +
        <tt>sin</tt>(2*<tt>pi</tt>*<i>fm</i>*(<tt>time</tt>-<i>td</i>))}
        * <tt>sin</tt>(2*<tt>pi</tt>*<i>fc</i>*(<tt>time</tt>-<i>td</i>))
    </td></tr></table>
    </blockquote>

    <p>
    This function applies only to transient analysis, where time is
    the running variable.  When referring to default values,
    <tt>tstep</tt> is the printing increment and <tt>tstop</tt> is the
    final time in <a href=".tran"> transient analysis</a>.  This
    function is a work-alike to the similar function found in <a
    href="hspicesim">HSPICE</a>.

    <p>
    If this function is used bare and not part of an expression in a
    voltage or current source, then the general source instance
    parameters <tt>prm1</tt> etc.  map as below.  It is possible to
    read and alter these values using the special vector
    @<i>device</i>[<i>param</i>] construct, or with the <a
    href="alter"><b>alter</b></a> and <a href="sweep"><b>sweep</b></a>
    commands.  However, there is no sanity checking so bad numbers can
    cause wild behavior or worse.

    <blockquote>
    <table border=0 cellspacing=4>
    <tr><td>prm1</td><td>sa</td></tr>
    <tr><td>prm2</td><td>oc</td></tr>
    <tr><td>prm3</td><td>fm</td></tr>
    <tr><td>prm4</td><td>fc</td></tr>
    <tr><td>prm5</td><td>td</td></tr>
    </table>
    </blockquote>
!!LATEX am elements.tex
\spgen{am({\it sa oc fm fc td\/})}
\spexampo{vin 12 0 am(10 1 10meg 100meg 10n)}

\begin{quote}
\begin{tabular}{|l|l|l|l|} \hline
{\bf parameter} & {\bf description} & {\bf default value} &
 {\bf units}\\ \hline\hline
{\it sa} & signal amplitude & & volts or amps\\ \hline
{\it oc} & offset constant & & \\ \hline
{\it fm} & modulation frequency & 1/{\vt tstop} & hz\\ \hline
{\it rc} & carrier frequency & 0.0 & hz\\ \hline
{\it td} & signal delay & 0.0 & seconds\\ \hline
\end{tabular}
\end{quote}

The shape of the waveform is described by the following table:

\begin{quote}
\begin{tabular}{ll}
{\bf time} & {\bf value}\\[0.5ex]
0 to {\it td} & 0\\
{\it td} to {\vt tstop} & {\it sa\/} ${\cdot} \{oc +
 sin(2\pi{\cdot}fm{\cdot}(time-td))\}
 {\cdot} sin(2\pi{\cdot}fc{\cdot}(time-td))$\\
\end{tabular}
\end{quote}

This function applies only to transient analysis, where time is the
running variable.  When referring to default values, {\vt tstep} is
the printing increment and {\vt tstop} is the final time in transient
analysis</a>.  This function is a work-alike to the similar function
found in HSPICE.

If this function is used bare and not part of an expression in a
voltage or current source, then the general source instance parameters
{\vt prm1} etc.  map as below.  It is possible to read and alter these
values using the special vector @{\it device}[{\it param\/}]
construct, or with the {\cb alter} and {\cb sweep} commands.  However,
there is no sanity checking so bad numbers can cause wild behavior or
worse.

\begin{quote}
\begin{tabular}{ll}
prm1 & sa\\
prm2 & oc\\
prm3 & fm\\
prm4 & fc\\
prm5 & td\\
\end{tabular}
\end{quote}
 
!!SEEALSO
tranfuncs
 
!! elements.tex 060119
!!KEYWORD
tsin
!!TITLE
Sinusoidal
!!HTML 
    General forms:
    <blockquote>
        <tt>sin</tt>(<i>vo va</i> [<i>freq td theta phi</i>])
    </blockquote>

    <p>
    Examples:
    <blockquote>
        <tt>vin 3 0 sin(0 1 100meg 1ns 1e10)</tt>
    </blockquote>

    <p>
    This function can be called as <tt>tsin</tt> to avoid possible
    conflict with the <a href="mathfuncs#sin"><tt>sin</tt></a> math
    function.

    <p>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th>parameter</th><th>description</th>
        <th>default value</th><th>units</th></tr>
    <tr><td><i>vo</i></td> <td>offset</td>
        <td>&nbsp;</td> <td>volts or amps</td></tr>
    <tr><td><i>va</i></td> <td>amplitude</td>
        <td>&nbsp;</td> <td>volts or amps</td></tr>
    <tr><td><i>freq</i></td> <td>frequency</td>
        <td>1/<tt>tstop</tt></td> <td>hz</td></tr>
    <tr><td><i>td</i></td> <td>delay</td>
        <td><tt>0.0</tt></td> <td>seconds</td></tr>
    <tr><td><i>theta</i></td> <td>damping factor</td>
        <td><tt>0.0</tt></td> <td>1/seconds</td></tr>
    <tr><td><i>phi</i></td>   <td>phase delay</td>
        <td><tt>0.0</tt></td> <td>degrees</td></tr>
    </table>

    <p>
    The shape of the waveform is described by the following table:

    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th>time</th>  <th>value</th></tr>
    <tr><td><tt>0</tt> to <i>td</i></td> <td><i>vo</i> +
      <i>va</i>*<tt>sin</tt>(<tt>pi</tt>*<tt>phi/180</tt>)</td></tr>
    <tr><td><i>td</i> to <tt>tstop</tt></td>
      <td><i>vo</i> + <i>va</i>*<tt>exp</tt>(-(<tt>time</tt>-<i>td</i>)*<i>theta</i>) *
      <tt>sin</tt>(2*<tt>pi</tt>*(<i>freq</i>*(<tt>time</tt>-<i>td</i>) +
      <tt>phi/360</tt>))</td></tr>
    </table>
    </blockquote>
 
    <p>
    This function applies only to transient analysis, where time is
    the running variable.  When referring to default values,
    <tt>tstep</tt> is the printing increment and <tt>tstop</tt> is the
    final time in <a href=".tran"> transient analysis</a>.  The
    argument count is used to distinguish this function from the math
    function of the same name.

    <p>
    If this function is used bare and not part of an expression in a
    voltage or current source, then the general source instance
    parameters <tt>prm1</tt> etc.  map as below.  It is possible to
    read and alter these values using the special vector
    @<i>device</i>[<i>param</i>] construct, or with the <a
    href="alter"><b>alter</b></a> and <a href="sweep"><b>sweep</b></a>
    commands.  However, there is no sanity checking so bad numbers can
    cause wild behavior or worse.

    <blockquote>
    <table border=0 cellspacing=4>
    <tr><td>prm1</td><td>vo</td></tr>
    <tr><td>prm2</td><td>va</td></tr>
    <tr><td>prm3</td><td>freq</td></tr>
    <tr><td>prm4</td><td>td</td></tr>
    <tr><td>prm5</td><td>theta</td></tr>
    <tr><td>prm6</td><td>phi</td></tr>
    </table>
    </blockquote>
!!LATEX tsin elements.tex
\spgen{sin({\it vo va\/} [{\it freq td theta phi\/}])}
\spexampo{vin 3 0 sin(0 1 100meg 1ns 1e10)}

This function can be called as {\vt tsin} to avoid possible conflict
with the {\vt sin} math function.

\begin{quote}
\begin{tabular}{|l|l|l|l|} \hline
{\bf parameter} & {\bf description} & {\bf default value} &
 {\bf units}\\ \hline\hline
{\it vo} & offset & & volts or amps\\ \hline
{\it va} & amplitude & & volts or amps\\ \hline
{\it freq} & frequency & 1/{\vt tstop} & hz\\ \hline
{\it td} & delay & 0.0 & seconds\\ \hline
{\it theta} & damping factor & 0.0 & 1/seconds\\ \hline
{\it phi} & phase delay & 0.0 & degrees\\ \hline
\end{tabular}
\end{quote}

The shape of the waveform is described by the following table:

\begin{quote}
\begin{tabular}{ll}
{\bf time} & {\bf value}\\[0.5ex]
0 to {\it td} & {\it vo\/} + {\it va}${\cdot}sin(\pi{\cdot}phi/180)$\\
{\it td} to {\vt tstop} & {\it vo\/} $+$ {\it va\/}$\cdot$exp($-$(time$-${\it
td\/})$\cdot${\it theta\/}) $\cdot$
 sin(2$\pi\cdot$({\it freq\/}$\cdot$(time$-${\it td\/}) +
 $\pi{\cdot}phi/360$))\\[2ex]
\end{tabular}
\end{quote}

This function applies only to transient analysis, where time is the
running variable.  When referring to default values, {\vt tstep} is
the printing increment and {\vt tstop} is the final time in transient
analysis, see \ref{tranline} for explanation.  The argument count is
used to distinguish this function from the math function of the same
name.

If this function is used bare and not part of an expression in a
voltage or current source, then the general source instance parameters
{\vt prm1} etc.  map as below.  It is possible to read and alter these
values using the special vector @{\it device}[{\it param\/}]
construct, or with the {\cb alter} and {\cb sweep} commands.  However,
there is no sanity checking so bad numbers can cause wild behavior or
worse.

\begin{quote}
\begin{tabular}{ll}
prm1 & vo\\
prm2 & va\\
prm3 & freq\\
prm4 & td\\
prm5 & theta\\
prm6 & phi\\
\end{tabular}
\end{quote}
 
!!SEEALSO
tranfuncs

!! elements.tex 060119
!!KEYWORD
spulse 
!!TITLE
Sinusoidal Pulse
!!HTML 
    General forms:
    <blockquote>
        <tt>spulse</tt>(<i>vo vp</i> [<i>per td decay</i>])
    </blockquote>

    <p>
    Example:
    <blockquote>
        <tt>vin 1 0 spulse(0 1 25ns 40ns 1E8)</tt>
    </blockquote>

    <p>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th>parameter</th><th>description</th>
        <th>default value</th><th>units</th></tr>
    <tr><td><i>vo</i></td> <td>offset</td>
        <td>&nbsp;</td> <td>volts or amps</td></tr>
    <tr><td><i>vp</i></td> <td>peak amplitude</td>
        <td>&nbsp;</td> <td>volts or amps</td></tr>
    <tr><td><i>per</i></td> <td>period</td>
        <td><tt>tstop</tt></td> <td>seconds</td></tr>
    <tr><td><i>td</i></td> <td>delay</td>
        <td><tt>0</tt></td> <td>seconds</td></tr>
    <tr><td><i>decay</i></td> <td>decay const</td>
        <td><tt>0</tt></td> <td>1/seconds</td></tr>
    </table>

    <p>
    The waveform is described by the following table:

    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th>time</th>  <th>value</th></tr>
    <tr><td><tt>0</tt> to <i>td</i></td> <td><i>vo</i></td></tr>
    <tr><td><i>td</i> to <i>tstop</i></td>
      <td><i>vo</i> + .5*(<i>vp</i>-<i>vo</i>)*(1-<tt>cos</tt>(2*<tt>pi</tt>*(<tt>time</tt>-<i>delay</i>)/<i>per</i>))
      *<tt>exp</tt>(-(<tt>time</tt>-<i>delay</i>)*<i>decay</i>)
    </table>
    </blockquote>
 
    <p>
    This function applies only to transient analysis, where time is
    the running variable.  When referring to default values,
    <tt>tstep</tt> is the printing increment and <tt>tstop</tt> is the
    final time in <a href=".tran"> transient analysis</a>.

    <p>
    If this function is used bare and not part of an expression in a
    voltage or current source, then the general source instance
    parameters <tt>prm1</tt> etc.  map as below.  It is possible to
    read and alter these values using the special vector
    @<i>device</i>[<i>param</i>] construct, or with the <a
    href="alter"><b>alter</b></a> and <a href="sweep"><b>sweep</b></a>
    commands.  However, there is no sanity checking so bad numbers can
    cause wild behavior or worse.

    <blockquote>
    <table border=0 cellspacing=4>
    <tr><td>prm1</td><td>vo</td></tr>
    <tr><td>prm2</td><td>vp</td></tr>
    <tr><td>prm3</td><td>per</td></tr>
    <tr><td>prm4</td><td>td</td></tr>
    <tr><td>prm5</td><td>decay</td></tr>
    </table>
    </blockquote>
!!LATEX spulse elements.tex
\spgen{spulse({\it vo vp\/} [{\it per td decay\/}])} 
\spexampo{vin 1 0 spulse(0 1 25ns 40ns 1e8)}

\begin{quote}
\begin{tabular}{|l|l|l|l|} \hline
{\bf parameter} & {\bf description} & {\bf default value} &
 {\bf units}\\ \hline\hline
{\it vo} & offset & & volts or amps\\ \hline
{\it vp} & peak amplitude & & volts or amps\\ \hline
{\it per} & period & {\vt tstop} & seconds\\ \hline
{\it td} & delay & 0.0 & seconds\\ \hline
{\it decay} & decay const & 0.0 & 1/seconds\\ \hline
\end{tabular}
\end{quote}

The shape of the waveform is described by the following table:

\begin{quote}
\begin{tabular}{ll}
{\bf time} & {\bf value}\\[0.5ex]
0 & {\it vo\/}\\
{\it td\/} & {\it vo\/} $+$ 0.5$\cdot$({\it vp\/}$-${\it vo\/})( 1 $-$
cos(2$\pi\cdot$(time$-${\it td\/})/{\it per\/})$\cdot$exp($-$(time$-${\it
td\/})
$\cdot${\it decay\/}) )\\[2ex]
\end{tabular}
\end{quote}

This function applies only to transient analysis, where time is the
running variable.  When referring to default values, {\vt tstep} is
the printing increment and {\vt tstop} is the final time in transient
analysis, see \ref{tranline} for explanation.

If this function is used bare and not part of an expression in a
voltage or current source, then the general source instance parameters
{\vt prm1} etc.  map as below.  It is possible to read and alter these
values using the special vector @{\it device}[{\it param\/}]
construct, or with the {\cb alter} and {\cb sweep} commands.  However,
there is no sanity checking so bad numbers can cause wild behavior or
worse.

\begin{quote}
\begin{tabular}{ll}
prm1 & vo\\
prm2 & vp\\
prm3 & per\\
prm4 & td\\
prm5 & decay\\
\end{tabular}
\end{quote}
 
!!SEEALSO
tranfuncs

!! elements.tex 012509
!!KEYWORD
table 
!!TITLE
Table Reference
!!HTML 
    General form:
    <blockquote>
        <tt>table</tt>(<i>table_name expr</i>)<br>
        <i>table_name</i>(<i>expr</i>)  (for sources only)
    </blockquote>

    <p>
    Example:
    <blockquote>
        <tt>vin 1 0 table(tab1 v(2))</tt><br>
        <tt>exx 1 0 2 0 table(tab2 x)</tt><br>
        <tt>exx 1 0 2 0 tab2(x)</tt><br>
    </blockquote>

    <p>
    The table referenced must be specified in the input deck with a <a
    href=".table"><tt>.table<</tt></a> line.  The reference to a table
    is in the form of a <tt>table</tt> function, as above, which
    takes two arguments.  The first argument is the name of a table
    defined elsewhere in the circuit file with a <tt>.table</tt> line. 
    The second argument is an expression which provides input to the
    table.  The return value is the interpolated value from the table.

    <p>
    Tables can also be referenced as part of the ac specification for
    a dependent or independent source.  These references are used in
    ac analysis, and have a different referencing syntax.

    <p>
    In the expression used in voltage and current sources, dependent
    and independent, the second form can be used and is equivalent. 
    The <i>table_name</i> must not conflict with another internal or
    user-defined function name.

    <p>
    The <tt>table</tt> reference provides one means of implementing
    a piecewise-linear transfer function.  This can also be
    accomplished by use of the <tt>pwl</tt> function in dependent
    sources.
!!LATEX table elements.tex
\spgen{table({\it table\_name expr\/})\\
    {\it table\_name\/}({\it expr\/})\hspace{1cm}(for sources only)}
\spexamp{vin 1 0 table(tab1, v(2))\\
    exx 1 0 2 0 table(tab2, x)\\
    exx 1 0 2 0 tab2(x)}

The table referenced must be specified in the input deck with a {\vt
.table} line.  The reference to a table is in the form of a {\vt
table} function, as above, which takes two arguments.  The first
argument is the name of a table defined elsewhere in the circuit file
with a {\vt .table} line.  The second argument is an expression which
provides input to the table.  The return value is the interpolated
value from the table.

Tables can also be referenced as part of the ac specification for a
dependent or independent source.  These references are used in ac
analysis, and have a different referencing syntax.

In the expression used in voltage and current sources, dependent and
independent, the second form can be used and is equivalent.  The {\it
table\_name} must not conflict with another internal or user-defined
function name.

The {\vt table} reference provides one means of implementing a
piecewise-linear transfer function.  This can also be accomplished by
use of the {\vt pwl} function in dependent sources.
 
!!SEEALSO
tranfuncs

!! elements.tex 012509
!!KEYWORD
depsource
!!TITLE
Dependent Sources
!!HTML 
    <i>WRspice</i> source specifications are completely general in
    that they allow arbitrary functional dependence upon circuit
    variables.  However, for compatibility with previous versions of
    SPICE, the separate keying of independent and dependent sources is
    retained.  <i>WRspice</i> allows circuits to contain dependent
    sources characterized by any of the four equations in the table
    below.

    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><td><a href="vccs"><tt>VCCS</tt></a></td> <td><tt>i = g(v)</tt></td>
      <td>Voltage-Controlled Current Source</td></tr>
    <tr><td><a href="vcvs"><tt>VCVS</tt></a></td> <td><tt>v = e(v)</tt></td>
      <td>Voltage-Controlled Voltage Source</td></tr>
    <tr><td><a href="cccs"><tt>CCCS</tt></a></td> <td><tt>i = f(i)</tt></td>
      <td>Current-Controlled Current Source</td></tr>
    <tr><td><a href="ccvs"><tt>CCVS</tt></a></td> <td><tt>v = h(i)</tt></td>
      <td>Current-Controlled Voltage Source</td></tr>
    </table>
    </blockquote>

    <p>
    The functions <tt>g</tt>, <tt>e</tt>, <tt>f</tt>, and <tt>h</tt>
    represent transconductance, voltage gain, current gain, and
    transresistance, respectively.
!!LATEX depsource elements.tex
{\WRspice} source specifications are completely general in that they
allow arbitrary functional dependence upon circuit variables.
However, for compatibility with previous versions of SPICE, the
separate keying of independent and dependent sources is retained.
{\WRspice} allows circuits to contain dependent sources characterized by
any of the four equations in the table below.

\begin{tabular}{|l|l|l|}\hline
\vt VCCS & \vt i = g(v) & Voltage-Controlled Current Source\\ \hline
\vt VCVS & \vt v = e(v) & Voltage-Controlled Voltage Source\\ \hline
\vt CCCS & \vt i = f(i) & Current-Controlled Current Source\\ \hline
\vt CCVS & \vt v = h(i) & Current-Controlled Voltage Source\\ \hline
\end{tabular}

The functions {\vt g}, {\vt e}, {\vt f}, and {\vt h} represent
transconductance, voltage gain, current gain, and transresistance,
respectively.

!!SEEALSO
src

!! elements.tex 030412
!!KEYWORD
vccs
!!TITLE
Voltage Controlled Current Sources
!!HTML
    This is a special case of the general source specification
    included for backward compatibility.

    <p>
    General forms:
    <blockquote>
        <tt>g</tt><i>name</i> <i>n+ n- nc+ nc-</i> <i>expr</i>
            <i>srcargs</i><br>
        <tt>g</tt><i>name</i> <i>n+ n-</i> <tt>function</tt> | <tt>cur</tt>
            [<tt>=</tt>] <i>expr</i> <i>srcargs</i><br>
        <tt>g</tt><i>name</i> <i>n+ n-</i> <tt>poly</tt>(<i>N</i>)
            <i>poly_spec</i> <i>srcargs</i><br>
        where <i>srcargs</i> = [<tt>ac</tt> <tt>table</tt>(<i>name</i>)]<br>
    </blockquote>

    <p>
    Examples:
    <blockquote><tt>
        g1 2 0 5 0 0.1mmho<br>
        g2 2 0 5 0 log10(x)<br>
        g3 2 0 function log10(v(5))<br>
    </tt></blockquote>

    <p>
    The <i>n+</i> and <i>n-</i> are the positive and negative nodes,
    respectively.  Current flow is from the positive node, through the
    source, to the negative node.  The <i>nc+</i> and <i>nc-</i> are
    the positive and negative controlling nodes, respectively.

    <p>
    In the first form, if the <a href="devexpr"><i>expr</i></a> is a
    constant, it represents the transconductance in siemens.  If no
    expression is given, a unit constant value is assumed.  Otherwise,
    the <i>expr</i> computes the source current, where the variable
    "<tt>x</tt>" if used in the <i>expr</i> is taken to be the
    controlling voltage (v(<i>nc+</i><tt>,</tt><i>nc-</i>)).  In this
    case only, the <a href="pwl"><tt>pwl</tt></a> construct if used in
    the <i>expr</i> takes as its input variable the value of
    <tt>x</tt> rather than time, thus a piecewise linear transfer
    function can be implemented using a <tt>pwl</tt> statement.  The
    second form is similar, but <tt>x</tt> is not defined.  The
    keywords "<tt>function</tt>" and "<tt>cur</tt>" are equivalent. 
    The third form allows use of the SPICE2 <a
    href="polyexpr"><tt>poly</tt></a> construct.
 
    <p>
    If the <tt>ac</tt> parameter is given and the <tt>table</tt>
    keyword follows, then the named table is taken to contain complex
    <i>transfer</i> coefficient data, which will be used in ac
    analysis (and possibly elsewhere, see below).  For each frequency,
    the source output will be the interpolated transfer coefficient
    from the table multiplied by the input.  The table must be
    specified with a <a href=".table"><tt>.table</tt></a> line, and
    must have the <tt>ac</tt> keyword given.

    <p>
    If an ac table is specified, and no dc/transient transfer function
    or coefficient is given, then in transient analysis, the source
    transfer will be obtained through Fourier analysis of the table
    data.  This is somewhat experimental, and may be prone to
    numerical errors.

    <p>
    In ac analysis, the transfer coefficient can be real or complex. 
    If complex, the imaginary value follows the real value.  Only
    constants or constant expressions are valid in this case.  If the
    source function is specified in this way, the real component is
    used in dc and transient analysis.  This will also override a
    table, if given.
!!LATEX vccs elements.tex
This is a special case of the general source specification included
for backward compatibility.

\spgen{g{\it name n\/}+ {\it n\/}- {\it nc\/}+ {\it nc\/}- [{\it expr}]
  {\it srcargs}\\
g{\it name n\/}+ {\it n\/}- function | cur [{\vt =}] {\it expr}
  {\it srcargs}\\
g{\it name n\/}+ {\it n\/}- poly {\it poly\_spec}
  {\it srcargs}\\
{\rm where} {\it srcargs} = [{\vt ac table}({\it name\/})]}
\spexamp{g1 2 0 5 0 0.1mmho\\
g2 2 0 5 0 log10(x)\\
g3 2 0 function log10(v(5))}

The {\it n\/}{\vt +} and {\it n\/}{\vt -} are the positive and
negative nodes, respectively.  Current flow is from the positive node,
through the source, to the negative node.  The parameters {\it
nc\/}{\vt +} and {\it nc\/}{\vt -} are the positive and negative
controlling nodes, respectively.

In the first form, if the {\it expr} is a constant, it represents the
transconductance in siemens.  If no expression is given, a unit
constant value is assumed.  Otherwise, the {\it expr} computes the
source current, where the variable ``{\vt x}'' if used in the {\it
expr} is taken to be the controlling voltage (v({\it nc\/}{\vt
+},{\it nc\/}{\vt -})).  In this case only, the {\vt pwl} construct
if used in the {\it expr} takes as its input variable the value of
``{\vt x}'' rather than time, thus a piecewise linear transfer
function can be implemented using a {\vt pwl} statement.  The second
form is similar, but ``{\vt x}'' is not defined.  The keywords ``{\vt
function}'' and ``{\vt cur}'' are equivalent.  The third form allows
use of the SPICE2 {\vt poly} construct.

More information on the function specification can be found in
\ref{indepsrc}, and the {\vt poly} specification is described in
\ref{polyspec}.

If the {\vt ac} parameter is given and the {\vt table} keyword
follows, then the named table is taken to contain complex {\it
transfer} coefficient data, which will be used in ac analysis (and
possibly elsewhere, see below).  For each frequency, the source output
will be the interpolated transfer coefficient from the table
multiplied by the input.  The table must be specified with a {\vt
.table} line, and must have the {\vt ac} keyword given.

If an ac table is specified, and no dc/transient transfer function or
coefficient is given, then in transient analysis, the source transfer
will be obtained through Fourier analysis of the table data.  This is
somewhat experimental, and may be prone to numerical errors.

In ac analysis, the transfer coefficient can be real or complex.  If
complex, the imaginary value follows the real value.  Only constants
or constant expressions are valid in this case.  If the source
function is specified in this way, the real component is used in dc
and transient analysis.  This will also override a table, if given.

!!SEEALSO
depsource

!! elements.tex 030412
!!KEYWORD
vcvs
!!TITLE
Voltage-Controlled Voltage Sources
!!HTML 
    This is a special case of the general source specification
    included for backward compatibility.

    <p>
    General forms:
    <blockquote>
        <tt>e</tt><i>name</i> <i>n+ n- nc+ nc-</i> <i>expr</i>
            <i>srcargs</i><br>
        <tt>e</tt><i>name</i> <i>n+ n-</i> <tt>function</tt> | <tt>vol</tt>
            [<tt>=</tt>] <i>expr</i> <i>srcargs</i><br>
        <tt>e</tt><i>name</i> <i>n+ n-</i> <tt>poly</tt>(<i>N</i>)
            <i>poly_spec</i> <i>srcargs</i><br>
        where <i>srcargs</i> = [<tt>ac</tt> <tt>table</tt>(<i>name</i>)]<br>
    </blockquote>

    <p>
    Examples:
    <blockquote>
        e1 2 3 14 1 2.0<br>
        e1 2 3 14 1 x+.015*x*x<br>
        e1 2 3 function v(14,1)+.015*v(14,1)*v(14,1)<br>
    </blockquote>

    <p>
    The <i>n+</i> is the positive node, and <i>n-</i> is the negative
    node, <i>nc+</i> and <i>nc-</i> are the positive and negative
    controlling nodes, respectively.

    <p>
    In the first form, if the <a href="devexpr"><i>expr</i></a> is a
    constant, it represents the linear voltage gain.  If no expression
    is given, a unit constant value is assumed.  Otherwise, the
    <i>expr</i> computes the source voltage, where the variable
    "<tt>x</tt>" if used in the <i>expr</i> is taken to be the
    controlling voltage (v(<i>nc+</i><tt>,</tt><i>nc-</i>)).  In this
    case only, the <a href="pwl"><tt>pwl</tt></a> construct if used in
    the <i>expr</i> takes as its input variable the value of
    <tt>x</tt> rather than time, thus a piecewise linear transfer
    function can be implemented using a <tt>pwl</tt> statement.  The
    second form is similar, but <tt>x</tt> is not defined.  The
    keywords "<tt>function</tt>" and "<tt>vol</tt>" are equivalent. 
    The third form allows use of the SPICE2 <a
    href="polyexpr"><tt>poly</tt></a> construct.
 
    <p>
    If the <tt>ac</tt> parameter is given and the <tt>table</tt>
    keyword follows, then the named table is taken to contain complex
    <i>transfer</i> coefficient data, which will be used in ac
    analysis (and possibly elsewhere, see below).  For each frequency,
    the source output will be the interpolated transfer coefficient
    from the table multiplied by the input.  The table must be
    specified with a <a href=".table"><tt>.table</tt></a> line, and
    must have the <tt>ac</tt> keyword given.

    <p>
    If an ac table is specified, and no dc/transient transfer function
    or coefficient is given, then in transient analysis, the source
    transfer will be obtained through Fourier analysis of the table
    data.  This is somewhat experimental, and may be prone to
    numerical errors.

    <p>
    In ac analysis, the transfer coefficient can be real or complex. 
    If complex, the imaginary value follows the real value.  Only
    constants or constant expressions are valid in this case.  If the
    source function is specified in this way, the real component is
    used in dc and transient analysis.  This will also override a
    table, if given.
!!LATEX vcvs elements.tex
This is a special case of the general source specification included
for backward compatibility.

\spgen{e{\it name n\/}+ {\it n\/}- {\it nc\/}+ {\it nc\/}- [{\it expr}]
  {\it srcargs}\\
e{\it name n\/}+ {\it n\/}- function | vol [{\vt =}] {\it expr}
  {\it srcargs}\\
e{\it name n\/}+ {\it n\/}- poly {\it poly\_spec}
  {\it srcargs}\\
{\rm where} {\it srcargs} = [{\vt ac table}({\it name\/})]}
\spexamp{e1 2 3 14 1 2.0\\
e2 2 3 14 1 x+.015*x*x\\
e3 2 3 function v(14,1)+.015*v(14,1)*v(14,1)}

The {\it n\/}{\vt +} is the positive node, and {\it n\/}{\vt -} is the
negative node.  {\it nc\/}{\vt +} and {\it nc\/}{\vt -} are the
positive and negative controlling nodes, respectively.

In the first form, if the {\it expr} is a constant, it represents the
linear voltage gain.  If no expression is given, a unit constant
value is assumed.  Otherwise, the {\it expr} computes the source
voltage, where the variable ``{\vt x}'' if used in the {\it expr} is
taken to be the controlling voltage (v({\it nc\/}{\vt +},{\it
nc\/}{\vt -})).  In this case only, the {\vt pwl} construct if used
in the {\it expr} takes as its input variable the value of ``{\vt
x}'' rather than time, thus a piecewise linear transfer function can
be implemented using a {\vt pwl} statement.  The second form is
similar, but ``{\vt x}'' is not defined.  The keywords ``{\vt
function}'' and ``{\vt vol}'' are equivalent.  The third form allows
use of the SPICE2 {\vt poly} construct.

More information of the function specification can be found in
\ref{indepsrc}, and the {\vt poly} specification is described in
\ref{polyspec}.

If the {\vt ac} parameter is given and the {\vt table} keyword
follows, then the named table is taken to contain complex {\it
transfer} coefficient data, which will be used in ac analysis (and
possibly elsewhere, see below).  For each frequency, the source output
will be the interpolated transfer coefficient from the table
multiplied by the input.  The table must be specified with a {\vt
.table} line, and must have the {\vt ac} keyword given.

If an ac table is specified, and no dc/transient transfer function or
coefficient is given, then in transient analysis, the source transfer
will be obtained through Fourier analysis of the table data.  This is
somewhat experimental, and may be prone to numerical errors.

In ac analysis, the transfer coefficient can be real or complex.  If
complex, the imaginary value follows the real value.  Only constants
or constant expressions are valid in this case.  If the source
function is specified in this way, the real component is used in dc
and transient analysis.  This will also override a table, if given.

!!SEEALSO
depsource
 
!! elements.tex 030815
!!KEYWORD
cccs
!!TITLE
Current-Controlled Current Sources
!!HTML 
    This is a special case of the general source specification
    included for backward compatibility.

    <p>
    General forms:
    <blockquote>
        <tt>f</tt><i>name</i> <i>n+ n- vnam</i> <i>expr</i> <i>srcargs</i><br>
        <tt>f</tt><i>name</i> <i>n+ n-</i> <tt>function</tt> | <tt>cur</tt>
            [<tt>=</tt>] <i>expr</i> <i>srcargs</i><br>
        <tt>f</tt><i>name</i> <i>n+ n-</i> <tt>poly</tt>(<i>N</i>)
            <i>poly_spec</i> <i>srcargs</i><br>
        where <i>srcargs</i> = [<tt>ac</tt> <tt>table</tt>(<i>name</i>)]<br>
    </blockquote>

    <p>
    Examples:
    <blockquote><tt>
        f1 13 5 vsens 5<br>
        f2 13 5 vsens 1-x*x ac table(acdata)<br>
        f3 13 5 function 1-i(vsens)*i(vsens)
    </tt></blockquote>

    <p>
    The <i>n+</i> and <i>n-</i> are the positive and negative nodes,
    respectively.  Current flow is from the positive node, through the
    source, to the negative node.  The <i>vnam</i> is the name of a
    voltage source or inductor through which the controlling current
    flows.  If <i>vnam</i> refers to a voltage source, the direction
    of positive controlling current flow is from the positive node,
    through the source, to the negative node.  If <i>vnam</i> names an
    inductor, the current flow is from the first node specified for
    the inductor, through the inductor, to the second node.

    <p>
    In the first form, if the <a href="devexpr"><i>expr</i></a> is a
    constant, it represents the linear current gain.  If no expression
    is given, a unit constant value is assumed.  Otherwise, the
    <i>expr</i> computes the source current, where the variable
    "<tt>x</tt>" if used in the <i>expr</i> is taken to be the
    controlling current (i(<i>vnam</i>)).  In this case only, the <a
    href="pwl"><tt>pwl</tt></a> construct if used in the <i>expr</i>
    takes as its input variable the value of <tt>x</tt> rather than
    time, thus a piecewise linear transfer function can be implemented
    using a <tt>pwl</tt> statement.  The second form is similar, but
    <tt>x</tt> is not defined.  The keywords "<tt>function</tt>" and
    "<tt>cur</tt>" are equivalent.  The third form allows use of the
    SPICE2 <a href="polyexpr"><tt>poly</tt></a> construct.

    <p>
    If the <tt>ac</tt> parameter is given and the <tt>table</tt>
    keyword follows, then the named table is taken to contain complex
    <i>transfer</i> coefficient data, which will be used in ac
    analysis (and possibly elsewhere, see below).  For each frequency,
    the source output will be the interpolated transfer coefficient
    from the table multiplied by the input.  The table must be
    specified with a <a href=".table"><tt>.table</tt></a> line, and
    must have the <tt>ac</tt> keyword given.

    <p>
    If an ac table is specified, and no dc/transient transfer function
    or coefficient is given, then in transient analysis, the source
    transfer will be obtained through Fourier analysis of the table
    data.  This is somewhat experimental, and may be prone to
    numerical errors.

    <p>
    In ac analysis, the transfer coefficient can be real or complex. 
    If complex, the imaginary value follows the real value.  Only
    constants or constant expressions are valid in this case.  If the
    source function is specified in this way, the real component is
    used in dc and transient analysis.  This will also override a
    table, if given.
!!LATEX cccs elements.tex
This is a special case of the general source specification included
for backward compatibility.

\spgen{f{\it name n\/}+ {\it n\/}- {\it vnam expr} {\it srcargs}\\
f{\it name n\/}+ {\it n\/}- function | cur [{\vt =}] {\it expr\/}
 {\it srcargs}\\
f{\it name n\/}+ {\it n\/}- poly {\it poly\_spec} {\it srcargs}\\
{\rm where} {\it srcargs} = [{\vt ac table}({\it name\/})]}
\spexamp{f1 13 5 vsens 5\\
f2 13 5 1-x*x ac table(acdata)\\
f3 13 5 function 1-i(vsens)*i(vsens)} 

The {\it n\/}{\vt +} and {\it n\/}{\vt -} are the positive and
negative nodes, respectively.  Current flow is from the positive node,
through the source, to the negative node.  The parameter {\it vnam\/}
is the name of a voltage source or inductor through which the
controlling current flows.  If {\it vnam} refers to a voltage source,
the direction of positive controlling current flow is from the
positive node, through the source, to the negative node.  If {\it
vnam} names an inductor, the current flow is from the first node
specified for the inductor, through the inductor, to the second node. 

In the first form, if the {\it expr} is a constant, it represents the
linear current gain.  If no expression is given, a unit constant
value is assumed.  Otherwise, the {\it expr} computes the source
current, where the variable ``{\vt x}'' if used in the {\it expr} is
taken to be the controlling current (i({\it vnam\/})).  In this case
only, the {\vt pwl} construct if used in the {\it expr} takes as its
input variable the value of ``{\vt x}'' rather than time, thus a
piecewise linear transfer function can be implemented using a {\vt
pwl} statement.  The second form is similar, but ``{\vt x}'' is not
defined.  The keywords ``{\vt function}'' and ``{\vt cur}'' are
equivalent.  The third form allows use of the SPICE2 {\vt poly}
construct.

More information of the function specification can be found in
\ref{indepsrc}, and the {\vt poly} specification is described in
\ref{polyspec}.

If the {\vt ac} parameter is given and the {\vt table} keyword
follows, then the named table is taken to contain complex {\it
transfer} coefficient data, which will be used in ac analysis (and
possibly elsewhere, see below).  For each frequency, the source output
will be the interpolated transfer coefficient from the table
multiplied by the input.  The table must be specified with a {\vt
.table} line, and must have the {\vt ac} keyword given.

If an ac table is specified, and no dc/transient transfer function or
coefficient is given, then in transient analysis, the source transfer
will be obtained through Fourier analysis of the table data.  This is
somewhat experimental, and may be prone to numerical errors.

In ac analysis, the transfer coefficient can be real or complex.  If
complex, the imaginary value follows the real value.  Only constants
or constant expressions are valid in this case.  If the source
function is specified in this way, the real component is used in dc
and transient analysis.  This will also override a table, if given.

!!SEEALSO
depsource

!! elements.tex 030815
!!KEYWORD
ccvs
!!TITLE
Current-Controlled Voltage Sources
!!HTML
    This is a special case of the general source specification
    included for backward compatibility.

    <p>
    General forms:
    <blockquote>
        <tt>h</tt><i>name</i> <i>n+ n- vnam</i> <i>expr</i> <i>srcargs</i><br>
        <tt>h</tt><i>name</i> <i>n+ n-</i> <tt>function</tt> | <tt>vol</tt>
            [<tt>=</tt>] <i>expr</i> <i>srcargs</i><br>
        <tt>h</tt><i>name</i> <i>n+ n-</i> <tt>poly</tt>(<i>N</i>)
            <i>poly_spec</i> <i>srcargs</i><br>
        where <i>srcargs</i> = [<tt>ac</tt> <tt>table</tt>(<i>name</i>)]<br>
    </blockquote>

    <p>
    Examples:
    <blockquote><tt>
        h1 5 17 vz 0.5k<br>
        h2 5 17 vz 0.71,0.71<br>
        h3 5 17 vz 2.5*exp(x/2.5) ac table(myvals)<br>
        ha 5 17 function 2.5*exp(i(vz)/2.5)<br>
    </tt></blockquote>

    <p>
    The <i>n+</i> and <i>n-</i> are the positive and negative nodes,
    respectively.  The <i>vnam</i> is the name of a voltage source or
    inductor through which the controlling current flows.  If
    <i>vnam</i> references a voltage source, the direction of positive
    controlling current flow is from the positive node, through the
    source, to the negative node.  If <i>vnam</i> references an
    inductor, the controlling current flows from the first node
    specified for the inductor, through the inductor, to the second
    node.

    <p>
    <font color=red">In releases earlier than 4.1.15 the output for a
    constant transfer value case was the reverse polarity of the
    description here.
    </font>

    <p>
    In the first form, if the <a href="devexpr"><i>expr</i></a> is a
    constant, it represents the transresistance in ohms.  If no
    expression is given, a unit constant value is assumed.  Otherwise,
    the <i>expr</i> computes the source voltage, where the variable
    "<tt>x</tt>" if used in the <i>expr</i> is taken to be the
    controlling current (i(<i>vnam</i>)).  In this case only, the <a
    href="pwl"><tt>pwl</tt></a> construct if used in the <i>expr</i>
    takes as its input variable the value of <tt>x</tt> rather than
    time, thus a piecewise linear transfer function can be implemented
    using a <tt>pwl</tt> statement.  The second form is similar, but
    <tt>x</tt> is not defined.  The keywords "<tt>function</tt>" and
    "<tt>vol</tt>" are equivalent.  The third form allows use of the
    SPICE2 <a href="polyexpr"><tt>poly</tt></a> construct.

    <p>
    If the <tt>ac</tt> parameter is given and the <tt>table</tt>
    keyword follows, then the named table is taken to contain complex
    <i>transfer</i> coefficient data, which will be used in ac
    analysis (and possibly elsewhere, see below).  For each frequency,
    the source output will be the interpolated transfer coefficient
    from the table multiplied by the input.  The table must be
    specified with a <a href=".table"><tt>.table</tt></a> line, and
    must have the <tt>ac</tt> keyword given.

    <p>
    If an ac table is specified, and no dc/transient transfer function
    or coefficient is given, then in transient analysis, the source
    transfer will be obtained through Fourier analysis of the table
    data.  This is somewhat experimental, and may be prone to
    numerical errors.

    <p>
    In ac analysis, the transfer coefficient can be real or complex. 
    If complex, the imaginary value follows the real value.  Only
    constants or constant expressions are valid in this case.  If the
    source function is specified in this way, the real component is
    used in dc and transient analysis.  This will also override a
    table, if given.
!!LATEX ccvs elements.tex
This is a special case of the general source specification included
for backward compatibility.

\spgen{h{\it name n\/}+ {\it n\/}- {\it vnam expr} {\it srcargs}\\
h{\it name n\/}+ {\it n\/}- function | vol [{\vt =}] {\it expr\/}
 {\it srcargs}\\
h{\it name n\/}+ {\it n\/}- poly {\it poly\_spec} {\it srcargs}\\
{\rm where} {\it srcargs} = [{\vt ac table}({\it name\/})]}
\spexamp{h1 5 17 vz 0.5k\\
h2 5 17 0.71,0.71\\
h3 5 17 vz 2.5*exp(x/2.5) ac table(myvals)\\
h2 5 17 function 2.5*exp(i(vz)/2.5)}

Above, {\it n\/}{\vt +} and {\it n\/}{\vt -} are the positive and
negative nodes, respectively.  The parameter {\it vnam} is the name
of a voltage source or inductor through which the controlling current
flows.  If {\it nam} references a voltage source, the direction of
positive controlling current flow is from the positive node, through
the source, to the negative node.  If {\it vnam\/} references an
inductor, the controlling current flows from the first node specified
for the inductor, through the inductor, to the second node.

{\bf Note}:  In releases earlier than 4.1.15 the output for a constant
transfer value case was the reverse polarity of the description here.

In the first form, if the {\it expr} is a constant, it represents the
transresistance in ohms.  If no expression is given, a unit constant
value is assumed.  Otherwise, the {\it expr} computes the source
voltage, where the variable ``{\vt x}'' if used in the {\it expr} is
taken to be the controlling current (i({\it vnam\/})).  In this case
only, the {\vt pwl} construct if used in the {\it expr} takes as its
input variable the value of ``{\vt x}'' rather than time, thus a
piecewise linear transfer function can be implemented using a {\vt
pwl} statement.  The second form is similar, but ``{\vt x}'' is not
defined.  The keywords ``{\vt function}'' and ``{\vt vol}'' are
equivalent.  The third form allows use of the SPICE2 {\vt poly}
construct.

More information of the function specification can be found in
\ref{indepsrc}, and the {\vt poly} specification is described in
\ref{polyspec}.

If the {\vt ac} parameter is given and the {\vt table} keyword
follows, then the named table is taken to contain complex {\it
transfer} coefficient data, which will be used in ac analysis (and
possibly elsewhere, see below).  For each frequency, the source output
will be the interpolated transfer coefficient from the table
multiplied by the input.  The table must be specified with a {\vt
.table} line, and must have the {\vt ac} keyword given.

If an ac table is specified, and no dc/transient transfer function or
coefficient is given, then in transient analysis, the source transfer
will be obtained through Fourier analysis of the table data.  This is
somewhat experimental, and may be prone to numerical errors.

In ac analysis, the transfer coefficient can be real or complex.  If
complex, the imaginary value follows the real value.  Only constants
or constant expressions are valid in this case.  If the source
function is specified in this way, the real component is used in dc
and transient analysis.  This will also override a table, if given.

!!SEEALSO
depsource
 
