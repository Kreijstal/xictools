
\pagenumbering{arabic}
\chapter{Introduction to {\WRspice}}

%S-----------------------------------------------------------------------------
\section{History of {\WRspice}}

% spMain.hlp:sphistory 051522

In the early days of radio, before the term ``electronics'' came into
use, experimenters and scientists (engineers designed bridges then)
built circuits on whatever could be found that was appropriate.  One
popular substrate was the wooden breadboard as found in most kitchens. 
The breadboard could be used to secure the tube sockets and other
appendages through use of screws.  Thus, the term ``breadboard'' as a
substrate for the building of electronic circuits was born.

Breadboards, in one form or another, were used for the construction of
all electronic prototype circuits until the integrated circuit was
invented in 1957.  Even well afterward, the integrated circuit was
only another component on the breadboard.  A new circuit could be
easily (well, in principle) debugged, modified, enhanced, or otherwise
engineered toward perfection, as all points of the circuit were
accessible for testing and measurement.

After it became possible to put more than a small number of devices on
an integrated circuit chip, design of such chips became quite
challenging.  Obviously there was no opportunity to solder in new
components, or even probe the internal connections.  The circuit had
to be perfect as designed, or it wouldn't work properly.  This is
almost never the case for any but the simplest design for any but
those engineers with godlike intelligence (or luck).  Clearly new
tools and methods were needed.

The rescue came in the early 1970's with the distribution of a
computer program called SPICE (Simulation Program for Integrated
Circuit Engineering), developed at the University of California,
Berkeley.  SPICE was a big (for its day) Fortran computer program,
requiring the power of a mainframe computer.  A circuit was described
in a certain syntax, which was punched into IBM computer cards.  The
terminology this inspired persists to this day, as a line of SPICE
input is often referred to as a ``card'', and a complete circuit
description as a ``deck''.  In the bad old days, the engineer would
laboriously punch the cards, deliver them to the Computer Center, and
receive the line printer output a few hours later.  It would generally
take several iterations before the first page of output would not
say ``Run Aborted...''.  Old-time engineers abhorred this activity,
which seemed suitable for office wimps and students only.  After a few
years, and the advent of Tektronix direct view storage terminals,
SPICE became the preeminent means of designing not just integrated
circuits, but the old-fashioned kind as well.

SPICE is the progenitor of most circuit simulators currently in use.
As the source code was available for next to nothing, major
organizations customized it for their own needs, and smoothed over
some of the rougher edges.  It remains a numerically intensive program
which can tax even the largest of today's computers.

Looking back, one can identify several important milestones in the
accessibility of computer power to the technically inclined masses. 
The first example was the ability to run the BASIC programming
language on a desktop computer, introduced in the late 1970's with the
Tektronix 4051.  This 8-bit machine with a built-in direct view
storage tube for the first time allowed engineers and scientists to
have directly applicable computer power at their desk or laboratory
bench.  Also at about this time, the UNIX operating system running on
a VAX minicomputer became popular, largely supplanting the
ahead-of-their-time desktop computers.  The VAX, although it was a
mainframe, was very cost effective as compared to the competition, and
UNIX was a much more desirable operating system for scientific and
engineering purposes than others available.  As with the 4051, it
allowed computer accessibility at the point of need, through use of a
terminal.  Although one could compile and run SPICE on a VAX, it would
tend to radically hog the VAX's resources, bringing the system to an
annoying unresponsive state.  As a consequence, many system managers
forbade the use of SPICE on their machines, thus SPICE users were
still faced with interfacing to the company CDC or IBM or Cray, and
the attendant CPU time charges and batch mode operation.  This
situation persisted until the advent of the UNIX workstation in the
early 1980's.

The original workstations were able to run SPICE, however the
execution speed was quite slow by modern standards.  Still, they were
often faster than a heavily loaded central mainframe, and although
expensive, were cost effective over time as compared to CPU charges
for a mainframe.  Many more engineers were able to take advantage of
the convenience of running their simulations on local workstations,
but due to the expense of the early workstations, the vast majority
still had to slug it out with the mainframe.

In the early 1980's, the IBM personal computer came on the scene, and
the real computer revolution was at hand.  However, these micros had
severe limitations which prevented them from even loading a program as
large as SPICE, thus they offered no solution to engineers and
scientists needing major number crunching ability.  They did, however,
provide the ability to run BASIC (thanks to Bill Gates), thus the
personal computer began to displace the VAX in many instances, which
had in turn displaced the earliest desktop BASIC machines.  As the
number of machines grew, and thanks to the ingenuity and manufacturing
skills resident in the Far East, the cost of these desktop computers
dropped rapidly.  Intel, designer and purveyor of the microprocessor
which was at the heart of the IBM compatible PC, made tons of money,
which it wisely reinvested in newer and more capable models.  However,
the original operating system, DOS, which ran universally on PC's, was
designed for and significantly incorporated the limitations of the
earliest microprocessors used in PC's.  These limitations have echos
even today in certain Microsoft products.

Thus, it was not with a bang but with a whimper that the first
inexpensive desktop computers which were capable of running SPICE and
similar applications appeared.  The Intel 386 microprocessor made this
possible.  Unlike its predecessors, the 386 was a true 32 bit
architecture, more powerful than a room full of VAX hardware.  It
could easily sit on a desk, and cost, even in the early days, less
than ten thousand dollars for a fully equipped system.  Alas, however,
the 386 PC was like a Ferrari which was deliberately equipped to
emulate a Volkswagen.  In order for the 386 to be compatible with its
relatively brain-dead predecessors, Intel included an emulation mode
in the instruction set.  In this mode, called ``real mode'' by Intel,
the 386 would behave as a somewhat faster version of earlier
microprocessors, and thus be compatible with DOS, and all of the
software written for DOS.  So thorough was the emulation that even
though the 386 could access 4 gigabits of memory directly, it was
prevented from doing so under DOS, so that games and other archaic
programs which could possibly make use of the memory address wrap
around at 1 megabyte would perform as on earlier chips.  To this day
under DOS, the 386 and its descendants operate in this emulation mode,
leaving the high-power native mode unused.

Intel assumed that a software vendor, meaning Microsoft, would soon
produce a successor to DOS that would unleash the full power of its
new chips.  Alas, Microsoft responded by ignoring this potential in
its own products, and appeared unsupportive of the exploitation of
this power by other software vendors.  The size of the DOS market
evidently influenced this business decision.  However, thankfully, a
few small companies saw the potential.  The first was Phar Lap, which
by working directly with Intel delivered a product known as a DOS
extender.  Intel and Phar Lap, and others, created a specification
under which extended DOS applications could coexist with regular DOS
programs to a large extent.  The DOS extender allowed programs of
arbitrary size to be compiled and executed in the 32-bit native mode,
which Intel termed ``protected mode''.  The term derives from the memory
mapping which allows all applications to have their own address space,
and not clobber one another as they can under DOS.  At last, with this
product and the right compiler, it was possible to run SPICE on a
desktop PC, without worrying about the memory limitations of DOS.

Microsoft eventually began to exploit some aspects of protected mode
in the Windows product, however, Windows was completely incompatible
with extended DOS software at the time.  Microsoft's objective was to
influence developers of large applications to port to Windows, for
which they made available a \$500.00 software development kit. 
Unfortunately Windows at that time had a memory management system
which most judged inadequate for applications such as SPICE, plus the
support for earlier versions of the Intel microprocessors in Windows
added rather severe performance penalties.  Thus, in spite of the lack
of Windows compatibility, the DOS extender market greatly expanded,
and several large commercial applications made use of this technology. 
DOS extenders were eventually being included with many advanced
compilers for ``free''.

The DOS extenders extended the life span of DOS, however many
limitations remained.  One such limitation was the lack of
multi-tasking.  Although some products such as Quarterdeck's DesqView
provided some crude multitasking, clearly the time had arrived that a
completely new operating system was in order.  These new operating
systems began arriving in 1992.  Vendors of advanced workstations,
such as Sun and Next, released versions of their UNIX-derived
operating systems for Intel machines.  IBM introduced OS2 2.0, which
was a 32-bit version of the OS2 operating system.  Microsoft has
released the NT operating system, the first version of Windows that
``really'' used protected mode.

The contender that will probably most interest engineers and
scientists is UNIX.  This operating system has a multi-decade history
of use and improvement, with features and performance other operating
systems are striving to emulate.  Proprietary operating systems based
on UNIX are available from several vendors, unfortunately, the cost,
still quite high due to the licensing fee extracted by the copyright
holder, is a deterrent.  However, UNIX clones, which operate the same
but use non-copyrighted software, are now widely available.  The most
popular of these are Linux and FreeBSD, both of which are available on
the Internet, and on CD for a small fee.  Both provide the advanced
user with a state-of-the-art operating system, capable of running the
plethora of applications available on the Internet.  Linux has become
quite popular with the general technically-inclined public, while
FreeBSD has found a large niche as an Internet server, due to its
reliability and speed.  The running of massive applications on a
desktop computer (or even a laptop) is now a reality.  A properly
equipped Intel-compatible computer running FreeBSD can be considered
in every respect a `'Unix workstation''.

The original Fortran version of SPICE became widespread in the
industry, and the creators of SPICE dispersed and went on to new
projects.  As SPICE became more widely used on modern hardware, its
age began to show.  Thus, the Berkeley groups set about to rewrite
SPICE in a modern programming language (C), and added new features and
functionality.  The result was SPICE3.  Unlike the previous versions
of SPICE, SPICE3 was designed for interactive use.  Furthermore, there
were built-in features for plotting output on-screen, as well as
enhanced control over the run in progress. SPICE3 has to date not
received the widespread acceptance of its predecessor, mainly because
is lacks the long history of use.  Early releases did have bugs, and
certain features were lacking.  The new code, being written in a
structured form, is relatively easy to modify, thus SPICE3 should
become a standard in time, however it is also competing with
commercial versions of SPICE with many of the same features.  The
original SPICE is still being shipped ``as is'', and although it is
robust and stable, there are parts of the code that seemingly nobody
understands.

In the early 1980's, IBM had a large project to introduce a computer
based on Josephson junction logic.  IBM used internal software to
model these circuits, as SPICE was not designed to support Josephson
junctions.  To provide a generally available software simulation tool
for the analysis of Josephson circuits, the Cryoelectronics group at
Berkeley modified SPICE to include Josephson junctions.  This version
of SPICE, JSPICE, was distributed by the Cryoelectronics group to the
handful of interested researchers.  It quickly became the dominant
tool for the simulation of these circuits (outside of IBM).

However, being based in SPICE, there were many aspects of the program
which could stand improvement.  Making these improvements would entail
a complete rewriting of the SPICE code, a rather formidable task with
the Fortran source.  Nevertheless, this was done in large measure for
internal use at Hypres, a small company engaged in superconductive
electronics.  The Hyspice program contained a numerical core written
in C, which was supported by much of the original SPICE Fortran.  The
algorithms were modified to increase execution speed, while providing
full support (rather than a tacked on appendage) for Josephson
junctions.  The execution speed for Josephson circuits increased by
about a factor of 3--5 over the older JSPICE.  Hyspice, however, was
basically a batch mode program similar to JSPICE, although it was
designed to work with a graphics post-processor, which was a separate
application.

While entering a consulting and contract design practice, the author
of Hyspice required a simulation tool in order to pursue design
activities.  Hyspice was proprietary to a former employer, and was
obsolete anyway.  JSPICE was even more obsolete.  Thus, the author
decided to modify SPICE3 to incorporate a Josephson model.  Further
modifications were anticipated so as to provide uncompromising
capability and flexibility in the simulation of circuits using
Josephson devices (without affecting the ability to simulate
conventional circuits).  The resulting program, named JSPICE3, also
had to be compatible with the author's 386 computer, yet be portable
to other computers and operating systems should the need arise. 
JSPICE3 evolved for several years.  Along the way, new features were
added, including a schematic capture front-end.  The program, still
available from Whiteley Research Inc., currently runs on most UNIX
platforms, and is still being used in several industrial and
educational facilities.

The author, once again getting restless, founded Whiteley Research
Inc., in Sunnyvale, CA in 1996.  The company was to develop a new
successor to JSPICE3, and other tools for schematic capture and mask
layout editing.  After about one solid year of development, the
{\XicTools} toolset was announced.  The electrical circuit simulator,
part of the core of the {\XicTools} and known as {\WRspice}, is a
descendent of the JSPICE3 program, and maintains full compatibility. 
The new program was migrated to the C++ programming language, for
improved maintainability.  Compatibility with the older SPICE program
was improved, as support for certain capabilities in SPICE, such as
the POLY directive, that were missing from SPICE3 were incorporated in
{\WRspice}.  {\WRspice} is more network-aware than its predecessors,
and in fact can control the dispatching of jobs to remote machines, so
that repetitive operations, such as Monte Carlo analysis, can exploit
all of the machines in the user's workgroup in parallel.  Incidently,
Monte Carlo analysis is a new feature, too.  Most of {\WRspice} can be
controlled graphically using point-and-click, yet is prompt-line
compatible with its predecessors.

\index{HSPICE simulator}

Probably the most popular industrial-strength SPICE simulator is
HSPICE$^{\et tm}$ from Synopsys, Inc.  Although ``next generation''
simulators from several vendors offer greater simulation speed and
support larger circuits, the variety and completeness of HSPICE device
models, algorithm flexibility, and usage history have made HSPICE a
target simulator for most if not all process design kits provided by
foundry services.  {\WRspice} has evolved to incorporate some of the
features of HSPICE, such as support for parameters and single-quoted
expressions, and device model extensions, to enable compatibility with
these design kits.  Further, when there is a conflict between HSPICE
and Berkeley SPICE defaults, such as in the assumed temperature,
{\WRspice} has adopted the HSPICE conventions.  This is to conform to
industry standards and current user expectations.  Though derived from
Berkeley Spice3, {\WRspice} seeks to emulate HSPICE behavior as much
as possible.

However, there are some rather fundamental differences, for example:
\begin{enumerate}
\item {\it WRspice} is designed for interactive use and contains an
integrated graphical package, HSPICE is batch-mode only and a separate
plotting program is required.

\item Not being interactive, HSPICE has no notion of a shell, or
shell expansion.  The default treatment of the dollar-sign
character is therefor very different.
\end{enumerate}


%S-----------------------------------------------------------------------------
\section{{\WRspice} Overview}

% spMain.hlp:spice 012609

{\WRspice} is a general-purpose circuit simulation program based on the
venerable Berkeley SPICE (Simulation Program for Integrated Circuit
Engineering).  Although completely compatible with modern
implementations of Berkeley SPICE, and partially compatible with many
commercial extensions, {\WRspice} is an entirely new simulator written
in the C++ programming language for ease of development and
maintenance with high performance.  {\WRspice} includes a built-in
Verilog parser/simulator for mixed analog/digital simulations.
Verilog is a popular IEEE standard hardware description language used
to model digital logic circuits.

The overall structure of {\WRspice} is shown in Figure 1.1.  The
core of the program is the numerical analysis kernel, which actually
solves the nonlinear circuit equations.  This engine is controlled by
a large block of logic, which in turn is controlled through
interaction with the keyboard and mouse, or under control of a script
file, or even under the control of another program.  Repeated
analyses, or analyses dependent upon the outcome of simulating
variables, can be set up through use of control language scripts.
Input can be entered as description files, or graphically from a
schematic representation.  Output can be plotted on the screen, with
powerful ability to manipulate and transform the data.  The basic user
interface is very similar to a UNIX shell, with automatic command
completion, a history mechanism, and other features known to UNIX
users.

\begin{figure}
\setlength{\unitlength}{1cm}
\begin{center}
\begin{picture}(11.5,7)
\put(1,.5){\framebox(9.5,1){\bf\large Graphical User Interface}}
\put(6.25,2){\framebox(3.5,1){\bf Script Interpreter}}
\put(.5,4){\framebox(10.5,1){\bf\large Control Logic}}
\multiput(2.25,6)(3.5,0){3}{\oval(3.25,1)}
\put(.75,5.5){\makebox(3,1){Schematic Capture}}
\put(4.25,5.5){\makebox(3,1){Simulator Core}}
\put(7.75,5.5){\makebox(3,1){Graphics Processor}}
\put(5.75,1.5){\line(0,1){2.5}}
\put(5.75,2.5){\line(1,0){.5}}
\multiput(2,5)(3.5,0){3}{\line(0,1){.5}}
\end{picture}
\end{center}
\caption{Block diagram of the {\WRspice} interactive circuit simulation tool.}
\end{figure}

{\WRspice} uses the same basic algorithm to solve the nonlinear
circuit equations as the original version of SPICE.  This is a
modified nodal analysis, where a matrix {\bf A} is determined, and a
solution vector {\bf X} is obtained from an excitation vector {\bf B}
by inverting the expression {\bf AX} = {\bf B}.  In {\WRspice}, the
coefficients of {\bf X} are node voltages, and branch currents of
voltage sources and inductors.  The coefficients of {\bf B} are
independent source currents, plus terms which are added during the
linearization process.  The coefficients of {\bf A} are the
small-signal admittance parameters of each device, plus factors which
relate branch currents to other circuit currents.

When the input description is submitted, {\WRspice} sets the
coefficients of the {\bf A} matrix corresponding to each device in the
circuit.  The {\bf B} vector is also defined from knowledge of the
source values.  The solution vector {\bf X} is then obtained through
an in-place LU decomposition of {\bf A}.  If all circuit elements are
linear, then {\bf X} represents the output vector at the initial time
point.  However, in general, the circuits contain nonlinear elements,
and {\bf X} at this point can be considered only an approximation to
the correct solution.  This is because the {\bf A} matrix contains
only first order terms, and approximations of the contributions of
higher order terms have been added to the {\bf B} vector.  Initially,
these ``predictor'' terms represent an educated guess, however after
solving for {\bf X}, one can obtain more accurate estimates.  These
better estimates are then incorporated into a new {\bf B} vector, a
new {\bf A} matrix is obtained, and the LU solution repeated.  This
iterative process continues until the predictor terms converge to a
stable value within an error tolerance.  This process is known as
Newton's method.

A transient analysis solves the equation set at increments of time
over the range specified by the user.  The time increment is
determined by an algorithm which predicts the maximum allowable time
step given past behavior.  Clearly, to simulate as rapidly as
possible, the number of time steps and iterations should be minimized.
There are a number of variables which can be set in {\WRspice} which
affect this behavior, and it is difficult to generalize from one
circuit to another which are the best conditions.  For example, one
can lengthen the average time step, however this will generally
require more iterations at each time step, which may lead to slower
execution time.  Also, one can reduce the number of iterations by
increasing the error tolerance, however this may result in excessive
errors in the output.

Figure 1.2 below shows a flow diagram of the solution algorithm for
transient analysis.

\begin{figure}
\setlength{\unitlength}{1cm}
\begin{center}
\begin{picture}(7,20)
\put(1.5,.5){\framebox(4,1){\bf Done}}
\put(1.5,3){\line(2,1){2}}
\put(1.5,3){\line(2,-1){2}}
\put(5.5,3){\line(-2,1){2}}
\put(5.5,3){\line(-2,-1){2}}
\put(1.5,4.5){\framebox(4,1){\bf time = time + delta}}
\put(1.5,7){\line(2,1){2}}
\put(1.5,7){\line(2,-1){2}}
\put(5.5,7){\line(-2,1){2}}
\put(5.5,7){\line(-2,-1){2}}
\put(1.5,8.5){\framebox(4,1){\bf Solve AX = B}}
\put(1.5,10){\framebox(4,1){\bf LU dcmp A}}
\put(1.5,11.5){\framebox(4,1){\bf Load A and B}}
\put(1.5,13.5){\framebox(4,1){\bf Predict}}
\put(1.5,15){\framebox(4,1){\bf Update Sources}}
\put(1.5,17){\framebox(4,1){\bf time = 0}}
\put(1.5,18.5){\framebox(4,1){\bf Read Input}}
\put(3.5,2){\vector(0,-1){.5}}
\put(3.5,4.5){\vector(0,-1){.5}}
\put(3.5,6){\vector(0,-1){.5}}
\put(3.5,8.5){\vector(0,-1){.5}}
\put(3.5,10){\vector(0,-1){.5}}
\put(3.5,11.5){\vector(0,-1){.5}}
\put(3.5,13.5){\vector(0,-1){1}}
\put(3.5,15){\vector(0,-1){.5}}
\put(3.5,17){\vector(0,-1){1}}
\put(3.5,18.5){\vector(0,-1){.5}}
\put(.5,16.5){\vector(1,0){3}}
\put(.5,3){\line(0,1){13.5}}
\put(.5,3){\line(1,0){1}}
\put(6.5,13){\vector(-1,0){3}}
\put(6.5,7){\line(0,1){6}}
\put(6.5,7){\line(-1,0){1}}
\put(1.5,2){\makebox(4,2){\bf time {\vt >} end?}}
\put(1.5,6){\makebox(4,2){\bf Converged?}}
\put(1.15,3){\makebox(.5,.5){N}}
\put(5.5,7){\makebox(.5,.5){N}}
\end{picture}
\end{center}
\caption{Flow diagram of the algorithm used by {\WRspice}.}
\end{figure}

\index{device library}
Some distributions of {\WRspice} separate the device models from the
program, placing them into a dynamically linked library, which is
loaded at run-time.  In some cases, the user has control of this
library and can add or delete devices at will.  All device-related
information in this manual pertains to the library supplied by
Whiteley Research Inc.  with the {\WRspice} product.  Local system
administrators should be consulted for information on locally-added
devices.

The default device library contains the devices familiar from SPICE2
and SPICE3, including resistors, capacitors, inductors, mutual
inductors, independent and dependent voltage and current sources,
lossy and lossless transmission lines, switches, and the five most
common semiconductor devices:  diodes, BJTs, JFETs, MESFETs, and
MOSFETs, plus Josephson junctions, similar to the RSJ model first
included in SPICE2 by Jewett\cite{jewett}.  The original device models
from SPICE3 are provided, along with a number of third-party models,
particularly for MOS transistors.

{\WRspice} is based on JSPICE3, which in turn was derived from
SPICE3F4, which developed from SPICE2G.6.  While {\WRspice} is being
developed to include new features, it will continue to support those
capabilities and models which remain in extensive use in the SPICE
community.
\index{pedigree}

{\WRspice} is part of the {\XicTools} design system from Whiteley
Research, Inc.  These tools are designed to be modular, yet
interactive.  In particular, {\WRspice} will work seamlessly with the
{\Xic} graphical front-end for schematic capture, if the {\Xic}
program is present.  Otherwise {\WRspice} can be utilized in a
stand-alone mode.  From the {\Xic} graphical editor, {\WRspice} can be
called upon to perform simulations, if {\WRspice} is present.  In this
case, since it is used in a background mode, the {\WRspice} binary can
exist on a remote machine.
\index{Xic}

\index{platforms}
\index{FreeBSD}
The {\XicTools} package has been developed primarily under BSD-4.4 Unix
(FreeBSD), which is the reference operating system.  The tools
have been ported to many other UNIX-type operating systems, including
Linux, Sun Solaris and SunOS 4.1.x, HPUX, and DEC Alpha-OSF.  The tools
are also now available for Microsoft Windows.

Unix/Linux releases of {\WRspice} use the GTK toolkit running on the
X window system for the graphical user interface.  If X is not
available, or if the user so chooses, {\WRspice} will run without
graphics (other than crude ASCII-mode plots).


%S-----------------------------------------------------------------------------
\section{Types of Analysis}
\index{analysis}

% spMain.hlp:spanalysis 012609

Like its predecessors, {\WRspice} supports various forms of nonlinear
dc, nonlinear transient, and linear ac analyses.

\begin{description}
\item{DC Analysis}\\
\index{dc analysis}
\index{analysis!dc}
The dc analysis portion of {\WRspice} determines the dc operating point
of the circuit with inductors shorted and capacitors opened.  A dc
analysis is automatically performed prior to a transient analysis to
determine the transient initial conditions, and prior to an ac
small-signal analysis to determine the linearized, small-signal models
for nonlinear devices.  The dc analysis can also be used to generate
dc transfer curves: a specified independent voltage or current source
is stepped over a user-specified range and the dc output variables are
stored for each sequential source value.  In {\WRspice}, dc analysis
can be combined with other analysis types to generate a family of analysis
results representing data from each point of the dc analysis.  The dc
analysis is not available if Josephson junctions are present in the
circuit.

\item{AC Analysis}\\
\index{ac analysis}
\index{analysis!ac}
The ac small-signal portion of {\WRspice} computes the ac output
variables as a function of frequency.  The program first computes the
dc operating point of the circuit and determines linearized,
small-signal models for all of the nonlinear devices in the circuit.
The resultant linear circuit is then analyzed over a user-specified
range of frequencies.  The desired output of an ac small-signal
analysis is usually a transfer function (voltage gain, transimpedance,
etc).  If the circuit has only one ac input, it is convenient to set
that input to unity and zero phase, so that output variables have the
same value as the transfer function of the output variable with
respect to the input.  The ac analysis can be combined with a dc sweep
so that ac analysis is performed at each point over a range of bias
conditions.  The ac analysis is not available on circuits containing
Josephson junctions.

\item{Transient Analysis}\\
\index{transient analysis}
\index{analysis!transient}
The transient analysis portion of {\WRspice} computes the transient
output variables as a function of time over a user-specified time
interval.  The initial conditions can be automatically determined by a
dc analysis.  All sources which are not time dependent (for example,
power supplies) are set to their dc value.  If Josephson junctions are
present, or if the {\vt uic} option is given, initial conditions are
assumed at the start of analysis rather than the result of the dc
operating point analysis.  With Josephson junctions, all sources
should start with zero output.  Transient analysis can be combined
with a dc sweep so that the transient simulation is performed at each
point over a range of bias conditions.

\item{Transfer Function Analysis}\\
\index{transfer function analysis}
\index{analysis!transfer function}
The transfer analysis portion of {\WRspice} computes the dc or ac
small signal transfer function, input impedance, and output impedance
of a network.  For ac analysis, the dc operating point is
automatically determined through an operating point analysis.  The
transfer analysis can be combined with a dc sweep so that the transfer
function is computed at each point over a range of bias conditions.

\item{Pole-Zero Analysis}\\
\index{pole-zero analysis}
\index{analysis!pole-zero}
The pole-zero analysis portion of {\WRspice} computes the poles and/or
zeros in the small-signal ac transfer function.  The program first
computes the dc operating point and then determines the linearized,
small-signal models for all the nonlinear devices in the circuit. 
This circuit is then used to find the poles and zeros.  Two types of
transfer functions are allowed: one of the form
\begin{quote}
({\it output\_voltage\/})/({\it input\_voltage\/})
\end{quote}
and the other of the form
\begin{quote}\it
(output\_voltage)/(input\_current).
\end{quote}
These two types of transfer functions cover all the cases and one can
find the poles/zeros of functions like input/output impedance and
voltage gain.  The pole-zero analysis works with resistors,
capacitors, inductors, linear-controlled sources, independent sources,
BJTs, MOSFETs, JFETs and diodes.  Transmission lines and Josephson
junctions are not supported.

\item{Distortion Analysis}\\
\index{distortion analysis}
\index{analysis!distortion}
The distortion analysis portion of {\WRspice} computes steady-state
harmonic and intermodulation products for small input signal
magnitudes.  If signals of a single frequency are specified as the
input to the circuit, the complex values of the second and third
harmonics are determined at every point in the circuit.  If there are
signals of two frequencies input to the circuit, the analysis finds
the complex values of the circuit variables at the sum and difference
of the input frequencies, and at the difference of the smaller
frequency from the second harmonic of the larger frequency.
Distortion analysis can be combined with a dc sweep so that distortion
is analyzed at each point over a range of bias conditions.

Distortion analysis is supported for the following nonlinear devices: 
diodes, bipolar transistors, JFETs, MOS1-4, MESFETs.  All linear
devices are automatically supported by distortion analysis.  If there
are switches present in the circuit, the analysis continues to be
accurate provided the switches do not change state under the small
excitations used for distortion analysis.

\item{Sensitivity Analysis}\\
\index{sensitivity analysis}
\index{analysis!sensitivity}
{\WRspice} will calculate either the DC operating-point sensitivity or
the AC small-signal sensitivity of an output variable with respect to
all circuit variables, including model parameters.  {\WRspice} calculates
the difference in an output variable (either a node voltage or a
branch current) by perturbing each parameter of each device
independently.  Since the method is a numerical approximation, the
results may demonstrate second-order effects in highly sensitive
parameters, or may fail to show very low but non-zero sensitivity. 
Further, since each variable is perturbed by a small fraction of its
value, zero-valued parameters are not analyzed (this has the benefit
of reducing what is usually a very large amount of data).  Sensitivity
analysis can be combined with a dc sweep so that sensitivity can be
analyzed at each point over a range of bias conditions.

\item{Noise Analysis}\\
\index{noise analysis}
\index{analysis!noise}
The noise analysis portion of {\WRspice} performs analysis of
device-generated noise for the given circuit.  When provided with an
input source and an output node, the analysis calculates the noise
contributions of each device (and each noise generator within the
device) to the output node voltage.  It also calculates the level of
input noise from the specified input source to generate the equivalent
output noise.  This is done for every frequency point in a specified
range --- the calculated value of the noise corresponds to the spectral
density of the circuit variable viewed as a stationary Gaussian
stochastic process.  Noise analysis can be combined with a dc sweep
so that noise can be computed at each point over a range of bias
conditions.

After calculating the spectral densities, noise analysis integrates
these values over the specified frequency range to arrive at the total
noise voltage/current (over this frequency range).  This calculated
value corresponds to the variance of the circuit variable viewed as a
stationary Gaussian process.

\item{Operating Range Analysis}\\
\index{operating range analysis}
\index{analysis!operating range}
{\WRspice} has an integrated two-dimensional operating range analysis
capability.  The operating range analysis mode is used in conjunction
with the other analysis types, such as transient or ac.  A suitably
configured source file and circuit description is evaluated over a one
or two dimensional area of parameter space, producing (optionally) an
output file describing the results at each evaluated point, or vectors
giving the minimum and maximum values of the varying parameters for
operation.  Results can be viewed graphically during or after
simulation.

\item{Monte Carlo Analysis}\\
\index{Monte Carlo analysis}
\index{analysis!Monte Carlo}
{\WRspice} has a built-in facility for performing Monte Carlo analysis,
where one or more circuit variables are set according to a random
distribution, and the circuit analyzed for functionality.  The file
format and operation is very similar to operating range analysis.

\item{Automated Looping}\\
\index{analysis!looping}
In {\WRspice}, any analysis can be automatically repeated while
stepping over a one or two dimensional area of parameter space.  Any
circuit parameter may be varied.
\end{description}

% spMain.hlp:convergence 021212

\index{convergence}
Both dc and transient solutions are obtained by an iterative process
which is terminated when both of the following conditions hold:
\begin{enumerate}
\item The nonlinear branch currents converge to within a tolerance of
0.1 percent or 1 picoamp (1.0E-12 Amp), whichever is larger.
\item The node voltages converge to within a tolerance of 0.1 percent or 1
microvolt (1.0E-6 Volt), whichever is larger.
\end{enumerate}

Although the algorithm used in {\WRspice} has been found to be very
reliable, in some cases it will fail to converge to a solution.  When
this failure occurs, the program will terminate the job.

\index{off parameter}
Failure to converge in dc analysis is usually due to an error in
specifying circuit connections, element values, or model parameter
values.  Regenerative switching circuits or circuits with positive
feedback probably will not converge in the dc analysis unless the {\vt off}
option is used for some of the devices in the feedback path, or the
{\vt .nodeset} card is used to force the circuit to converge to the desired
state.

See the section describing operating point analysis (\ref{opline})
for a detailed description of the algorithms and information on
convergence issues.

% spMain.hlp:memory 012609

\index{memory use}
\index{virtual memory use}
{\WRspice} runs can consume quite a bit of virtual memory, and it is
possible to exceed machine limits on many systems.  The main consumer
of memory is the data arrays from simulation runs.  Each point is a
double precision number requiring 8 bytes.  Typically, all nodes and
branch currents are saved, though this can be changed with the {\cb
save} command.  One set of values is retained for each output
increment.  For example, a circuit with 100 saved vectors running {\vt
tran 1p 1n} requires roughly 8 X 100 X 1000 bytes per run.  This is
allocated to the plot structure.  By default, all plots are saved, so
memory usage increases with each run.

The maximum memory that can be used for plot data storage for a single
run is set by the {\et maxdata} variable.  The {\cb Tool Control}
window displays memory statistics, and can be used to keep track of
memory in use.

The vectors are copied when a plot is produced (including iplots),
thus this additional memory must be available for plots to be
displayed.  In addition, iplots with a large number of data points
(more than about 10000) can noticeably slow the simulation run.

The {\cb free} and {\cb destroy} commands can be used to delete
existing plots, making the memory available for other purposes.  The
{\cb rusage} command displays memory usage and memory limits.  Note
that once {\WRspice} obtains memory from the operating system, on many
systems this memory is never returned.  Thus, the {\cb free} command
can make more memory available for {\WRspice}, but not for other
programs which may also be running.

Exceeding virtual memory limits is not in general a fatal error,
depending on when the error occurs.  Plots and iplots allocate all
memory needed at the beginning of the operation, so an out of memory
condition will usually abort the operation and return the command
prompt.  It is possible, though, for further errors to be generated by
a memory failure which may cause a segmentation fault.

%S-----------------------------------------------------------------------------
\section{Multi-threading}
\index{threads}
\index{multi-threads}
\label{threads}

% spMain.hlp:spthreads 051016

{\WRspice} can use multi-threading to accelerate certain types of
analyses.  This capability is not present in the original Berkeley
SPICE and most derivatives, and allows {\WRspice} to take advantage of
the presence of multiple processor cores provided in modern
microprocessor chips.  Multi-threading allows different cores to work
on the same simulation job in parallel.

Multi-threading in {\WRspice} is a new feature currently being
incorporated.  It should be considered somewhat experimental at this
point.  Users are encouraged to try it and share their observations
(and report bugs!).  Multi-threading does {\bf not} guarantee a faster
run, as it has its own overhead that must be overcome to reduce
overall run time.  Experience will provide insight into which types of
circuits and analyses benefit from multi-threading and which do not,
and what related threading parmeter values, such of the number of
threads to reserve, give the best results on a given machine.

All supported operating systems provide multi-threading, however
parallel runs require multiple cores or CPUs.  Many Intel processors
provide two instruction queues (threads) per core, so that the number
of available hardware threads is twice the number of cores.

\subsection{Multi-Threaded Loading}

Transient analysis has been cited as an algorithm not suitable for
parallelization.  This is due to the analysis being inherently
sequential; previous results are required before a new calculation can
be performed.  However, there is one point where parallelization can
logically be employed; the load operation.

In dc and transient analysis, the load operation is performed before
each iteration.  During the load operation, the device-specific code
is run using the previous iteration results, and the circuit matrix
and right-hand side (rhs) vectors are loaded with the computed values. 
As the ordering of devices is unimportant, different threads can be
called upon to perform the load operation for different devices, in
parallel.  The matrix and rhs loading operations are engineered to be
atomic, so that different threads do not interfere with one another
while accessing these common resources.

The loading operation dominates the simulation time in many circuits,
particularly when complex device models such as BSIM are used.  These
circuits benefit most from multi-threaded loading.

When enabled, multi-threaded loading is used in dc analysis, including
operating point analysis and when finding the operating point ahead of
ac small-signal analysis, and transient analysis.  By default,
multi-threaded loading is disabled.  It is enabled by setting the {\et
loadthrds} variable to an integer value 1 or larger.  This can be done
in a {\vt .options} line in the SPICE deck, or interactively from the
command line using the {\cb set} command, or graphically from the {\cb
General} page of the {\cb Simulation Options} panel from the {\cb
Tools} menu.

The {\et loadthrds} variable sets the number of helper threads that
will be created to assist the main thread in evaluating device code. 
If 0 or not set, no helper threads are used.

Multiple threads will not necessarily make simulations run faster and
in fact can have the opposite effect.  The latter is sadly true in
Josephson circuits tested thus far.  The problem is that
multi-threading adds a small amount of overhead, and the load function
may be called hundreds of thousands of times in these simulations. 
The model calculation for JJs runs very quickly, and the overhead
becomes significant.  The same is true for other simple devices.  Work
to improve this situation is ongoing.

On the other hand, if there is a lot of computation in the device
model, this will dominate the overhead and we see shorter load times. 
This is true for BSIM MOS models, in circuits with more than about 20
transistors.  Such simulations can run 2--3 times faster than a single
thread.  One should experiment with the value of the {\et loadthrds}
variable.  Most likely for best performance, the value plus the main
thread should equal the number of available hardware threads, which is
usually twice the number of available CPU cores.

\subsection{Multi-Threaded Looping}

A second potentially profitable use of multiple threads is when
performing parameter sweeps, i.e. performing repeated simulations of a
circuit while varying one or more parameters.  These simulations can
be done in any order, as long as the computed results are saved in a
well-defined sequence.  Thus, multiple threads can be called upon to
run the simulations concurrently.

In {\WRspice} there are several ways to initiate this type of
repeated analysis.

\begin{description}
\item{chained dc analysis}\\
Most analysis specifications in {\WRspice} can be followed by a dc
sweep specification.  In {\WRspice}, a ``dc sweep'' is a one or
two-dimensional sweep of {\bf any} ciruit paramter, which is far more
powerful than the original SPICE dc sweep which allowed only source
outputs to be varied.  In this ``chained dc'' analysis, the basic
analysis is performed at each point in parameter space of the sweep. 
The result will be a family of multi-dimensional vectors, one
dimension per parameter set.  Multi-threading is supported in this
type of analysis.

\item{the {\cb sweep} command}\\
The {\cb sweep} command is an interactive command that automatically
sets one or two shell variables to points in a range, and initiates an
arbitrary analysis at each point.  At each point, a circuit object is
created from the shell-expanded SPICE input, which will reflect the
state of the shell variables.  The specified analysis is then
performed.

Unlike the chained dc analysis, the sweep can be run over any command,
in particular a user's script.  However, internally the command runs
at the shell level and has a lot of overhead, so the chained dc
analysis would be preferable for speed when possible.  At present, the
{\cb sweep} command is not multi-threaded.

\item{Monte-Carlo analysis}\\
In Monte-Carlo analysis, repeated simulations are performed using a
circuit object generated for each trial, where parameter values have
been randomly generated according to a probability distribution.  The
simulation run is analyzed by pass/fail logic, and only this result is
typically saved.  At present, Monte Carlo analysis is not
multi-threaded. 
\end{description}

As mentioned, at present only the chained-dc analysis can be
multi-threaded.  This is accomplished by setting the {\et loopthrds}
variable to a positive integer.  This can be done in a {\vt .options}
line in the SPICE deck, or interactively from the command line using
the {\cb set} command, or graphically from the {\cb General} page of
the {\cb Simulation Options} panel from the {\cb Tools} menu.

Multiple threads will be used automatically in a chained dc analysis
if:

\begin{enumerate}
\item{The {\et loopthrds} variable is set to an integer 1 or larger. 
This option variable indicates the number of ``helper'' threads to
use.  It can be set to an integer in the range 0 through 31, with 0
being the same as not set (single threading).  The ``best'' value can
be found experimentally, but the value plus the main thread probably
equals twice the number of available CPU cores.}

\item{The analysis specification supports multi-threading.  Presently
the following analyses can be multi-threaded:
\begin{quote}
{\cb tran}, without scrolling, segmenting, and with the {\et nousertp}
mode not set.\\
{\cb ac}\\
{\cb tf}
\end{quote}}
\end{enumerate}

Multi-threading in the {\cb sweep} command and Monte Carlo analysis is
not yet available, but will be provided (it is hoped) in a future
release.  These analyses require a rebuild of the circuit object for
each trial, requiring that the entire input parser be thread safe. 
This is because shell variables are used to pass parameters, requiring
a re-parse of the circuit deck to create a modified internal circuit
representation.  In chained dc analysis, the same circuit object is
re-used multiple times. 

The {\et loopthrds} and {\et loadthrds} can be used together.  One
should experiment to find the fastest settings.


%S-----------------------------------------------------------------------------
\section{Program Control}

% spMain.hlp:spcontrol 012609

{\WRspice} is intended for use as an interactive tool, though various
batch-mode features are supported.  Circuit input is provided in the form
of files which are loaded into {\WRspice}.  These files can be generated
by the user with a text editor, or be generated by a graphical editor
program such as {\Xic}.  Once loaded into {\WRspice}, a circuit is subject
to the many types of analysis and post-processing operations available
through {\WRspice} commands.  These commands can be given interactively
through the text-mode interface provided by {\WRspice}, or in many cases
through graphical operations.

\index{text-mode interface}
The most common way directives are provided to {\WRspice} is through
the text-mode command line interface.  The command line interface
behaves very much like a UNIX shell, through which commands are
entered, variables set, and output is printed.  The shell provides
most of the mechanisms familiar from UNIX shells, including aliasing,
history substitution, and command completion.

The command shell is normally established on the input terminal or
terminal emulation window from which {\WRspice} was executed. 
{\WRspice} takes control of this terminal, that is, all input typed
will be directed to {\WRspice}, however the operating system job
control commands can be used to place {\WRspice} in the background.

The {\WRspice} shell provides a command language, which enables
scripts containing commands to be executed.  Writing scripts enables
automation of repetitive or complicated tasks.  Control commands can be
added to circuit files, and in fact a unified input processing system
handles both type of input.  Input files are loaded into {\WRspice} with
the {\cb source} command.  The ``{\vt source}'' is in fact optional.
If the file name does not conflict with the name of a {\WRspice} command,
simply typing the name of the file will perform the {\cb source}
operation.

\index{tool control window}
When graphics is available, {\WRspice} provides a small {\cb Tool
Control} window which contains menus.  The menus contain buttons
which in turn bring up graphical tools which control most of
{\WRspice}.  All of the operations of these tools have analogous
command line commands, though many users find the graphical interface
preferable.

\index{help system}
{\WRspice} contains a complete HTML-based help system, available with
the {\et help} command.  The help windows provide an extensively
cross-linked reference on the various commands and features.  In addition,
the help windows can be used to view arbitrary HTML content on the Internet
or on the user's local machine.


%S-----------------------------------------------------------------------------
\section{Post-Processing and Run Control}

% spMain.hlp:sppost 012609

\index{plotting}
{\WRspice} in interactive mode provides a powerful plotting capability
for simulation output.  Plots can be generated on the fly while
simulating, or after simulation is complete.  The command language
provides interactive data manipulation and generation capability on
output prior to plotting.  Any number of plots can be shown on-screen
at a given time, and traces can be copied between plot windows via
mouse operations for easy comparison.

\index{tracing}
A {\cb trace} command allows the value of expressions involving
circuit variables to be printed as simulation progresses.  Simulation
can be paused by typing the interrupt character ({\kb Ctrl-C}), and
can be resumed later.  Simulation can also be paused after a certain
number of data points, or when a logical expression involving circuit
variables becomes true.

\index{Verilog}
The Verilog capability can be used to provide automata for control and
monitoring of a circuit during simulation.  Verilog modules are defined
within the circuit description, and are evaluated as simulation (transient
analysis only) progresses.  This is clearly useful for mixed analog/digital
systems, but has additional utility for implementing event or error
counters, etc., for output statistical analysis.

\index{measurement}
{\WRspice} provides a measurement capability for providing timing or
other information from a circuit simulation.  Any number of
measurements can be included in a circuit description.  This can be
particularly useful in optimization scripts.

\index{shell}
\index{scripts}
All of this capability is tied together in the {\WRspice} shell, which
provides command processing in interactive mode, but also provides a
scripting capability.  Scripts can be written to automate complicated
analyses and data manipulation.  All circuit output data, device and
circuit parameters, and shell variables and vectors are available in
a rich programming environment.


%S-----------------------------------------------------------------------------
\section{Introduction to Interactive Simulation}

% spMain.hlp:spintr 012609

\index{interactive simulation}
{\WRspice} is an interactive circuit simulation program.  One can find
details about preparing {\WRspice} input files in Chapter
\ref{inputformat} --- this section assumes some familiarity with this
syntax, which is basically that of SPICE2.  This section is intended
to be a quick introduction to the use of {\WRspice}, and its
capabilities.  The remaining chapters provide details and in-depth
explanations of the various modes, functions, and features.

\index{Xic}
If {\Xic} is being run, circuits can be entered graphically, making
the command line interface described here somewhat unnecessary (there
are users, however, who prefer the command line interface).  However,
in order to use the full spectrum of capabilities, the command line
interface is required.

To start {\WRspice}, one can type
\begin{quote}\vt
wrspice {\it input\_file}
\end{quote}
where {\it input\_file} is the name of the {\WRspice} circuit description
file to run.  Alternately, one can simply type
\begin{quote}\vt
wrspice
\end{quote}
in which case {\WRspice} will start up without loading a circuit.  A new
circuit description file can be loaded into {\WRspice} by typing the
command
\begin{quote}\vt
source {\it input\_file}
\end{quote}
\index{source command}
\index{Circuits tool}
\index{current circuit}
\index{setcirc command}
If the name {\it input\_file} is different from any internal or
external {\WRspice} commands, the {\cb source} command can be
eliminated, and the {\WRspice} input file is loaded simply by typing
the file name at the command prompt.  The file is parsed into an
internal circuit representation, which is held in memory until
explicitly deleted.  The list of circuits is shown in the panel
brought up by the {\cb Circuits} button in the {\cb Tools} menu of the
{\cb Tool Control} window.  One can switch the ``current circuit''
with the {\cb setcirc} command.

When {\WRspice} starts, it normally displays a {\cb Tool Control}
window containing command menus.  The menu buttons bring up panels
which control and display information.  Most of the typed commands
have analogues within the display panels.  These panels can be
arranged on the screen, and the configuration saved, so that when
{\WRspice} is started subsequently, the user's screen arrangement will
be presented.

In addition, {\WRspice} ``takes over'' the text window from which it
was launched.  The command interface is very much like a shell, and in
fact it can be configured to run operating system commands in a manner
very similar to the C-shell.

\index{run command}
If there are any analysis lines in the input file and the user wishes
to run the analyses as given there, one simply enters
\begin{quote}\vt
run
\end{quote}
{\WRspice} will run the requested analyses and will prompt the user again
when finished and the output data are available.  If the user wishes
to perform an analysis that is not specified by a line in the input
file, one can type the analysis line just as it would appear in the input file,
without the dot.  For example, the command
\begin{quote}\vt
ac lin 20 0.99 1.01
\end{quote}
will initiate an ac analysis with 20 frequency values between 0.99 and 1.01.

After the analysis is complete and the {\WRspice} prompt is displayed,
the values of the nodes are available. Similarly, one can load the
results from previous {\WRspice} sessions using the {\cb load} command.  In
either case, to plot the voltage on nodes 4 and 5, for example, one
could then issue the command
\begin{quote}\vt
plot v(4) v(5).
\end{quote}
To display a list of the circuit variables available for plotting,
type {\vt display} at the command prompt.  The output data items
displayed are vectors, with a length generally equal to the number of
analysis or output points in the simulation.

\index{plot command}
To plot vectors with the {\cb plot} package, one types
\begin{quote}\vt
plot {\it varlist}
\end{quote}
where {\it varlist} is a list of outputs (such as {\vt v(3)}) or
expressions (such as {\vt v(3)*time}).  {\WRspice} will plot a graph of
the outputs on the screen.  When finished plotting, {\WRspice} will
issue a prompt.  Under windowing systems such as X, the plot will be
drawn in a newly created window somewhere on the screen.  This window
will remain open until explicitly dismissed by the user, however the
execution returns to {\WRspice} immediately, so that any number of
plots can be on-screen simultaneously.

One can also specify combinations of outputs and functions of them, as in
\begin{quote}\vt
plot v(1) + 2 * v(2)
\end{quote}
or
\begin{quote}\vt
plot log(v(1)) sin(cos(v(2))).
\end{quote}
\index{vectors}
Notice that the vector name {\vt v(1)} is not a function, but rather
denotes the voltage at the node named 1.  One can use most algebraic
functions, including trig functions, {\vt log} - (base 10), {\vt
ln} - (base e), and functions such as {\vt mag}, the magnitude of
the complex number, {\vt phase}, the phase, {\vt real}, the real
part, and {\vt imag}, the imaginary part.  These all operate on real
or complex values.  A complete list of functions and operations
available can be found in \ref{vectors}.  Generally, any command which
expects a vector as an argument will accept an expression.

The notation
\begin{quote}\vt
plot {\it something} vs {\it something\_else}
\end{quote}
means to plot {\it something} with {\it something\_else} on the
X-axis.

The plot style can be modified through buttons and features found on
the plot window.  These and other features can have default behavior
changed through setting of shell variables.  Shell variables are set
with the {\cb set} command from the command line, and any alphanumeric
variable can be set to a value or a string.  There are a number of
such variables that are predefined to affect plotting.  These can also
be altered graphically from the panel brought up by the {\cb Plot
Opts} button in the {\cb Tools} menu.  The panel brought up by the
{\cb Variables} button in the {\cb Tools} menu shows a listing of the
shell variables currently set.

For example, one can modify the {\cb plot} command to plot a subset of the
data available.  The command
\begin{quote}\vt
set ylimit = "1 2"\\
plot v(1) v(2)
\end{quote}
will plot the two vectors when the values are between 1 and 2, and
\begin{quote}\vt
set xlimit = "1 2"\\
plot v(1) v(2)
\end{quote}
will plot them when the scale (time or frequency) is between 1 and 2.
The variables will remain set until they are unset, using
\begin{quote}\vt
unset xlimit ylimit
\end{quote}
or the corresponding buttons in the {\cb Plot Options} panel are made
inactive.

The command
\begin{quote}\vt
set xcompress 5\\
plot v(1) v(2)
\end{quote}
plots only every fifth point, and
\begin{quote}\vt
unset xcompress\\
set xindices 20 30\\
plot v(1) v(2)
\end{quote}
plots the values between the 20th time point and the 30th.  Any of
these variables may be used together, and they are also available in
the {\cb asciiplot} command (which produces an ASCII representation for
use with text-only printers).

\index{let command}
\index{set command}
Typing {\cb let} without arguments is synonymous with the {\cb display}
command.  The {\cb let} command is different from the {\cb set}
command, which sets non-vector shell variables, which may control various
aspects of {\WRspice} operation.  The {\cb let} command is used to assign
a new vector, for example
\begin{quote}\vt
let aa = v(1)
\end{quote}
\index{Vectors tool}
will assign a new vector {\vt aa} with all components equal to {\vt v(1)}.
If no arguments are given, a listing of output vectors from the most recent
simulation is shown.  This listing is also shown in the panel brought up
by the {\cb Vectors} button in the {\cb Tools} menu.

\index{print command}
One can print the values of vectors with the {\cb print} command:
\begin{quote}\vt
print time
\end{quote}
The command
\begin{quote}\vt
print all
\end{quote}
will print the values of all the data available.  Incidentally, one
can also use the keyword {\vt all} with any of the other commands that
take vector names, like {\cb plot}.  There are also alias and history
mechanisms available (see \ref{shell} for details), and a {\cb shell}
command, which passes its arguments to the operating system shell, or
starts a subshell.

\index{rawfile}
If the user wishes to save the output values in a data file known as a
rawfile, one can then type
\begin{quote}\vt
write {\it filename} v(4) v(5)
\end{quote}
to put the values of {\vt v(4)}, and {\vt v(5)} into {\it
filename\/}.  If the user wishes to save everything, one can type
\begin{quote}\vt
write {\it filename}.
\end{quote}

There are also many commands for tracing the analysis --- one can
print the values at a node for each time point or cause {\WRspice} to
stop whenever a value gets to a certain point.  Descriptions of the
commands {\cb stop}, {\cb trace}, and {\cb step} can be found in
\ref{simcmds}.  A listing of these commands that are currently in
force is available in the panel brought up with the {\cb Trace} button
in the {\cb Tools} menu.

\index{edit command}
After the user is done with the values obtained from the simulation
run, one can change the circuit and re-run the analysis.  If it is
desired to edit the circuit itself, one can use the command {\cb edit}
--- it will bring up an internal text editor (or a favorite external
editor) and allow changes to the circuit in whatever way is necessary,
and then when the editor is exited, {\WRspice} can re-load the circuit
and be ready to run it again.  Under UNIX with X windows, a default
internal editor is provided.  This editor is also available as the
``{\vt xeditor}'' command from the UNIX shell.  Also, one can give
another analysis ({\cb ac}, {\cb dc}, {\cb tran}, ...) command after
the first one completes.  If the analysis is not finished, i.e.  the
user typed an interrupt ({\kb Ctrl-C}), or the run stopped under the
{\cb stop} command, then one must type {\cb reset} in order to re-run
an analysis from the beginning.

\index{plots}
Each separate analysis that is performed will create one or more sets
of values.  Such a set of values is called a plot --- if several
analyses have been performed, and the user wishes to switch from the
results of one to the results of another, the {\cb setplot} command will
inform the user as to which analysis results are available and let the
user choose one.  The plots are displayed in the panel brought up by
the {\cb Plots} button in the {\cb Tools} menu.

\index{Ctrl-D}
To see what other commands are available, skip to Chapter
\ref{commands}, or type {\kb Ctrl-D} in {\WRspice}.  For
information about a particular command, type {\vt help} {\it
command\/}, where {\it command} is one of those listed by {\kb
Ctrl-D}.  This introduction should be enough to get started.

\index{example run}
Here is a sample {\WRspice} run:
\begin{quote} {\raggedright\vt
 csh\% wrspice\\
 wrspice 10 -> source xtal.in\\
 Circuit: crystal filter\\

 wrspice 11 -> listing\\
 \begin{quote}
  {\rm (listing of the circuit is printed)}
 \end{quote}

 wrspice 12 -> run\\
 wrspice 15 -> display\\
 Here are the vectors currently active:\\

 Title: crystal filter\\
 Plotname: AC analysis curves.\\
 Date: Thu Sep 26 12:16:34 PDT 1985\\
 \begin{verbatim}
     FREQ    : frequency (complex, 20 long) [scale]
     V(4)    : voltage (complex, 20 long)
     V(6)    : voltage (complex, 20 long)
     V(5)    : voltage (complex, 20 long)
 \end{verbatim}
 \begin{quote}
  {\rm (and so on...)}
 \end{quote}

 wrspice 16 -> plot v(4)\\
 \begin{quote}
  {\rm (plot takes place)}
 \end{quote}

 wrspice 17 -> write outfile freq v(4)\\
 wrspice 18 -> ac lin 30 1 2\\
 wrspice 19 -> display\\
 Here are the vectors currently active:\\

 Title: crystal filter\\
 Plotname: AC analysis curves.\\
 Date: Thu Sep 26 12:16:34 PDT 1985\\

 \begin{verbatim}
     FREQ    : frequency (complex, 30 long) [scale]
     V(4)    : voltage (complex, 30 long)
     V(6)    : voltage (complex, 30 long)
     V(5)    : voltage (complex, 30 long)
 \end{verbatim}
 \begin{quote}
  {\rm (and so on...)}
 \end{quote}

 wrspice 20 -> print v(4) > tempfile\\
 \begin{quote}
  {\rm (print to tempfile takes place)}
 \end{quote}

 wrspice 21 -> shell lpr tempfile\\
 \begin{quote}
  {\rm (a printout is made of the results)}
 \end{quote}

 wrspice 22 -> load testh\\
 Title:  SPICE 3-C raw output test heading\\
 Name:  Transient analysis.\\
 Date:  08/19/84 03:17:11\\

 wrspice 23 -> display\\
 Here are the variables currently active:\\

 Title: SPICE 3-C raw output test heading\\
 Plotname: Transient analysis.\\
 Date: Sun Dec 1 11:18:25 PST 1985\\
 \begin{verbatim}
     TIME    : time (real, 152 long) [scale]
     v(1)    : voltage (real, 152 long)
     v(2)    : voltage (real, 152 long)
     v(3)    : voltage (real, 152 long)
     v(4)    : voltage (real, 152 long)
     v(5)    : voltage (real, 152 long)
 \end{verbatim}

 wrspice 24 -> print v(1)\\
 \begin{quote}
  {\rm (prints v(1) values)}
 \end{quote}

 wrspice 25 -> plot v(1)\\
 \begin{quote}
  {\rm (plot takes place)}
 \end{quote}

 wrspice 26 -> let xxx = log(v(1))\\
 wrspice 27 -> plot xxx\\
 \begin{quote}
  {\rm (plot takes place)}
 \end{quote}

 wrspice 28 -> plot v(1) v(2) v(3) + 1 vs TIME * 2\\
 \begin{quote}
  {\rm (plot takes place)}
 \end{quote}

 wrspice 30 -> asciiplot v(1) v(2) TIME + 2 > File\\
 wrspice 31 -> shell lpr File\\
 \begin{quote}
  {\rm (Pick up ASCII plot ...)}
 \end{quote}

 wrspice 33 -> quit\\
 Warning: the following plot hasn't been saved:\\
         crystal filter, AC analysis curves.\\
 
 Are you sure you want to quit? y\\
 
 csh\%\\
}
\end{quote}

Note that {\WRspice} will issue a warning if there is work in progress
that has not been saved.

