
/*========================================================================*
 *                                                                        *
 *  Distributed by Whiteley Research Inc., Sunnyvale, California, USA     *
 *                       http://wrcad.com                                 *
 *  Copyright (C) 2017 Whiteley Research Inc., all rights reserved.       *
 *  Author: Stephen R. Whiteley, except as indicated.                     *
 *                                                                        *
 *  As fully as possible recognizing licensing terms and conditions       *
 *  imposed by earlier work from which this work was derived, if any,     *
 *  this work is released under the Apache License, Version 2.0 (the      *
 *  "License").  You may not use this file except in compliance with      *
 *  the License, and compliance with inherited licenses which are         *
 *  specified in a sub-header below this one if applicable.  A copy       *
 *  of the License is provided with this distribution, or you may         *
 *  obtain a copy of the License at                                       *
 *                                                                        *
 *        http://www.apache.org/licenses/LICENSE-2.0                      *
 *                                                                        *
 *  See the License for the specific language governing permissions       *
 *  and limitations under the License.                                    *
 *                                                                        *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,      *
 *   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES      *
 *   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-        *
 *   INFRINGEMENT.  IN NO EVENT SHALL WHITELEY RESEARCH INCORPORATED      *
 *   OR STEPHEN R. WHITELEY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER     *
 *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,      *
 *   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE       *
 *   USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                        *
 *========================================================================*
 *               XicTools Integrated Circuit Design System                *
 *                                                                        *
 * WRspice Circuit Simulation and Analysis Tool:  Device Library          *
 *                                                                        *
 *========================================================================*
 $Id:$
 *========================================================================*/

/*
 * Author: 2000 Wladek Grabinski; EKV v2.6 Model Upgrade
 * Author: 1997 Eckhard Brass;    EKV v2.5 Model Implementation
 *     (C) 1990 Regents of the University of California. Spice3 Format
 */

#include <stdio.h>
#include "ekvdefs.h"
#include "noisdefs.h"

#define EKVnextModel      next()
#define EKVnextInstance   next()
#define EKVinstances      inst()
#define EKVname GENname
#define MAX SPMAX
#define NOISEAN sNOISEAN
#define Nintegrate(a, b, c, d) (d)->integrate(a, b, c)
#define NstartFreq JOBac.fstart()

extern void
NevalSrcEKV(double, sEKVmodel*, sEKVinstance*, double*, double*, sCKT*,
    int, int, int, double);

/*
 * EKVnoise (mode, operation, firstModel, ckt, data, OnDens)
 *    This routine names and evaluates all of the noise sources
 *    associated with MOSFET's.  It starts with the model *firstModel and
 *    traverses all of its insts.  It then proceeds to any other models
 *    on the linked list.  The total output noise density generated by
 *    all of the MOSFET's is summed with the variable "OnDens".
 */

int
EKVdev::noise(int mode, int operation, sGENmodel *genmod, sCKT *ckt,
    sNdata *data, double *OnDens)
{
    sEKVmodel *firstModel = static_cast<sEKVmodel*>(genmod);
    sEKVinstance *inst;
    sEKVmodel *model;

    char ekvname[N_MXVLNTH];
    double leff;
    double weff;
//    double coxSquared;
    double tempOnoise;
    double tempInoise;
    double noizDens[EKVNSRCS];
    double lnNdens[EKVNSRCS];
    int i;
    double temp;

    /* define the names of the noise sources */

    static const char *EKVnNames[EKVNSRCS] = {       /* Note that we have to keep the order */
        "_rd",              /* noise due to rd */        /* consistent with the index definitions */
        "_rs",              /* noise due to rs */        /* in EKVdefs.h */
        "_id",              /* noise due to id */
        "_1overf",          /* flicker (1/f) noise */
        ""                  /* total transistor noise */
    };

    for (model=firstModel; model != NULL; model=model->EKVnextModel) {

//        coxSquared = model->EKVcox * model->EKVcox;

        for (inst=model->EKVinstances; inst != NULL; inst=inst->EKVnextInstance) {

            temp=inst->EKVtemp;

            switch (operation) {

            case N_OPEN:

                /* see if we have to to produce a summary report */
                /* if so, name all the noise generators */

                if (((NOISEAN*)ckt->CKTcurJob)->NStpsSm != 0) {
                    switch (mode) {

                    case N_DENS:
                        for (i=0; i < EKVNSRCS; i++) {
                            (void)snprintf(ekvname, sizeof(ekvname),"onoise_%s%s",
                                (char*) inst->EKVname,EKVnNames[i]);

/*
                            data->namelist = (IFuid *)trealloc((char *)data->namelist,(data->numPlots
                                + 1)*sizeof(IFuid));
                            if (!data->namelist) return(E_NOMEM);
                            (*(SPfrontEnd->IFnewUid))(ckt,
                                &(data->namelist[data->numPlots++]),
                                (IFuid)NULL,ekvname,UID_OTHER,(GENERIC **)NULL);
*/
                            /* we've added one more plot */
                Realloc(&data->namelist, data->numPlots+1,
                    data->numPlots);
                ckt->newUid(&data->namelist[data->numPlots++],
                    0, ekvname, UID_OTHER);


                        }
                        break;

                    case INT_NOIZ:
                        for (i=0; i < EKVNSRCS; i++) {
                            (void)snprintf(ekvname, sizeof(ekvname),"onoise_total_%s%s",
                                (char*) inst->EKVname,EKVnNames[i]);

/*
                            data->namelist = (IFuid *)trealloc((char *)data->namelist,(data->numPlots
                                + 1)*sizeof(IFuid));
                            if (!data->namelist) return(E_NOMEM);
                            (*(SPfrontEnd->IFnewUid))(ckt,
                                &(data->namelist[data->numPlots++]),
                                (IFuid)NULL,ekvname,UID_OTHER,(GENERIC **)NULL);
*/
                            /* we've added one more plot */
                Realloc(&data->namelist, data->numPlots+2,
                    data->numPlots);
                ckt->newUid(&data->namelist[data->numPlots++],
                    0, ekvname, UID_OTHER);


                            (void)snprintf(ekvname, sizeof(ekvname),"inoise_total_%s%s",
                                (char*) inst->EKVname,EKVnNames[i]);


/*
                            data->namelist = (IFuid *)trealloc((char *)data->namelist,(data->numPlots
                                + 1)*sizeof(IFuid));
                            if (!data->namelist) return(E_NOMEM);
                            (*(SPfrontEnd->IFnewUid))(ckt,
                                &(data->namelist[data->numPlots++]),
                                (IFuid)NULL,ekvname,UID_OTHER,(GENERIC **)NULL);
*/
                            /* we've added one more plot */
                ckt->newUid(&data->namelist[data->numPlots++],
                    0, ekvname, UID_OTHER);


                        }
                        break;
                    }
                }
                break;

            case N_CALC:
                switch (mode) {

                case N_DENS:
                    leff = inst->EKVl+model->EKVdl;
                    weff = inst->EKVw+model->EKVdw;

                    NevalSrcEKV(temp,model,inst,&noizDens[EKVRDNOIZ],&lnNdens[EKVRDNOIZ],
                        ckt,THERMNOISE,inst->EKVdNodePrime,inst->EKVdNode,
                        inst->EKVdrainConductance);

                    NevalSrcEKV(temp,model,inst,&noizDens[EKVRSNOIZ],&lnNdens[EKVRSNOIZ],
                        ckt,THERMNOISE,inst->EKVsNodePrime,inst->EKVsNode,
                        inst->EKVsourceConductance);

                    NevalSrcEKV(temp,model,inst,&noizDens[EKVIDNOIZ],&lnNdens[EKVIDNOIZ],
                        ckt,THERMNOISE,inst->EKVdNodePrime,inst->EKVsNodePrime,
                        (2.0/3.0 * FABS(inst->EKVgm)));

                    NevalSrcEKV(temp,model,inst,&noizDens[EKVFLNOIZ],(double*)NULL,ckt,
                        N_GAIN,inst->EKVdNodePrime, inst->EKVsNodePrime,
                        (double)0.0);

                    if (model->EKVnlevel==1)
                        noizDens[EKVFLNOIZ] *= model->EKVfNcoef * 
                            exp(model->EKVfNexp *
                            log(MAX(FABS(inst->EKVcd),N_MINLOG))) /
                            data->freq / leff / leff / model->EKVcox;
                    else
                        noizDens[EKVFLNOIZ] *= model->EKVfNcoef *
                            model->EKVfNexp * inst->EKVgm * inst->EKVgm
                            / exp(model->EKVfNexp*log(data->freq)) / leff / weff 
                            / model->EKVcox;

                    lnNdens[EKVFLNOIZ] = 
                        log(MAX(noizDens[EKVFLNOIZ],N_MINLOG));

                    noizDens[EKVTOTNOIZ] = noizDens[EKVRDNOIZ] +
                        noizDens[EKVRSNOIZ] +
                        noizDens[EKVIDNOIZ] +
                        noizDens[EKVFLNOIZ];
                    lnNdens[EKVTOTNOIZ] = 
                        log(MAX(noizDens[EKVTOTNOIZ], N_MINLOG));

                    *OnDens += noizDens[EKVTOTNOIZ];

                    if (data->delFreq == 0.0) {

                        /* if we haven't done any previous integration, we need to */
                        /* initialize our "history" variables                      */

                        for (i=0; i < EKVNSRCS; i++) {
                            inst->EKVnVar[LNLSTDENS][i] = lnNdens[i];
                        }

                        /* clear out our integration variables if it's the first pass */

                        if (data->freq == ((NOISEAN*)ckt->CKTcurJob)->NstartFreq) {
                            for (i=0; i < EKVNSRCS; i++) {
                                inst->EKVnVar[OUTNOIZ][i] = 0.0;
                                inst->EKVnVar[INNOIZ][i] = 0.0;
                            }
                        }
                    } else {   /* data->delFreq != 0.0 (we have to integrate) */
                        for (i=0; i < EKVNSRCS; i++) {
                            if (i != EKVTOTNOIZ) {
                                tempOnoise = Nintegrate(noizDens[i], lnNdens[i],
                                    inst->EKVnVar[LNLSTDENS][i], data);
                                tempInoise = Nintegrate(noizDens[i] * data->GainSqInv ,
                                    lnNdens[i] + data->lnGainInv,
                                    inst->EKVnVar[LNLSTDENS][i] + data->lnGainInv,
                                    data);
                                inst->EKVnVar[LNLSTDENS][i] = lnNdens[i];
                                data->outNoiz += tempOnoise;
                                data->inNoise += tempInoise;
                                if (((NOISEAN*)ckt->CKTcurJob)->NStpsSm != 0) {
/* code folded from here */
    inst->EKVnVar[OUTNOIZ][i] += tempOnoise;
    inst->EKVnVar[OUTNOIZ][EKVTOTNOIZ] += tempOnoise;
    inst->EKVnVar[INNOIZ][i] += tempInoise;
    inst->EKVnVar[INNOIZ][EKVTOTNOIZ] += tempInoise;
/* unfolding */
                                }
                            }
                        }
                    }
                    if (data->prtSummary) {
                        for (i=0; i < EKVNSRCS; i++) {     /* print a summary report */
                            data->outpVector[data->outNumber++] = noizDens[i];
                        }
                    }
                    break;

                case INT_NOIZ:        /* already calculated, just output */
                    if (((NOISEAN*)ckt->CKTcurJob)->NStpsSm != 0) {
                        for (i=0; i < EKVNSRCS; i++) {
                            data->outpVector[data->outNumber++] = inst->EKVnVar[OUTNOIZ][i];
                            data->outpVector[data->outNumber++] = inst->EKVnVar[INNOIZ][i];
                        }
                    }    /* if */
                    break;
                }    /* switch (mode) */
                break;

            case N_CLOSE:
                return (OK);         /* do nothing, the main calling routine will close */
                break;               /* the plots */
            }    /* switch (operation) */
        }    /* for inst */
    }    /* for model */

    return(OK);
}

