
/*========================================================================*
 *                                                                        *
 *  Distributed by Whiteley Research Inc., Sunnyvale, California, USA     *
 *                       http://wrcad.com                                 *
 *  Copyright (C) 2017 Whiteley Research Inc., all rights reserved.       *
 *  Author: Stephen R. Whiteley, except as indicated.                     *
 *                                                                        *
 *  As fully as possible recognizing licensing terms and conditions       *
 *  imposed by earlier work from which this work was derived, if any,     *
 *  this work is released under the Apache License, Version 2.0 (the      *
 *  "License").  You may not use this file except in compliance with      *
 *  the License, and compliance with inherited licenses which are         *
 *  specified in a sub-header below this one if applicable.  A copy       *
 *  of the License is provided with this distribution, or you may         *
 *  obtain a copy of the License at                                       *
 *                                                                        *
 *        http://www.apache.org/licenses/LICENSE-2.0                      *
 *                                                                        *
 *  See the License for the specific language governing permissions       *
 *  and limitations under the License.                                    *
 *                                                                        *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,      *
 *   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES      *
 *   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-        *
 *   INFRINGEMENT.  IN NO EVENT SHALL WHITELEY RESEARCH INCORPORATED      *
 *   OR STEPHEN R. WHITELEY BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER     *
 *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,      *
 *   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE       *
 *   USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
 *                                                                        *
 *========================================================================*
 *               XicTools Integrated Circuit Design System                *
 *                                                                        *
 * WRspice Circuit Simulation and Analysis Tool:  Device Library          *
 *                                                                        *
 *========================================================================*
 $Id:$
 *========================================================================*/

/**********
Copyright 1990 Regents of the University of California.  All rights reserved.
Author: 1995 Gary W. Ng and Min-Chie Jeng.
* Revision 3.2 1998/6/16  18:00:00  Weidong 
* BSIM3v3.2 release
**********/

#include <stdio.h>
#include "b3defs.h"
#include "noisdefs.h"

//    This routine names and evaluates all of the noise sources
//    associated with MOSFET's.  It starts with the model *firstModel and
//    traverses all of its insts.  It then proceeds to any other models
//    on the linked list.  The total output noise density generated by
//    all of the MOSFET's is summed with the variable "OnDens".

// Channel thermal and flicker noises are calculated based on the value
// of model->BSIM3noiMod.
// If model->BSIM3noiMod = 1,
//    Channel thermal noise = SPICE2 model
//    Flicker noise         = SPICE2 model
// If model->BSIM3noiMod = 2,
//    Channel thermal noise = BSIM3 model
//    Flicker noise         = BSIM3 model
// If model->BSIM3noiMod = 3,
//    Channel thermal noise = SPICE2 model
//    Flicker noise         = BSIM3 model
// If model->BSIM3noiMod = 4,
//    Channel thermal noise = BSIM3 model
//    Flicker noise         = SPICE2 model


static double
StrongInversionNoiseEval(double vgs, double vds, sB3model *model,
    sB3instance *inst, double freq, double temp)
{
    bsim3SizeDependParam *pParam;
    double cd, esat, DelClm, EffFreq, N0, Nl, Vgst;
    double T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, Ssi;

    pParam = inst->pParam;
    cd = fabs(inst->B3cd) * inst->B3m;  // SRW
    if (vds > inst->B3vdsat) {
        esat = 2.0 * pParam->B3vsattemp / inst->B3ueff;
        T0 = ((((vds - inst->B3vdsat) / pParam->B3litl) + model->B3em) / esat);
        DelClm = pParam->B3litl * log (SPMAX(T0, N_MINLOG));
    }
    else 
        DelClm = 0.0;
    EffFreq = pow(freq, model->B3ef);
    T1 = CHARGE * CHARGE * 8.62e-5 * cd * temp * inst->B3ueff;
    T2 = 1.0e8 * EffFreq * model->B3cox * pParam->B3leff * pParam->B3leff;
    Vgst = vgs - inst->B3von;
    N0 = model->B3cox * Vgst / CHARGE;
    if (N0 < 0.0)
        N0 = 0.0;
    Nl = model->B3cox * (Vgst - SPMIN(vds, inst->B3vdsat)) / CHARGE;
    if (Nl < 0.0)
        Nl = 0.0;

    T3 = model->B3oxideTrapDensityA
        * log(SPMAX(((N0 + 2.0e14) / (Nl + 2.0e14)), N_MINLOG));
    T4 = model->B3oxideTrapDensityB * (N0 - Nl);
    T5 = model->B3oxideTrapDensityC * 0.5 * (N0 * N0 - Nl * Nl);

    T6 = 8.62e-5 * temp * cd * cd;
    T7 = 1.0e8 * EffFreq * pParam->B3leff
        * pParam->B3leff * pParam->B3weff * inst->B3m; // SRW
    T8 = model->B3oxideTrapDensityA + model->B3oxideTrapDensityB * Nl
        + model->B3oxideTrapDensityC * Nl * Nl;
    T9 = (Nl + 2.0e14) * (Nl + 2.0e14);

    Ssi = T1 / T2 * (T3 + T4 + T5) + T6 / T7 * DelClm * T8 / T9;
    return (Ssi);
}


int
B3dev::noise(int mode, int operation, sGENmodel *genmod, sCKT *ckt,
    sNdata *data, double *OnDens)
{
    bsim3SizeDependParam *pParam;
    char b3name[N_MXVLNTH];
    double tempOnoise;
    double tempInoise;
    double noizDens[B3NSRCS];
    double lnNdens[B3NSRCS];

    double vgs, vds, Slimit;
    double T1, T10, T11;
    double Ssi, Swi;

    int i;

    // define the names of the noise sources
    static const char *B3nNames[B3NSRCS] = {
        // Note that we have to keep the order consistent with the index
        // definitions in b3defs.h
        ".rd",          // noise due to rd
        ".rs",          // noise due to rs
        ".id",          // noise due to id
        ".1overf",      // flicker (1/f) noise
        ""              // total transistor noise
    };

    sB3model *model = static_cast<sB3model*>(genmod);
    for ( ; model; model = model->next()) {

        sB3instance *inst;
        for (inst = model->inst(); inst; inst = inst->next()) {

            pParam = inst->pParam;
            switch (operation) {
            case N_OPEN:
                // see if we have to to produce a summary report
                // if so, name all the noise generators

                if (((sNOISEAN*)ckt->CKTcurJob)->NStpsSm != 0) {
                    switch (mode) {
                    case N_DENS:
                        for (i = 0; i < B3NSRCS; i++) {
                            (void) snprintf(b3name, sizeof(b3name),
                                "onoise.%s%s", (char*)inst->GENname,
                                B3nNames[i]);
                            Realloc(&data->namelist, data->numPlots+1,
                                data->numPlots);
                            ckt->newUid(&data->namelist[data->numPlots++],
                                0, b3name, UID_OTHER);
                            // we've added one more plot
                        }
                        break;
                    case INT_NOIZ:
                        for (i = 0; i < B3NSRCS; i++) {
                            (void) snprintf(b3name, sizeof(b3name),
                                "onoise_total.%s%s", (char*)inst->GENname,
                                B3nNames[i]);
                            Realloc(&data->namelist, data->numPlots+2,
                                data->numPlots);
                            ckt->newUid(&data->namelist[data->numPlots++],
                                0, b3name, UID_OTHER);
                            (void) snprintf(b3name, sizeof(b3name),
                                "inoise_total.%s%s", (char*)inst->GENname,
                                B3nNames[i]);
                            ckt->newUid(&data->namelist[data->numPlots++],
                                0, b3name, UID_OTHER);
                            // we've added two more plots
                        }
                        break;
                    }
                }
                break;
            case N_CALC:
                switch (mode) {
                case N_DENS:
                    NevalSrc(&noizDens[B3RDNOIZ],
                        &lnNdens[B3RDNOIZ], ckt, THERMNOISE,
                        inst->B3dNodePrime, inst->B3dNode,
                        inst->B3drainConductance * inst->B3m); // SRW

                    NevalSrc(&noizDens[B3RSNOIZ],
                        &lnNdens[B3RSNOIZ], ckt, THERMNOISE,
                        inst->B3sNodePrime, inst->B3sNode,
                        inst->B3sourceConductance * inst->B3m); // SRW

                    switch (model->B3noiMod) {
                    case 1:
                    case 3:
                        NevalSrc(&noizDens[B3IDNOIZ],
                            &lnNdens[B3IDNOIZ], ckt, THERMNOISE,
                            inst->B3dNodePrime, inst->B3sNodePrime,
                            (2.0 / 3.0 * FABS(inst->B3gm + inst->B3gds
                            + inst->B3gmbs) * inst->B3m)); // SRW
                        break;
                    case 2:
                    case 4:
                        NevalSrc(&noizDens[B3IDNOIZ],
                            &lnNdens[B3IDNOIZ], ckt, THERMNOISE,
                            inst->B3dNodePrime, inst->B3sNodePrime,
                           (inst->B3ueff * FABS((inst->B3qinv * inst->B3m)  // SRW
                               / (pParam->B3leff * pParam->B3leff))));
                        break;
                    }
                    NevalSrc(&noizDens[B3FLNOIZ], 0,
                        ckt, N_GAIN, inst->B3dNodePrime,
                        inst->B3sNodePrime, (double) 0.0);

                    switch (model->B3noiMod) {
                    case 1:
                    case 4:
                        noizDens[B3FLNOIZ] *= model->B3kf * exp(model->B3af
                            * log(SPMAX(FABS(inst->B3cd * inst->B3m), N_MINLOG))) // SRW
                            / (pow(data->freq, model->B3ef)
                            * pParam->B3leff * pParam->B3leff
                            * model->B3cox);
                        break;
                    case 2:
                    case 3:
                        vgs = *(ckt->CKTstates[0] + inst->B3vgs);
                        vds = *(ckt->CKTstates[0] + inst->B3vds);
                        if (vds < 0.0) {
                            vds = -vds;
                            vgs = vgs + vds;
                        }
                        if (vgs >= inst->B3von + 0.1) {
                            Ssi = StrongInversionNoiseEval(vgs,
                                vds, model, inst, data->freq,
                                ckt->CKTcurTask->TSKtemp);
                            noizDens[B3FLNOIZ] *= Ssi;
                        }
                        else {
                            pParam = inst->pParam;
                            T10 = model->B3oxideTrapDensityA
                                * 8.62e-5 * ckt->CKTcurTask->TSKtemp;
                            T11 = pParam->B3weff * inst->B3m   // SRW
                                * pParam->B3leff
                                * pow(data->freq, model->B3ef)
                                * 4.0e36;
                            Swi = T10 / T11 * inst->B3cd * inst->B3m  // SRW
                                * inst->B3cd * inst->B3m;  // SRW
                            Slimit = StrongInversionNoiseEval(
                                inst->B3von + 0.1, vds, model,
                                inst, data->freq,
                                ckt->CKTcurTask->TSKtemp);
                            T1 = Swi + Slimit;
                            if (T1 > 0.0)
                                noizDens[B3FLNOIZ] *= (Slimit * Swi) / T1; 
                            else
                                noizDens[B3FLNOIZ] *= 0.0;
                        }
                        break;
                    }

                    lnNdens[B3FLNOIZ] =
                        log(SPMAX(noizDens[B3FLNOIZ], N_MINLOG));

                    noizDens[B3TOTNOIZ] = noizDens[B3RDNOIZ]
                        + noizDens[B3RSNOIZ]
                        + noizDens[B3IDNOIZ]
                        + noizDens[B3FLNOIZ];
                    lnNdens[B3TOTNOIZ] = 
                        log(SPMAX(noizDens[B3TOTNOIZ], N_MINLOG));

                    *OnDens += noizDens[B3TOTNOIZ];

                    if (data->delFreq == 0.0) {
                        // if we haven't done any previous
                        // integration, we need to initialize our
                        // "history" variables.

                        for (i = 0; i < B3NSRCS; i++) {
                            inst->B3nVar[LNLSTDENS][i] = lnNdens[i];
                        }

                        // clear out our integration variables
                        // if it's the first pass
                        if (data->freq ==
                                ((sNOISEAN*)ckt->CKTcurJob)->JOBac.fstart()) {
                            for (i = 0; i < B3NSRCS; i++) {
                                inst->B3nVar[OUTNOIZ][i] = 0.0;
                                inst->B3nVar[INNOIZ][i] = 0.0;
                            }
                        }
                    }
                    else {
                        // data->delFreq != 0.0, we have to integrate.
                        for (i = 0; i < B3NSRCS; i++) {
                            if (i != B3TOTNOIZ) {
                                tempOnoise = data->integrate(noizDens[i],
                                    lnNdens[i], inst->B3nVar[LNLSTDENS][i]);
                                tempInoise = data->integrate(noizDens[i]
                                    * data->GainSqInv, lnNdens[i]
                                    + data->lnGainInv,
                                    inst->B3nVar[LNLSTDENS][i]
                                    + data->lnGainInv);
                                inst->B3nVar[LNLSTDENS][i] = lnNdens[i];
                                data->outNoiz += tempOnoise;
                                data->inNoise += tempInoise;
                                if (((sNOISEAN*)
                                        ckt->CKTcurJob)->NStpsSm != 0) {
                                    inst->B3nVar[OUTNOIZ][i]
                                        += tempOnoise;
                                    inst->B3nVar[OUTNOIZ][B3TOTNOIZ]
                                        += tempOnoise;
                                    inst->B3nVar[INNOIZ][i]
                                        += tempInoise;
                                    inst->B3nVar[INNOIZ][B3TOTNOIZ]
                                        += tempInoise;
                                }
                            }
                        }
                    }
                    if (data->prtSummary) {
                        for (i = 0; i < B3NSRCS; i++) {
                            // print a summary report
                            data->outpVector[data->outNumber++] = noizDens[i];
                        }
                    }
                    break;
                case INT_NOIZ:
                    // already calculated, just output
                    if (((sNOISEAN*)ckt->CKTcurJob)->NStpsSm != 0) {
                        for (i = 0; i < B3NSRCS; i++) {
                            data->outpVector[data->outNumber++]
                                = inst->B3nVar[OUTNOIZ][i];
                            data->outpVector[data->outNumber++]
                                = inst->B3nVar[INNOIZ][i];
                        }
                    }
                    break;
                }
                break;
            case N_CLOSE:
                // do nothing, the main calling routine will close
                return (OK);
                break;   // the plots
            }    // switch (operation)
        }     // for inst
    }    // for model
    return(OK);
}
