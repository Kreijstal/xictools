<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- built-in implicit transforms @SVN_VERSION=1228:1229M@ -->
<!-- this file is saved in local working directory, then downloaded prior any -e xml files -->
<!-- unless flag '-x' is specified -->

<!--
  This is a modified version of .adms.implicit.xml for use with the WRspice
  translation scripts.
  $Id: adms.implicit.xml,v 1.12 2016/05/10 23:49:38 stevew Exp $
-->

<!DOCTYPE admst SYSTEM "admst.dtd">
<admst version="2.3.0" xmlns:admst="http://mot-adms.sourceforge.net/adms/admst.xml">

<admst:variable name="globalmodule"/>
<admst:variable name="globalassignment"/>
<admst:variable name="globalcontribution"/>
<admst:variable name="globalexpression"/>
<admst:variable name="globalopdependent" string="no"/>
<admst:variable name="globalpartitionning"/>
<admst:variable name="globaltreenode"/>

<!-- ---------------------------------------------------------------------- -->
<!--
  Whiteley Research Inc. additions for WRspice support and general
  improvement.
-->

<!--
  The split_expr template will chop up an expression in the form of a
  summation of terms into a list of separate expressions for each
  term.  It does this only at the top level.  The list is returned in
  the $split_expr_list variable.  The $split_expr_neg variable is used
  internally, to keep track of the need to add a unary minus ahead of
  terms that need it.

  For correct initialization, call on adms/datatypename=expression.
-->
<admst:variable name="split_expr_list" datatype="list"/>
<admst:variable name="split_expr_neg" value="no"/>

<admst:template match="split_expr">
  <admst:choose>
    <admst:when test="[datatypename='expression']">
      <admst:variable name="split_expr_list" datatype="list"/>
      <admst:variable name="split_expr_neg" value="no"/>
      <admst:apply-templates select="tree" match="split_expr"/>
    </admst:when>

    <admst:when test="[datatypename='mapply_unary' and name='minus']">
      <admst:variable name="tmpn" value="$split_expr_neg"/>
      <admst:variable name="split_expr_neg" test="[$tmpn='no']" value="yes"/>
      <admst:variable name="split_expr_neg" test="[$tmpn='yes']" value="no"/>
      <admst:apply-templates select="arg1" match="split_expr"/>
      <admst:variable name="split_expr_neg" value="$tmpn"/>
    </admst:when>
    <admst:when test="[datatypename='mapply_binary' and name='addp']">
      <admst:apply-templates select="arg1" match="split_expr"/>
      <admst:apply-templates select="arg2" match="split_expr"/>
    </admst:when>
    <admst:when test="[datatypename='mapply_binary' and name='addm']">
      <admst:apply-templates select="arg1" match="split_expr"/>
      <admst:variable name="tmpn" value="$split_expr_neg"/>
      <admst:variable name="split_expr_neg" test="[$tmpn='no']" value="yes"/>
      <admst:variable name="split_expr_neg" test="[$tmpn='yes']" value="no"/>
      <admst:apply-templates select="arg2" match="split_expr"/>
      <admst:variable name="split_expr_neg" value="$tmpn"/>
    </admst:when>
    <admst:otherwise>
      <admst:choose>
        <admst:when test="[$split_expr_neg='no']">
          <admst:push into="$split_expr_list" select="."/>
        </admst:when>
        <admst:otherwise>
          <admst:new datatype="mapply_unary" inputs="'minus',.">
            <admst:push into="$split_expr_list" select="."/>
          </admst:new>
        </admst:otherwise>
      </admst:choose>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!--
  The split_contrib template will convert contributions into multiple
  contributions, using the split_expr template.  We do this before
  other processing to improve the chance that each contrubution is
  purely static, dynamic, noise, or whatever category.  The rest of
  adms will process the contribution according to the category.  Since
  a single category applies to the whole contribution line, without
  the splitting, mixed contribution lines (e.g., containing both
  static and dynamic terms) would be handled incorrectly.

  Both variables below are for internal use.  The template should be
  called on adms/datatypename=module for correct initialization.

  Upon return, contributions containing multiple terms will have been
  converted to multiple contributions, but the data structure can
  subsequently be handled in the normal way.  In some cases, a block
  item is created to contain the multiple contributions, to preserve
  correct logic in output.

  NOTE: in adms-2.3.0, this may generate a spurious error message
    [error..] mismatch in assigment - lhs=contribution rhs=block
  This seems to have no consequence.
  ADDED: this is suppressed in the adms-2.3.0-wr release.
-->
<admst:variable name="split_contrib_list" datatype="list"/>
<admst:variable name="split_contrib_pblk"/>

<admst:template match="split_contrib">
  <admst:choose>
    <admst:when test="adms[datatypename='module']">
      <admst:variable name="split_contrib_list" datatype="list"/>
      <admst:apply-templates select="analog/code" match="split_contrib"/>
    </admst:when>

    <admst:when test="adms[datatypename='block']">
      <admst:variable name="split_contrib_pblk" path="."/>
      <admst:variable name="split_contrib_list" datatype="list"/>
      <admst:apply-templates select="item[adms/datatypename='contribution']"
          match="split_contrib"/>
      <admst:if test="[count($split_contrib_list)!=0]">
        <admst:for-each select="$split_contrib_list">
          <admst:push into="../item" select="."/>
          <admst:push into="./module/contribution" select="."/>
        </admst:for-each>
        <admst:variable name="split_contrib_list" datatype="list"/>
      </admst:if>
      <admst:apply-templates select="item[adms/datatypename!='contribution']"
          match="split_contrib"/>
    </admst:when>

    <admst:when test="adms[datatypename='conditional']">
      <!--
        If a contribution is split, and it is not in a block, we have
        to create a block to hold the pieces.
      -->
      <admst:apply-templates select="then" match="split_contrib"/>
      <admst:if test="[count($split_contrib_list)!=0]">
        <admst:variable name="then" path="then"/>
        <admst:if test="[then/adms/datatypename!='block']">
          <admst:variable name="vv" datatype="list"/>
          <admst:new datatype="block"
              inputs="../module,'',$split_contrib_pblk,$vv">
            <admst:value-to select="../then" path="."/>
          </admst:new>
          <admst:push into="then/item" select="$then"/>
        </admst:if>
        <admst:for-each select="$split_contrib_list">
          <admst:push into="../then/item" select="."/>
          <admst:push into="./module/contribution" select="."/>
        </admst:for-each>
        <admst:variable name="split_contrib_list" datatype="list"/>
      </admst:if>

      <admst:apply-templates select="else" match="split_contrib"/>
      <admst:if test="[count($split_contrib_list)!=0]">
        <admst:variable name="else" path="else"/>
        <admst:if test="[else/adms/datatypename!='block']">
          <admst:variable name="vv" datatype="list"/>
          <admst:new datatype="block"
              inputs="../module,'',$split_contrib_pblk,$vv">
            <admst:value-to select="../else" path="."/>
          </admst:new>
          <admst:push into="else/item" select="$else"/>
        </admst:if>
        <admst:for-each select="$split_contrib_list">
          <admst:push into="../else/item" select="."/>
          <admst:push into="./module/contribution" select="."/>
        </admst:for-each>
        <admst:variable name="split_contrib_list" datatype="list"/>
      </admst:if>
    </admst:when>

    <admst:when test="adms[datatypename='case']">
      <admst:for-each select="caseitem">
        <admst:apply-templates select="code" match="split_contrib"/>
        <!--
          If a contribution is split, and it is not in a block, we have
          to create a block to hold the pieces.
        -->
        <admst:if test="[count($split_contrib_list)!=0]">
          <admst:variable name="code" path="code"/>
          <admst:if test="[code/adms/datatypename!='block']">
            <admst:variable name="vv" datatype="list"/>
            <admst:new datatype="block"
                inputs="../module,'',$split_contrib_pblk,$vv">
              <admst:value-to select="../code" path="."/>
            </admst:new>
            <admst:push into="code/item" select="$code"/>
          </admst:if>
          <admst:for-each select="$split_contrib_list">
            <admst:push into="../code/item" select="."/>
            <admst:push into="./module/contribution" select="."/>
          </admst:for-each>
          <admst:variable name="split_contrib_list" datatype="list"/>
        </admst:if>

      </admst:for-each>
    </admst:when>

    <admst:when test="adms[datatypename='whileloop']">
      <admst:apply-templates select="whileblock" match="split_contrib"/>
      <admst:if test="[count($split_contrib_list)!=0]">
        <admst:variable name="while" path="whileblock"/>
        <admst:if test="[whileblock/adms/datatypename!='block']">
          <admst:variable name="vv" datatype="list"/>
          <admst:new datatype="block"
              inputs="../module,'',$split_contrib_pblk,$vv">
            <admst:value-to select="../whileblock" path="."/>
          </admst:new>
          <admst:push into="whileblock/item" select="$while"/>
        </admst:if>
        <admst:for-each select="$split_contrib_list">
          <admst:push into="../whileblock/item" select="."/>
          <admst:push into="./module/contribution" select="."/>
        </admst:for-each>
        <admst:variable name="split_contrib_list" datatype="list"/>
      </admst:if>
    </admst:when>

    <admst:when test="adms[datatypename='forloop']">
      <admst:apply-templates select="forblock" match="split_contrib"/>
      <admst:if test="[count($split_contrib_list)!=0]">
        <admst:variable name="for" path="forblock"/>
        <admst:if test="[forblock/adms/datatypename!='block']">
          <admst:variable name="vv" datatype="list"/>
          <admst:new datatype="block"
              inputs="../module,'',$split_contrib_pblk,$vv">
            <admst:value-to select="../forblock" path="."/>
          </admst:new>
          <admst:push into="forblock/item" select="$for"/>
        </admst:if>
        <admst:for-each select="$split_contrib_list">
          <admst:push into="../forblock/item" select="."/>
          <admst:push into="./module/contribution" select="."/>
        </admst:for-each>
        <admst:variable name="split_contrib_list" datatype="list"/>
      </admst:if>
    </admst:when>

    <admst:when test="adms[datatypename='contribution']">
      <admst:variable name="c" path="."/>
      <admst:apply-templates select="rhs" match="split_expr"/>
      <admst:if test="[count($split_expr_list)!=1]">
        <admst:for-each select="$split_expr_list">
          <admst:choose>
            <admst:when test="[position(.)=1]">
              <admst:new datatype="expression" inputs="$c/module,.">
                <admst:value-to select="$c/rhs" path="."/>
              </admst:new>
            </admst:when>
            <admst:otherwise>
              <admst:new datatype="expression" inputs="$c/module,.">
                <admst:new datatype="contribution"
                    inputs="$c/module,$c/lhs,.,$c/lexval">
                  <admst:push into="$split_contrib_list" select="."/>
                </admst:new>
              </admst:new>
            </admst:otherwise>
          </admst:choose>
        </admst:for-each>
      </admst:if>
    </admst:when>
    <admst:when test="adms[datatypename='assignment']"/>
    <admst:when test="adms[datatypename='callfunction']"/>
    <admst:when test="adms[datatypename='nilled']"/>
    <admst:when test="adms[datatypename='blockvariable']"/>
    <admst:when test="adms[datatypename='node']"/>
    <admst:otherwise>
      <admst:warning
        format="split_contrib: unhandled type %(datatypename).\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!-- ---------------------------------------------------------------
  The following templates enable support of ddx(expression,probe)
  where the expression is not a simple variable.  The basic internal
  ddx support requires a variable as the first argument.  Here, we
  rewrite in a form like

    temp_var = expression;
    ... ddx(temp_var,probe) ...

  where we create the temp var as a local variable.  Subsequent
  processing should do the right thing regarding derivates.
-->

<admst:variable name="eddx_find_list"/>

<!--
  Call this on an expression, it will return a list of "eddx" calls
  (datatypename=function), which are ddx calls where the first
  argument is not a simple variable, in $eddx_find_list.
-->
<admst:template match="eddx_find">
  <admst:choose>
    <admst:when test="[datatypename='expression']">
      <admst:apply-templates select="tree" match="eddx_find"/>
    </admst:when>
    <admst:when test="[datatypename='mapply_unary']">
      <admst:apply-templates select="arg1" match="eddx_find"/>
    </admst:when>
    <admst:when test="[datatypename='mapply_binary']">
      <admst:apply-templates select="arg1|arg2" match="eddx_find"/>
    </admst:when>
    <admst:when test="[datatypename='mapply_ternary']">
      <admst:apply-templates select="arg1|arg2|arg3" match="eddx_find"/>
    </admst:when>
    <admst:when test="[datatypename='function']">
      <admst:if test="[name='ddx']">
        <admst:if test="[arguments[1]/datatypename!='variable']">
          <admst:push into="$eddx_find_list" select="."/>
        </admst:if>
      </admst:if>
    </admst:when>
    <admst:when test="[datatypename='probe']"/>
    <admst:when test="[datatypename='array']"/>
    <admst:when test="[datatypename='variable']"/>
    <admst:when test="[datatypename='number']"/>
    <admst:when test="[datatypename='string']"/>
    <admst:when test="[datatypename='node']"/>
    <admst:otherwise>
      <admst:fatal format="%(datatypename): case not handled\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!--
  Call this on an expression, it will return 'yes' if the expression
  contains "eddx" calls, which are ddx calls where the first argument
  is not a simple variable.
-->
<admst:template match="eddx_check">
  <admst:variable name="has_eddx" value="no"/>
  <admst:choose>
    <admst:when test="[datatypename='expression']">
      <admst:if test="[eddx_check(tree)/value='yes']">
        <admst:variable name="has_eddx" value="yes"/>
      </admst:if>
    </admst:when>
    <admst:when test="[datatypename='mapply_unary']">
      <admst:if test="[eddx_check(arg1)/value='yes']">
        <admst:variable name="has_eddx" value="yes"/>
      </admst:if>
    </admst:when>
    <admst:when test="[datatypename='mapply_binary']">
      <admst:if test="[eddx_check(arg1)/value='yes']">
        <admst:variable name="has_eddx" value="yes"/>
      </admst:if>
      <admst:if test="[eddx_check(arg2)/value='yes']">
        <admst:variable name="has_eddx" value="yes"/>
      </admst:if>
    </admst:when>
    <admst:when test="[datatypename='mapply_ternary']">
      <admst:if test="[eddx_check(arg1)/value='yes']">
        <admst:variable name="has_eddx" value="yes"/>
      </admst:if>
      <admst:if test="[eddx_check(arg2)/value='yes']">
        <admst:variable name="has_eddx" value="yes"/>
      </admst:if>
      <admst:if test="[eddx_check(arg3)/value='yes']">
        <admst:variable name="has_eddx" value="yes"/>
      </admst:if>
    </admst:when>
    <admst:when test="[datatypename='function']">
      <admst:if test="[name='ddx']">
        <admst:if test="[arguments[1]/datatypename!='variable']">
          <admst:variable name="has_eddx" value="true"/>
        </admst:if>
      </admst:if>
    </admst:when>
    <admst:when test="[datatypename='probe']"/>
    <admst:when test="[datatypename='array']"/>
    <admst:when test="[datatypename='variable']"/>
    <admst:when test="[datatypename='number']"/>
    <admst:when test="[datatypename='string']"/>
    <admst:when test="[datatypename='node']"/>
    <admst:otherwise>
      <admst:fatal format="%(datatypename): case not handled\n"/>
    </admst:otherwise>
  </admst:choose>
  <admst:return name="value" value="$has_eddx"/>
</admst:template>

<admst:variable name="reference"/>
<admst:variable name="assigned"/>

<!--
  Call on a block, with an item from the block in $reference, and the
  list of new assignments in $assigned.  This will push the new
  assignments ahead of the reference item.
-->
<admst:template match="push_into_block">
  <admst:variable name="itms" datatype="list"/>
  <admst:for-each select="item">
    <admst:push into="$itms" select="."/>
    <admst:if test="[.=$reference]">
      <!-- DEBUG
      <admst:warning format="DBG4 $reference $assigned\n"/>
      -->
      <admst:for-each select="$assigned">
        <admst:push into="$itms" select="."/>
      </admst:for-each>
    </admst:if>
  </admst:for-each>
  <admst:reset select="item"/>
  <admst:for-each select="$itms">
    <admst:push into="../item" select="."/>
  </admst:for-each>
</admst:template>

<admst:variable name="eddx_fix_list" datatype="list"/>
<admst:variable name="eddx_src_list" datatype="list"/>
<admst:variable name="eddx_fix_pblk"/>
<!--
  eddx_fix_list: List of new assignemts lists, each element is a list
                 of the newly-created assignments for a ddx call in
                 original assignment rhs.
  eddx_src_list: List of the original assignments
-->

<!--
  The main template to process input allowing "eddx" calls (calls to
  ddx where the first argument is an expression, not a variable).
  Call this on the module ahead of normal adms processing.
-->
<admst:template match="eddx_fix">
  <admst:choose>
    <admst:when test="adms[datatypename='module']">
      <admst:variable name="eddx_fix_list" datatype="list"/>
      <admst:variable name="eddx_src_list" datatype="list"/>
      <admst:apply-templates select="analog/code" match="eddx_fix"/>
    </admst:when>

    <admst:when test="adms[datatypename='block']">
      <admst:variable name="tfix" path="$eddx_fix_list"/>
      <admst:variable name="eddx_fix_list" datatype="list"/>
      <admst:variable name="tsrc" path="$eddx_src_list"/>
      <admst:variable name="eddx_src_list" datatype="list"/>
      <admst:variable name="eddx_fix_pblk" path="."/>
      <admst:apply-templates select="item" match="eddx_fix"/>
      <admst:if test="[count($eddx_src_list)!=0]">
        <admst:variable name="blk" path="."/>
        <admst:for-each select="$eddx_src_list">
          <admst:variable name="reference" path="."/>
          <admst:for-each select="$eddx_fix_list">
            <admst:if test="[
                index($eddx_src_list,$reference)=index($eddx_fix_list,.)]">
              <admst:variable name="assigned" path="."/>
              <admst:apply-templates select="$blk" match="push_into_block"/>
            </admst:if>
          </admst:for-each>
        </admst:for-each>
      </admst:if>
      <admst:variable name="eddx_fix_list" path="$tfix"/>
      <admst:variable name="eddx_src_list" path="$tsrc"/>
    </admst:when>

    <admst:when test="adms[datatypename='conditional']">
      <admst:choose>
        <admst:when test="[then/adms/datatypename='block']">
          <admst:apply-templates select="then" match="eddx_fix"/>
        </admst:when>
        <admst:when test="[then/adms/datatypename='assignment']">
          <admst:if test="[eddx_check(then/rhs)/value='yes']">
            <admst:variable name="then" path="then"/>
            <admst:variable name="vv" datatype="list"/>
            <admst:new datatype="block"
                inputs="../module,'',$eddx_fix_pblk,$vv">
              <admst:value-to select="../then" path="."/>
            </admst:new>
            <admst:push into="then/item" select="$then"/>
            <admst:apply-templates select="then" match="eddx_fix"/>
          </admst:if>
        </admst:when>
      </admst:choose>

      <admst:choose>
        <admst:when test="[else/adms/datatypename='block']">
          <admst:apply-templates select="else" match="eddx_fix"/>
        </admst:when>
        <admst:when test="[else/adms/datatypename='assignment']">
          <admst:if test="[eddx_check(else/rhs)/value='yes']">
            <admst:variable name="else" path="else"/>
            <admst:variable name="vv" datatype="list"/>
            <admst:new datatype="block"
                inputs="../module,'',$eddx_fix_pblk,$vv">
              <admst:value-to select="../else" path="."/>
            </admst:new>
            <admst:push into="else/item" select="$else"/>
            <admst:apply-templates select="else" match="eddx_fix"/>
          </admst:if>
        </admst:when>
      </admst:choose>
    </admst:when>

    <admst:when test="adms[datatypename='case']">
      <admst:for-each select="caseitem">
        <admst:choose>
          <admst:when test="[code/adms/datatypename='block']">
            <admst:apply-templates select="code" match="eddx_fix"/>
          </admst:when>
          <admst:when test="[code/adms/datatypename='assignment']">
            <admst:if test="[eddx_check(code/rhs)/value='yes']">
              <admst:variable name="code" path="code"/>
              <admst:variable name="vv" datatype="list"/>
              <admst:new datatype="block"
                  inputs="../module,'',$eddx_fix_pblk,$vv">
                <admst:value-to select="../code" path="."/>
              </admst:new>
              <admst:push into="code/item" select="$code"/>
              <admst:apply-templates select="code" match="eddx_fix"/>
            </admst:if>
          </admst:when>
        </admst:choose>
      </admst:for-each>
    </admst:when>

    <admst:when test="adms[datatypename='whileloop']">
      <admst:choose>
        <admst:when test="[whileblock/adms/datatypename='block']">
          <admst:apply-templates select="whileblock" match="eddx_fix"/>
        </admst:when>
        <admst:when test="[whileblock/adms/datatypename='assignment']">
          <admst:if test="[eddx_check(whileblock/rhs)/value='yes']">
            <admst:variable name="while" path="whileblock"/>
            <admst:variable name="vv" datatype="list"/>
            <admst:new datatype="block"
                inputs="../module,'',$eddx_fix_pblk,$vv">
              <admst:value-to select="../whileblock" path="."/>
            </admst:new>
            <admst:push into="whileblock/item" select="$while"/>
            <admst:apply-templates select="whileblock" match="eddx_fix"/>
          </admst:if>
        </admst:when>
      </admst:choose>
    </admst:when>

    <admst:when test="adms[datatypename='forloop']">
      <admst:choose>
        <admst:when test="[forblock/adms/datatypename='block']">
          <admst:apply-templates select="forblock" match="eddx_fix"/>
        </admst:when>
        <admst:when test="[forblock/adms/datatypename='assignment']">
          <admst:if test="[eddx_check(forblock/rhs)/value='yes']">
            <admst:variable name="for" path="forblock"/>
            <admst:variable name="vv" datatype="list"/>
            <admst:new datatype="block"
                inputs="../module,'',$eddx_fix_pblk,$vv">
              <admst:value-to select="../forblock" path="."/>
            </admst:new>
            <admst:push into="forblock/item" select="$for"/>
            <admst:apply-templates select="forblock" match="eddx_fix"/>
          </admst:if>
        </admst:when>
      </admst:choose>
    </admst:when>

    <admst:when test="adms[datatypename='assignment']">
      <admst:variable name="fix_list" datatype="list"/>
      <admst:variable name="eddx_find_list" datatype="list"/>
      <admst:apply-templates select="rhs" match="eddx_find"/>
      <admst:if test="[count($eddx_find_list)!=0]">
        <admst:variable name="a" path="."/>
        <admst:for-each select="$eddx_find_list">
          <admst:variable name="newvar"/>
          <admst:variable name="ddxfnc" path="."/>
          <admst:variable name="namevar" value="ddxtmp%(unique_id)"/>
          <admst:value-of select="$a/module"/>
          <admst:value-of select="$a/module"/>
          <admst:new datatype="variable" arguments="%p,$(namevar),%p">
            <admst:push into="$a/module/variable" select="."
              onduplicate="ignore"/>
            <admst:value-to select="sizetype" value="scalar"/>
            <admst:value-to select="type" value="real"/>
            <admst:value-to select="input" value="no"/>
            <admst:value-to select="output" value="no"/>
            <admst:value-to select="parametertype" value="instance"/>
            <admst:value-to select="scope" value="local"/>
            <admst:new datatype="number" arguments="0">
              <admst:value-to select="scalingunit" value="1"/>
              <admst:value-of select="."/>
              <admst:value-of select="$a/module"/>
              <admst:new datatype="expression" arguments="%p,%p">
                <admst:value-of select="."/>
                <admst:value-to select="../../default" value="%p"/>
              </admst:new>
            </admst:new>
            <!-- The datatypename of $newvar is "variableprototype". -->
            <admst:variable name="newvar" path="."/>
            <!-- DEBUG
              This should be "module".  The new variable will end up
              in the $instance_local_vars list.
            <admst:warning format="DBG1 %(block/adms/datatypename)\n"/>
            -->
          </admst:new>

          <!--
            We need an object of datatypename=variable, so the $newvar
            is no good as-is.  Seens that we have to call admst:new
            again.
          -->
          <admst:new datatype="variable" inputs="$newvar">
            <admst:variable name="newvar" path="."/>
          </admst:new>
          <!-- DEBUG
            Should be "variable".
          <admst:warning format="DBG2 %($newvar/adms/datatypename)\n"/>
          -->

          <!--
            Create an assignment setting the new variable to the ddx
            argument function.  Push it into the fix_list.
          -->
          <admst:new datatype="expression"
              inputs="$a/module,$ddxfnc/arguments[1]">
            <admst:variable name="vv" path="."/>
            <admst:new datatype="assignment"
                inputs="$a/module,$newvar,$vv,$a/lexval">
              <admst:push into="$fix_list" select="."/>
            </admst:new>
          </admst:new>

          <!--
            Replace the ddx function argument with the new variable. 
            Have to reset and rebuild the argument array.
          -->
          <admst:variable name="a2" path="$ddxfnc/arguments[2]"/>
          <admst:reset select="$ddxfnc/arguments"/>
          <admst:push into="$ddxfnc/arguments" select="$a2"/>
          <admst:push into="$ddxfnc/arguments" select="$newvar"/>

        </admst:for-each>
        <admst:push into="$eddx_fix_list" select="$fix_list"/>
        <admst:push into="$eddx_src_list" select="$a"/>
        <!-- DEBUG
        <admst:warning format="DBG3 $fix_list $a\n"/>
        -->
      </admst:if>
    </admst:when>
    <admst:when test="adms[datatypename='contribution']"/>
    <admst:when test="adms[datatypename='callfunction']"/>
    <admst:when test="adms[datatypename='nilled']"/>
    <admst:when test="adms[datatypename='blockvariable']"/>
    <admst:when test="adms[datatypename='node']"/>
    <admst:otherwise>
      <admst:warning
        format="eddx_fix: unhandled type %(datatypename).\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<!--
  End of Whiteley Research Inc.  additions.  The remaining code may
  contain minor tweaks, such as additions to the recognized function
  name list.
-->
<!-- ---------------------------------------------------------------------- -->

<admst:template match="e:init">
  <admst:choose>
    <admst:when test="[datatypename='expression']">
      <admst:variable name="globalexpression" path="."/>
      <admst:apply-templates select="tree" match="e:init"/>
      <admst:variable name="globalexpression"/>
      <admst:reverse select="function"/>
      <admst:value-to select="math/value" path="tree/math/value"/>
    </admst:when>
    <admst:when test="[datatypename='probe']">
      <admst:push into="$globalexpression/probe" select="." onduplicate="ignore"/>
    </admst:when>
    <admst:when test="[datatypename='array']">
      <admst:apply-templates select="variable" match="e:init"/>
    </admst:when>
    <admst:when test="[datatypename='variable']">
      <admst:push into="$globalexpression/variable" select="." onduplicate="ignore"/>
      <admst:push into="$globaltreenode/@variable" select="." onduplicate="ignore"/>
      <admst:push into="$globalexpression/probe" select="probe" onduplicate="ignore"/>
    </admst:when>
    <admst:when test="[datatypename='mapply_unary']">
      <admst:apply-templates select="arg1" match="e:init"/>
      <admst:value-to select="[name='minus']/math/value" string="-%(arg1/math/value)"/>
    </admst:when>
    <admst:when test="[datatypename='mapply_binary']">
      <admst:apply-templates select="arg1|arg2" match="e:init"/>
    </admst:when>
    <admst:when test="[datatypename='mapply_ternary']">
      <admst:apply-templates select="arg1|arg2|arg3" match="e:init"/>
    </admst:when>
    <admst:when test="[datatypename='function']">
      <admst:choose>
        <admst:when test="[name='ddx' or name='\$ddx' or name='\$derivate']">
          <admst:value-to select="$globalassignment/lhs/derivate" string="yes"/>
          <admst:apply-templates select="arguments[1]" match="e:init"/>
          <admst:push into="$globalexpression/variable/ddxprobe" select="arguments[2]" onduplicate="ignore"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arguments" match="e:init"/>
        </admst:otherwise>
      </admst:choose>
      <admst:choose>
        <admst:when test="[
            name='\$abstime' or name='\$given' or name='\$mfactor' or
            name='\$param_given' or name='\$port_connected' or
            name='\$realtime' or name='\$temperature' or name='\$vt' or
            name='\$random' or name='\$rdist_uniform' or
            name='\$rdist_normal' or name='\$rdist_exponential' or
            name='\$rdist_poisson' or name='\$rdist_chi_square' or
            name='\$rdist_t' or name='\$rdist_erlang'
          ]"/>
        <admst:when test="[
            name='ddt' or name='ddx' or name='flicker_noise' or
            name='idt' or name='white_noise'
          ]"/>

        <!--Trigonometric and hyperbolic functions-->
        <admst:when test="[
            name='sin' or name='cos' or name='tan' or name='asin' or
            name='acos' or name='atan' or name='atan2' or name='hypot' or
            name='sinh' or name='cosh' or name='tanh' or name='asinh' or
            name='acosh' or name='atanh'
          ]">
          <admst:push into="$globalexpression/function" select="."/>
          <admst:value-to select="class" string="builtin"/>
        </admst:when>
        <!--standard functions-->
        <admst:when
          test="[
            name='ln' or name='log' or name='exp' or name='sqrt' or
            name='min' or name='max' or
            name='abs' or name='pow' or name='floor' or name='ceil'
          ]">
          <admst:push into="$globalexpression/function" select="."/>
          <admst:value-to select="class" string="builtin"/>
        </admst:when>
        <!--other functions-->
        <admst:when
          test="[name='analysis' or name='simparam' or name='\$limexp'
            or name='limexp']">
          <admst:push into="$globalexpression/function" select="."/>
          <admst:value-to select="class" string="builtin"/>
        </admst:when>
        <!--not standard-->
        <admst:when
          test="[name='\$bcs_egapv' or name='div' or name='\$analysis' or
            name='\$simparam' or
            name='\$shrinka' or name='\$shrinkl' or name='cfunc']">
          <admst:push into="$globalexpression/function" select="."/>
          <admst:value-to select="class" string="builtin"/>
        </admst:when>
        <admst:otherwise>
          <admst:assert test="[exists(definition)]" format="%(lexval/(f|':'|l|':'|c)): analog function '%(name)' is undefined\n"/>
        </admst:otherwise>
      </admst:choose>
      <admst:value-to select="subexpression/expression" path="$globalexpression"/>
      <!-- fixme: these flags should be set after all contribs are transformed to ...<+F(...); canonical form -->
      <admst:value-to test="[name='ddt']" select="$globalcontribution/#fixmedynamic" path="1"/>
      <admst:value-to test="[name='white_noise']" select="$globalcontribution/#fixmewhitenoise" path="1"/>
      <admst:value-to test="[name='flicker_noise']" select="$globalcontribution/#fixmeflickernoise" path="1"/>
      <admst:value-to test="[name='\$temperature']" select="$globalassignment/lhs/TemperatureDependent" string="yes"/>
    </admst:when>
    <admst:when test="[datatypename='number']">
      <admst:choose>
        <admst:when test="[scalingunit='1']">
          <admst:value-to select="math/value" path="value"/>
        </admst:when>
        <admst:when test="[scalingunit='E']">
          <admst:value-to select="math/value" string="%(value)e+18"/>
        </admst:when>
        <admst:when test="[scalingunit='P']">
          <admst:value-to select="math/value" string="%(value)e+15"/>
        </admst:when>
        <admst:when test="[scalingunit='T']">
          <admst:value-to select="math/value" string="%(value)e+12"/>
        </admst:when>
        <admst:when test="[scalingunit='G']">
          <admst:value-to select="math/value" string="%(value)e+9"/>
        </admst:when>
        <admst:when test="[scalingunit='M']">
          <admst:value-to select="math/value" string="%(value)e+6"/>
        </admst:when>
        <admst:when test="[scalingunit='k']">
          <admst:value-to select="math/value" string="%(value)e+3"/>
        </admst:when>
        <admst:when test="[scalingunit='h']">
          <admst:value-to select="math/value" string="%(value)e+2"/>
        </admst:when>
        <admst:when test="[scalingunit='D']">
          <admst:value-to select="math/value" string="%(value)e+1"/>
        </admst:when>
        <admst:when test="[scalingunit='d']">
          <admst:value-to select="math/value" string="%(value)e-1"/>
        </admst:when>
        <admst:when test="[scalingunit='c']">
          <admst:value-to select="math/value" string="%(value)e-2"/>
        </admst:when>
        <admst:when test="[scalingunit='m']">
          <admst:value-to select="math/value" string="%(value)e-3"/>
        </admst:when>
        <admst:when test="[scalingunit='u']">
          <admst:value-to select="math/value" string="%(value)e-6"/>
        </admst:when>
        <admst:when test="[scalingunit='n']">
          <admst:value-to select="math/value" string="%(value)e-9"/>
        </admst:when>
        <admst:when test="[scalingunit='A']">
          <admst:value-to select="math/value" string="%(value)e-10"/>
        </admst:when>
        <admst:when test="[scalingunit='p']">
          <admst:value-to select="math/value" string="%(value)e-12"/>
        </admst:when>
        <admst:when test="[scalingunit='f']">
          <admst:value-to select="math/value" string="%(value)e-15"/>
        </admst:when>
        <admst:when test="[scalingunit='a']">
          <admst:value-to select="math/value" string="%(value)e-18"/>
        </admst:when>
        <admst:otherwise>
          <admst:error format="%(lexval/(f|':'|l|':'|c)): unit not supported: %(scalingunit)\n"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='string']"/>
    <admst:when test="[datatypename='node']"/>
    <admst:otherwise>
      <admst:fatal format="%(datatypename): case not handled\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="init">
  <admst:choose>
    <admst:when test="[datatypename='callfunction']">
      <admst:apply-templates select="function/arguments" match="e:init"/>
    </admst:when>
    <admst:when test="[datatypename='whileloop']">
      <admst:apply-templates select="while" match="e:init"/>
      <admst:apply-templates select="whileblock" match="init"/>
    </admst:when>
    <admst:when test="[datatypename='forloop']">
      <admst:apply-templates select="initial|update" match="init"/>
      <admst:apply-templates select="condition" match="e:init"/>
      <admst:apply-templates select="forblock" match="init"/>
    </admst:when>
    <admst:when test="[datatypename='case']">
      <admst:apply-templates select="case" match="e:init"/>
      <admst:variable name="globaltreenode"/>
      <admst:for-each select="caseitem">
        <admst:for-each select="condition">
          <admst:variable name="globaltreenode" path="."/>
          <admst:apply-templates select="." match="e:init"/>
          <admst:variable name="globaltreenode"/>
        </admst:for-each>
        <admst:apply-templates select="code" match="init"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="[datatypename='conditional']">
      <admst:push into="$globalmodule/conditional" select="."/>
      <admst:apply-templates select="if" match="e:init"/>
      <admst:apply-templates select="then|else" match="init"/>
    </admst:when>
    <admst:when test="[datatypename='contribution']">
      <admst:variable name="globalcontribution" path="."/>
      <admst:apply-templates select="rhs" match="e:init"/>
      <admst:variable name="globalcontribution"/>
      <admst:push into="lhs/probe" select="rhs/probe" onduplicate="ignore"/>
    </admst:when>
    <admst:when test="[datatypename='assignment']">
      <admst:choose>
        <admst:when test="[lhs/datatypename='array']">
          <admst:variable name="lhs" path="lhs/variable"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="lhs" path="lhs"/>
        </admst:otherwise>
      </admst:choose>
      <admst:variable name="globalassignment" path="."/>
      <admst:apply-templates select="rhs" match="e:init"/>
      <admst:variable name="globalassignment"/>
      <admst:push into="$lhs/probe" select="rhs/probe" onduplicate="ignore"/>
      <admst:push into="$lhs/variable" select="rhs/variable" onduplicate="ignore"/>
    </admst:when>
    <admst:when test="[datatypename='block']">
      <admst:reverse select="item|variable"/>
      <admst:apply-templates select="item" match="init"/>
    </admst:when>
    <admst:when test="[datatypename='nilled']"/>
    <admst:when test="[datatypename='blockvariable']"/>
    <admst:otherwise>
      <admst:fatal format="%(datatypename): case not handled\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="e:dependency">
  <admst:choose>
    <admst:when test="[datatypename='expression']">
      <admst:variable name="globalexpression" path="."/>
      <admst:apply-templates select="tree" match="e:dependency"/>
      <admst:variable name="globalexpression"/>
      <admst:value-to select="dependency" path="tree/dependency"/>
      <admst:value-to select="dependency[.='constant' and $globalopdependent='yes']" string="noprobe"/>
      <admst:apply-templates select="." match="e:partition"/>
    </admst:when>
    <admst:when test="[datatypename='probe']">
      <admst:value-to select="dependency" string="linear"/>
    </admst:when>
    <admst:when test="[datatypename='array']">
      <admst:apply-templates select="variable" match="e:dependency"/>
      <admst:value-to select="dependency" path="variable/dependency"/>
    </admst:when>
    <admst:when test="[datatypename='variable']">
      <admst:value-to select="dependency" path="prototype/dependency"/>
    </admst:when>
    <admst:when test="[datatypename='mapply_unary']">
      <admst:apply-templates select="arg1" match="e:dependency"/>
      <admst:value-to select="dependency" path="arg1/dependency"/>
    </admst:when>
    <admst:when test="[datatypename='mapply_binary']">
      <admst:apply-templates select="arg1|arg2" match="e:dependency"/>
      <!--
        +:             -:            *:            /:                                                          
          c  np l  nl    c  np l  nl   c  np l  nl   c  np nl nl                                                          
          np np l  nl    np np l  nl   np np l  nl   np np nl nl                                                          
          l  l  l  nl    l  l  l  nl   l  l  nl nl   l  l  nl nl                                                          
          nl nl nl nl    nl nl nl nl   nl nl nl nl   nl nl nl nl                                                          
      -->
      <admst:choose>
        <admst:when test="[arg1/dependency='nonlinear' or arg2/dependency='nonlinear']">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[name='multtime' and (arg1|arg2)/dependency=('linear'|'linear')]">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[name='multdiv' and arg2/dependency='linear']">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[arg1/dependency='linear' or arg2/dependency='linear']">
          <admst:value-to select="dependency" string="linear"/>
        </admst:when>
        <admst:when test="[arg1/dependency='noprobe' or arg2/dependency='noprobe']">
          <admst:value-to select="dependency" string="noprobe"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="dependency" string="constant"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='mapply_ternary']">
      <admst:apply-templates select="arg1|arg2|arg3" match="e:dependency"/>
      <!--
          ?: - arg1=c -  - arg1!=c -                                                            
             c  np l  nl np np l  nl                                                             
             np np l  nl np np l  nl                                                             
             l  l  l  nl l  l  l  nl                                                             
             nl nl nl nl nl nl nl nl                                                             
      -->
      <admst:choose>
        <admst:when test="[arg2/dependency='nonlinear' or arg3/dependency='nonlinear']">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[arg2/dependency='linear' or arg3/dependency='linear']">
          <admst:value-to select="dependency" string="linear"/>
        </admst:when>
        <admst:when test="[arg1/dependency!='constant' or arg2/dependency='noprobe' or arg3/dependency='noprobe']">
          <admst:value-to select="dependency" string="noprobe"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="dependency" string="constant"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='function']">
      <admst:choose>
        <admst:when test="[name='\$port_connected']"/>
        <admst:when test="[name='ddx' or name='\$ddx' or name='\$derivate']">
          <admst:apply-templates select="arguments[1]" match="e:dependency"/>
          <admst:choose>
            <admst:when test="arguments[1]/dependency[.='constant' or .='noprobe']">
              <admst:value-to select="dependency" path="arguments[1]/dependency"/>
            </admst:when>
            <admst:otherwise>
              <admst:value-to select="dependency" string="nonlinear"/>
            </admst:otherwise>
          </admst:choose>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="arguments" match="e:dependency"/>
          <admst:choose>
            <admst:when test="[(name='ddt' or name='\$ddt')or(name='idt' or name='\$idt')]">
              <admst:value-to select="dependency" string="nonlinear"/>
            </admst:when>
            <admst:when test="arguments/dependency[.='linear' or .='nonlinear']">
              <admst:value-to select="dependency" string="nonlinear"/>
            </admst:when>
            <admst:when test="arguments/dependency[.='noprobe']">
              <admst:value-to select="dependency" string="noprobe"/>
            </admst:when>
            <admst:otherwise>
              <admst:value-to select="dependency" string="constant"/>
            </admst:otherwise>
          </admst:choose>
        </admst:otherwise>
      </admst:choose>
      <admst:value-to test="dependency[.='linear' or .='nonlinear']" select="$globalexpression/hasVoltageDependentFunction" string="yes"/>
    </admst:when>
    <admst:when test="[datatypename='number']"/>
    <admst:when test="[datatypename='string']"/>
    <admst:when test="[datatypename='node']"/>
    <admst:otherwise>
      <admst:fatal format="%(datatypename): case not handled\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="dependency">
  <admst:choose>
    <admst:when test="[datatypename='callfunction']">
      <admst:apply-templates select="function/arguments" match="e:dependency"/>
      <admst:value-to select="dependency" path="function/dependency"/>
    </admst:when>
    <admst:when test="[datatypename='whileloop']">
      <!--
        w, logic(D,while.d)            , d=wb.d                                               
              c                 !c                           
           c  wb,w,!c?(D,wb,!D) D,wb,!D                                                                                        
           !c wb                wb                                                                                             
      -->
      <admst:apply-templates select="while" match="e:dependency"/>
      <admst:apply-templates select="[$globalopdependent='yes' or while/dependency='constant']/whileblock" match="dependency"/>
      <admst:if test="[$globalopdependent='no']">
        <admst:apply-templates select="while[dependency='constant']" match="e:dependency"/>
        <admst:if test="[while/dependency!='constant']">
          <admst:variable name="globalopdependent" string="yes"/>
          <admst:apply-templates select="whileblock" match="dependency"/>
          <admst:variable name="globalopdependent" string="no"/>
        </admst:if>
      </admst:if>
      <!--
          wl:  w=c          w!=c
               c  np l  nl  np np l  nl                                                             
               np np l  nl  np np l  nl                                                             
               l  l  l  nl  l  l  l  nl                                                             
               nl nl nl nl  nl nl nl nl                                                             
      -->
      <admst:choose>
        <admst:when test="[whileblock/dependency='nonlinear']">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[whileblock/dependency='linear']">
          <admst:value-to select="dependency" string="linear"/>
        </admst:when>
        <admst:when test="[while/dependency!='constant' or whileblock/dependency='noprobe']">
          <admst:value-to select="dependency" string="noprobe"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="dependency" string="constant"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='forloop']">
      <admst:apply-templates select="initial|update" match="dependency"/>
      <admst:apply-templates select="condition" match="e:dependency"/>
      <admst:apply-templates select="[$globalopdependent='yes' or nilled((initial|condition|update)/[dependency!='constant'])]/forblock" match="dependency"/>
      <admst:if test="[$globalopdependent='no']">
        <admst:apply-templates select="(initial|update)/[dependency='constant']" match="dependency"/>
        <admst:apply-templates select="condition[dependency='constant']" match="e:dependency"/>
        <admst:if test="[condition/dependency!='constant' or initial/dependency!='constant' or update/dependency!='constant']">
          <admst:variable name="globalopdependent" string="yes"/>
          <admst:apply-templates select="forblock" match="dependency"/>
          <admst:variable name="globalopdependent" string="no"/>
        </admst:if>
      </admst:if>
      <!--
          fl:  f=c          f!=c
               c  np l  nl  np np l  nl                                                             
               np np l  nl  np np l  nl                                                             
               l  l  l  nl  l  l  l  nl                                                             
               nl nl nl nl  nl nl nl nl                                                             
      -->
      <admst:choose>
        <admst:when test="[forblock/dependency='nonlinear']">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[forblock/dependency='linear']">
          <admst:value-to select="dependency" string="linear"/>
        </admst:when>
        <admst:when test="[(condition!='constant' or initial!='constant' or update!='constant') or forblock/dependency='noprobe']">
          <admst:value-to select="dependency" string="noprobe"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="dependency" string="constant"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='case']">
      <admst:apply-templates select="case" match="e:dependency"/>
      <admst:for-each select="caseitem">
        <admst:for-each select="condition">
          <admst:apply-templates select="." match="e:dependency"/>
        </admst:for-each>
        <admst:apply-templates select="code" match="dependency"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="[datatypename='conditional']">
      <admst:apply-templates select="if" match="e:dependency"/>
      <admst:choose>
        <admst:when test="[$globalopdependent='no' and if/dependency!='constant']">
          <admst:variable name="globalopdependent" string="yes"/>
          <admst:apply-templates select="then|else" match="dependency"/>
          <admst:variable name="globalopdependent" string="no"/>
        </admst:when>
        <admst:otherwise>
          <admst:apply-templates select="then|else" match="dependency"/>
        </admst:otherwise>
      </admst:choose>
      <!--
          cd:  i=c          i!=c
               c  np l  nl  np np l  nl                                                             
               np np l  nl  np np l  nl                                                             
               l  l  l  nl  l  l  l  nl                                                             
               nl nl nl nl  nl nl nl nl                                                             
      -->
      <admst:choose>
        <admst:when test="[then/dependency='nonlinear' or else/dependency='nonlinear']">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[then/dependency='linear' or else/dependency='linear']">
          <admst:value-to select="dependency" string="linear"/>
        </admst:when>
        <admst:when test="[if/dependency!='constant' or then/dependency='noprobe' or else/dependency='noprobe']">
          <admst:value-to select="dependency" string="noprobe"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="dependency" string="constant"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='contribution']">
      <admst:apply-templates select="rhs" match="e:dependency"/>
      <admst:value-to select="dependency" string="nonlinear"/>
    </admst:when>
    <admst:when test="[datatypename='assignment']">
      <admst:choose>
        <admst:when test="[lhs/datatypename='array']">
          <admst:variable name="lhs" path="lhs/variable"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="lhs" path="lhs"/>
        </admst:otherwise>
      </admst:choose>
      <admst:choose>
        <admst:when test="[$globalpartitionning='initial_model']">
          <admst:value-to select="$lhs/setinmodel" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='initial_instance']">
          <admst:value-to select="$lhs/setininstance" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='initial_step']">
          <admst:value-to select="$lhs/setininitial_step" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='noise']">
          <admst:value-to select="$lhs/setinnoise" string="yes"/>
        </admst:when>
        <admst:when test="[$globalpartitionning='final_step']">
          <admst:value-to select="$lhs/setinfinal" string="yes"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="$lhs/setinevaluate" string="yes"/>
        </admst:otherwise>
      </admst:choose>
      <admst:apply-templates select="rhs" match="e:dependency"/>
      <admst:value-to test="rhs/variable[TemperatureDependent='yes']" select="$lhs/TemperatureDependent" string="yes"/>
      <!--
        d=rhs.d,d=(c and D)?np
        l(l,r,$globalopdependent)
        $globalopdependent='no'  $globalopdependent='yes'
        c  np l  nl               np np l  nl
        np np l  nl               np np l  nl
        l  l  l  nl               l  l  l  nl
        nl nl nl nl               nl nl nl nl
      -->
      <admst:value-to select="dependency" path="rhs/dependency"/>
      <admst:choose>
        <admst:when test="[$lhs/prototype/dependency='nonlinear' or rhs/dependency='nonlinear']">
          <admst:value-to select="$lhs/(.|prototype)/dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="[$lhs/prototype/dependency='linear' or rhs/dependency='linear']">
          <admst:value-to select="$lhs/(.|prototype)/dependency" string="linear"/>
        </admst:when>
        <admst:when test="[$globalopdependent='yes' or $lhs/prototype/dependency='noprobe' or rhs/dependency='noprobe']">
          <admst:value-to select="$lhs/(.|prototype)/dependency" string="noprobe"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="$lhs/(.|prototype)/dependency" string="constant"/>
        </admst:otherwise>
      </admst:choose>      
    </admst:when>
    <admst:when test="[datatypename='block']">
      <admst:variable name="forcepartitionning" string="yes"/>
      <admst:choose>
        <!--
          Allow synonym initializeModel for initial_model, same for
          instance.  Is there a standard name for these blocks?  The
          code in these blocks is output in the temperature method,
          and is excluded from the load method.  They also provide
          identification of instance vs.  model parameters.
        -->
        <admst:when test="[name='initial_model' or name='initializeModel']">
          <admst:variable name="globalpartitionning" string="initial_model"/>
        </admst:when>
        <admst:when test="[name='initial_instance' or name='initializeInstance']">
          <admst:variable name="globalpartitionning" string="initial_instance"/>
        </admst:when>
        <admst:when test="[name='initial_step']">
          <admst:variable name="globalpartitionning" string="initial_step"/>
        </admst:when>
        <admst:when test="[name='noise']">
          <admst:variable name="globalpartitionning" string="noise"/>
        </admst:when>
        <admst:when test="[name='final_step']">
          <admst:variable name="globalpartitionning" string="final_step"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="forcepartitionning" string="no"/>
        </admst:otherwise>
      </admst:choose>
      <admst:apply-templates select="item" match="dependency"/>
      <admst:variable test="[$forcepartitionning='yes']" name="globalpartitionning"/>
      <admst:choose>
        <admst:when test="item[dependency='nonlinear']">
          <admst:value-to select="dependency" string="nonlinear"/>
        </admst:when>
        <admst:when test="item[dependency='linear']">
          <admst:value-to select="dependency" string="linear"/>
        </admst:when>
        <admst:when test="item[dependency='noprobe']">
          <admst:value-to select="dependency" string="noprobe"/>
        </admst:when>
        <admst:otherwise>
          <admst:value-to select="dependency" string="constant"/>
        </admst:otherwise>
      </admst:choose>
    </admst:when>
    <admst:when test="[datatypename='nilled']"/>
    <admst:when test="[datatypename='blockvariable']"/>
    <admst:otherwise>
      <admst:fatal format="%(datatypename): case not handled\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="e:partition">
  <admst:fatal test="[datatypename!='expression']" format="should be expression\n"/>
  <admst:choose>
    <admst:when test="[nilled($globalpartitionning)]">
      <admst:value-to select="variable/usedinevaluate" string="yes"/>
    </admst:when>
    <admst:when test="[$globalpartitionning='initial_model']">
      <admst:value-to select="variable/usedinmodel" string="yes"/>
    </admst:when>
    <admst:when test="[$globalpartitionning='initial_instance']">
      <admst:value-to select="variable/usedininstance" string="yes"/>
    </admst:when>
    <admst:when test="[$globalpartitionning='initial_step']">
      <admst:value-to select="variable/usedininitial_step" string="yes"/>
    </admst:when>
    <admst:when test="[$globalpartitionning='noise']">
      <admst:value-to select="variable/usedinnoise" string="yes"/>
    </admst:when>
    <admst:when test="[$globalpartitionning='final_step']">
      <admst:value-to select="variable/usedinfinal" string="yes"/>
    </admst:when>
  </admst:choose>
</admst:template>

<admst:template match="partition">
  <admst:choose>
    <admst:when test="[datatypename='callfunction']">
      <admst:apply-templates select="function/arguments" match="e:partition"/>
    </admst:when>
    <admst:when test="[datatypename='whileloop']">
      <admst:apply-templates select="while" match="e:partition"/>
      <admst:apply-templates select="whileblock" match="partition"/>
    </admst:when>
    <admst:when test="[datatypename='forloop']">
      <admst:apply-templates select="condition" match="e:partition"/>
      <admst:apply-templates select="initial|update|forblock" match="partition"/>
    </admst:when>
    <admst:when test="[datatypename='case']">
      <admst:apply-templates select="case" match="e:partition"/>
      <admst:for-each select="caseitem">
        <!-- c'est pas une expression admst:apply-templates select="condition" match="e:partition"/ -->
        <admst:apply-templates select="code" match="partition"/>
      </admst:for-each>
    </admst:when>
    <admst:when test="[datatypename='conditional']">
      <admst:apply-templates select="if" match="e:partition"/>
      <admst:apply-templates select="then|else" match="partition"/>
    </admst:when>
    <admst:when test="[datatypename='contribution']">
      <admst:apply-templates select="rhs" match="e:partition"/>
    </admst:when>
    <admst:when test="[datatypename='assignment']">
      <admst:apply-templates select="rhs" match="e:partition"/>
    </admst:when>
    <admst:when test="[datatypename='block']">
      <admst:variable name="forcepartitionning" string="yes"/>
<!--
  Allow synonym initializeModel for initial_model, same for instance.
  Is there a standard name for this block?
-->
      <admst:choose>
        <admst:when test="[name='initial_model' or name='initializeModel']">
          <admst:variable name="globalpartitionning" string="initial_model"/>
        </admst:when>
        <admst:when test="[name='initial_instance' or name='initializeInstance']">
          <admst:variable name="globalpartitionning" string="initial_instance"/>
        </admst:when>
        <admst:when test="[name='initial_step']">
          <admst:variable name="globalpartitionning" string="initial_step"/>
        </admst:when>
        <admst:when test="[name='noise']">
          <admst:variable name="globalpartitionning" string="noise"/>
        </admst:when>
        <admst:when test="[name='final_step']">
          <admst:variable name="globalpartitionning" string="final_step"/>
        </admst:when>
        <admst:otherwise>
          <admst:variable name="forcepartitionning" string="no"/>
        </admst:otherwise>
      </admst:choose>
      <admst:apply-templates select="item" match="partition"/>
      <admst:variable test="[$forcepartitionning='yes']" name="globalpartitionning"/>
    </admst:when>
    <admst:when test="[datatypename='nilled']"/>
    <admst:when test="[datatypename='blockvariable']"/>
    <admst:otherwise>
      <admst:fatal format="%(datatypename): case not handled\n"/>
    </admst:otherwise>
  </admst:choose>
</admst:template>

<admst:template match="adms.implicit.xml.module">
  <admst:variable name="globalmodule" path="."/>
  <admst:reverse select="analogfunction|analogfunction/variable|node|variable
                         |instance|instance/terminal|contribution|forloop|whileloop|case|callfunction"/>
  <admst:value-to select="node[location='ground']/grounded" string="yes"/>
  <admst:for-each select="branch">
    <admst:value-to select="discipline" path="pnode/discipline"/>
    <admst:value-to select="[nnode/grounded='yes']/grounded" string="yes"/>
    <!-- FIXME: check that pnode/nnode have same discipline -->
  </admst:for-each>
  <admst:for-each select="source|probe">
    <admst:value-to select="discipline" path="branch/discipline"/>
    <admst:value-to select="[branch/grounded='yes']/grounded" string="yes"/>
  </admst:for-each>
  <admst:for-each select="instance">
    <admst:push into="module/instantiator" select=".." onduplicate="ignore"/>
    <admst:assert select="terminal" test="nodefrommodule[location='external']"
                  format="%(../instantiator).%(nodefrommodule/name): is not terminal\n"/>
    <admst:assert select="parameterset" test="parameter[input='yes']"
                  format="%(../instantiator).%(parameter/name): is not input parameter\n"/>
  </admst:for-each>
  <admst:apply-templates select="(analogfunction/tree)|(analog/code)" match="init"/>
  <admst:apply-templates select="(analogfunction/tree)|(analog/code)" match="dependency"/>
  <admst:apply-templates select="(analogfunction/tree)|(analog/code)" match="partition"/>
  <admst:for-each select="variable">
    <admst:value-to select="[dependency!='constant']/OPdependent" string="yes"/>
    <admst:value-to select="output" path="input"/>
    <admst:for-each select="attribute">
      <admst:value-to select="[name='type' and value='instance']/../parametertype" string="instance"/>
      <admst:value-to select="[name='ask' and value='yes']/../output" string="yes"/>
      <admst:value-to select="[name='ask' and value='no']/../output" string="no"/>
    </admst:for-each>
    <admst:apply-templates select="default" match="e:dependency"/>
    <admst:value-to
       select="default[exists(tree[datatypename='mapply_unary' and name='minus' and arg1/datatypename='number' and arg1/value='1.0'])]/value"
       string="is_neg_one"/>
    <admst:value-to select="default[exists(tree[datatypename='number' and value='0.0'])]/value" string="is_zero"/>
    <admst:value-to select="default[exists(tree[datatypename='number' and value='1.0'])]/value" string="is_one"/>
    <admst:value-to select="scope"
      test="[(input='yes' and parametertype='model') or (input='no' and (setinmodel='yes' or usedinmodel='yes')
        and (setininstance='yes' or setininitial_step='yes' or setinevaluate='yes' or setinnoise='yes' or setinfinal='yes'
        or usedininstance='yes' or usedininitial_step='yes' or usedinevaluate='yes' or usedinnoise='yes' or usedinfinal='yes' or output='yes'))]"
      string="global_model"/>
    <admst:value-to select="scope"
      test="[(input='yes' and parametertype='instance') or
      (input='no' and setinmodel='no' and usedinmodel='no' and
        (((setininstance='yes' or usedininstance='yes') and (setininitial_step='yes' or setinevaluate='yes' or setinnoise='yes' or setinfinal='yes'
        or usedininitial_step='yes' or usedinevaluate='yes' or usedinnoise='yes' or usedinfinal='yes' or output='yes'))
        or ((setininitial_step='yes' or usedininitial_step='yes') and (setinevaluate='yes' or setinnoise='yes' or setinfinal='yes'
        or usedinevaluate='yes' or usedinnoise='yes' or usedinfinal='yes' or output='yes'))
        or ((setinevaluate='yes' or usedinevaluate='yes') and (setinnoise='yes' or setinfinal='yes'
          or usedinnoise='yes' or usedinfinal='yes' or output='yes'))
        or ((setinnoise='yes' or usedinnoise='yes') and (setinfinal='yes' or usedinfinal='yes' or output='yes'))
        or ((setinfinal='yes' or usedinfinal='yes') and output='yes')
        or (setinmodel='no' and setininstance='no' and setinevaluate='no' and setinnoise='no' and setinfinal='no' and
            usedinmodel='no' and usedininstance='no' and usedinevaluate='no' and usedinnoise='no' and usedinfinal='no' and output='yes')
      ))]"
      string="global_instance"/>
    <admst:value-to select="isstate"
      test="[input='no' and scope='global_instance' and setininitial_step='yes' and (setinevaluate='yes' or usedinevaluate='yes')]"
      string="yes"/>
  </admst:for-each>
  <admst:template match="modify">
    <admst:choose>
      <admst:when test="[datatypename='block']">
        <admst:apply-templates select="reverse(item)" match="modify"/>
        <admst:value-to test="item[#modifys=1]" select="#modifys" path="1"/>
        <admst:value-to test="item[#modifyd=1]" select="#modifyd" path="1"/>
        <admst:value-to test="item[#modifyn=1]" select="#modifyn" path="1"/>
        <admst:value-to test="item[#modifyc=1]" select="#modifyc" path="1"/>
      </admst:when>
      <admst:when test="[datatypename='conditional']">
        <admst:apply-templates select="else|then" match="modify"/>
        <admst:value-to test="[then/#modifys=1 or else/#modifys=1]" select="#modifys|if/#modifys|if/variable/#modifys" path="1"/>
        <admst:value-to test="[then/#modifyd=1 or else/#modifyd=1]" select="#modifyd|if/#modifyd|if/variable/#modifyd" path="1"/>
        <admst:value-to test="[then/#modifyn=1 or else/#modifyn=1]" select="#modifyn|if/#modifyn|if/variable/#modifyn" path="1"/>
        <admst:value-to test="[then/#modifyc=1 or else/#modifyc=1]" select="#modifyc|if/#modifyc|if/variable/#modifyc" path="1"/>
      </admst:when>
      <admst:when test="[datatypename='whileloop']">
        <admst:apply-templates select="whileblock" match="modify"/>
        <admst:value-to test="[whileblock/#modifys=1]" select="#modifys|while/#modifys|while/variable/#modifys" path="1"/>
        <admst:value-to test="[whileblock/#modifyd=1]" select="#modifyd|while/#modifyd|while/variable/#modifyd" path="1"/>
        <admst:value-to test="[whileblock/#modifyn=1]" select="#modifyn|while/#modifyn|while/variable/#modifyn" path="1"/>
        <admst:value-to test="[whileblock/#modifyc=1]" select="#modifyc|while/#modifyc|while/variable/#modifyc" path="1"/>
        <admst:apply-templates select="whileblock" match="modify"/>
      </admst:when>
      <admst:when test="[datatypename='forloop']">
        <admst:choose>
          <admst:when test="[update/lhs/datatypename='array']">
            <admst:variable name="lhs" path="update/lhs/variable"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="lhs" path="update/lhs"/>
          </admst:otherwise>
        </admst:choose>
        <admst:apply-templates select="forblock" match="modify"/>
        <admst:value-to test="[forblock/#modifys=1]" select="#modifys|(condition|update)/#modifys|(condition|update/rhs)/($lhs|variable)/#modifys" path="1"/>
        <admst:value-to test="[forblock/#modifyd=1]" select="#modifyd|(condition|update)/#modifyd|(condition|update/rhs)/($lhs|variable)/#modifyd" path="1"/>
        <admst:value-to test="[forblock/#modifyn=1]" select="#modifyn|(condition|update)/#modifyn|(condition|update/rhs)/($lhs|variable)/#modifyn" path="1"/>
        <admst:value-to test="[forblock/#modifyc=1]" select="#modifyc|(condition|update)/#modifyc|(condition|update/rhs)/($lhs|variable)/#modifyc" path="1"/>
        <admst:apply-templates select="forblock" match="modify"/>
      </admst:when>
      <admst:when test="[datatypename='case']">
        <admst:apply-templates select="caseitem/code" match="modify"/>
        <admst:for-each select="caseitem">
          <admst:value-to test="[code/#modifys=1 and defaultcase='no']" select="#modifys|condition/#modifys|condition/@variable/#modifys" path="1"/>
          <admst:value-to test="[code/#modifyd=1 and defaultcase='no']" select="#modifyd|condition/#modifyd|condition/@variable/#modifyd" path="1"/>
          <admst:value-to test="[code/#modifyn=1 and defaultcase='no']" select="#modifyn|condition/#modifyn|condition/@variable/#modifyn" path="1"/>
          <admst:value-to test="[code/#modifyc=1 and defaultcase='no']" select="#modifyc|condition/#modifyc|condition/@variable/#modifyc" path="1"/>
        </admst:for-each>
        <admst:value-to test="caseitem[#modifys=1]" select="#modifys|case/@variable/#modifys" path="1"/>
        <admst:value-to test="caseitem[#modifyd=1]" select="#modifyd|case/@variable/#modifyd" path="1"/>
        <admst:value-to test="caseitem[#modifyn=1]" select="#modifyn|case/@variable/#modifyn" path="1"/>
        <admst:value-to test="caseitem[#modifyc=1]" select="#modifyc|case/@variable/#modifyc" path="1"/>
      </admst:when>
      <admst:when test="[datatypename='assignment']">
        <admst:choose>
          <admst:when test="[lhs/datatypename='array']">
            <admst:variable name="lhs" path="lhs/variable"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="lhs" path="lhs"/>
          </admst:otherwise>
        </admst:choose>
        <admst:value-to test="$lhs[exists(prototype/instance[#modifys=1])]" select="#modifys|rhs/#modifys|rhs/variable/#modifys" path="1"/>
        <admst:value-to test="$lhs[exists(prototype/instance[#modifyd=1])]" select="#modifyd|rhs/#modifys|rhs/variable/#modifyd" path="1"/>
        <admst:value-to test="$lhs[exists(prototype/instance[#modifyn=1])]" select="#modifyn|rhs/#modifys|rhs/variable/#modifyn" path="1"/>
        <admst:value-to test="$lhs[exists(prototype/instance[#modifyc=1])]" select="#modifyc|rhs/#modifys|rhs/variable/#modifyc" path="1"/>
        <admst:value-to test="$lhs/ddxprobe" select="#ddxprobe" string="yes"/>
        <admst:push into="rhs/variable/ddxprobe" select="$lhs/ddxprobe" onduplicate="ignore"/>
      </admst:when>
      <admst:when test="[datatypename='contribution']">
        <admst:choose>
          <admst:when test="[#fixmedynamic=1]">
            <admst:value-to select="#modifyd|(lhs|rhs|rhs/variable)/#modifyd" path="1"/>
          </admst:when>
          <admst:when test="[#fixmeflickernoise=1]">
            <admst:value-to select="flickernoise|lhs/flickernoise" string="yes"/>
            <admst:value-to select="#modifyn|(lhs|rhs|rhs/variable)/#modifyn" path="1"/>
          </admst:when>
          <admst:when test="[#fixmewhitenoise=1]">
            <admst:value-to select="whitenoise|lhs/whitenoise" string="yes"/>
            <admst:value-to select="#modifyn|(lhs|rhs|rhs/variable)/#modifyn" path="1"/>
          </admst:when>
          <admst:otherwise>
            <admst:value-to select="#modifys|(lhs|rhs|rhs/variable)/#modifys" path="1"/>
          </admst:otherwise>
        </admst:choose>
      </admst:when>
      <admst:when test="[datatypename='blockvariable']">
      </admst:when>
      <admst:when test="[datatypename='nilled']"/>
      <admst:when test="[datatypename='callfunction']">
        <admst:value-to select="#modifyc|function/arguments/variable/#modifyc" path="1"/>
      </admst:when>
      <admst:otherwise><admst:fatal format="%(datatypename): case not handled\n"/></admst:otherwise>
    </admst:choose>
  </admst:template>
  <admst:apply-templates select="analog/code" match="modify"/>
  <admst:push into="@analogitems" select="assignment|assignment/rhs|contribution|contribution/rhs|block|forloop|whileloop|case|callfunction|conditional|conditional/if"/>
  <admst:value-to select="@analogitems[#modifys=1 or #modifyn=1 or #modifyc=1]/static" string="yes"/>
  <admst:value-to select="@analogitems[#modifys!=1 and #modifyn!=1 and #modifyc!=1]/dynamic" string="yes"/>

  <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifys=1])]/#modifys" path="1"/>
  <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifyd=1])]/#modifyd" path="1"/>
  <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifyn=1])]/#modifyn" path="1"/>
  <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifyc=1])]/#modifyc" path="1"/>

  <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifys=1 or #modifyd=1 or #modifyn=1])]/insource" string="yes"/>
  <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifys=1 or #modifyn=1 or #modifyc=1])]/static" string="yes"/>
  <admst:value-to select="(.|blockvariable)/variable[exists(instance[#modifyd=1])]/dynamic" string="yes"/>
  <admst:value-to select="source[#modifys=1 or #modifyn=1]/static" string="yes"/>
  <admst:value-to select="source[#modifyd=1]/dynamic" string="yes"/>

  <!-- jacobian -->
  <admst:for-each select="contribution">
    <admst:variable name="mycontribution" path="."/>
    <admst:variable name="mysource" path="lhs"/>
    <admst:push into="$mysource/attribute" select="attribute"/>
    <!-- case I() <+ .V(). -->
    <admst:for-each select="rhs/probe[(nature=discipline/potential)and($mysource/nature=$mysource/discipline/flow)]">
      <admst:new datatype="jacobian" inputs="module,$mysource/branch/pnode,branch/pnode">
        <admst:push into="/@jacobian" select="." onduplicate="ignore"/>
      </admst:new>
      <admst:new test="branch/nnode[grounded='no']" datatype="jacobian" inputs="module,$mysource/branch/pnode,branch/nnode">
        <admst:push into="/@jacobian" select="." onduplicate="ignore"/>
      </admst:new>
      <admst:new test="$mysource/branch/nnode[grounded='no']" datatype="jacobian" inputs="module,$mysource/branch/nnode,branch/pnode">
        <admst:push into="/@jacobian" select="." onduplicate="ignore"/>
        <admst:new test="../branch/nnode[grounded='no']" datatype="jacobian" inputs="module,$mysource/branch/nnode,../branch/nnode">
          <admst:push into="/@jacobian" select="." onduplicate="ignore"/>
        </admst:new>
      </admst:new>
      <admst:for-each select="/reverse(@jacobian)">
        <admst:choose>
          <admst:when test="module/jacobian[row=../../row and column=../../column]">
            <admst:variable name="jacobian" path="module/jacobian[row=../../row and column=../../column]"/>
          </admst:when>
          <admst:otherwise>
            <admst:variable name="jacobian" path="."/>
            <admst:value-to select="[row=column]/diagonal" string="yes"/>
            <admst:push into="module/jacobian" select="."/>
          </admst:otherwise>
        </admst:choose>
        <admst:value-to test="$mycontribution[dynamic='yes']" select="$jacobian/dynamic" string="yes"/>
        <!-- XXX Original logic, however this leaves out terms in psp104.
            Omitting the dynamic=no test gives precisely the correct
            result is that case.  This seems to be related to the
            unique internal I(noi) branch, I don't see this issue
            anywhere else.
        <admst:value-to test="$mycontribution[dynamic='no']" select="$jacobian/static" string="yes"/>
        -->
        <admst:value-to select="$jacobian/static" string="yes"/>
        <!-- XXX debug
        <admst:warning format="$mycontribution %($mycontribution/dynamic)  %($jacobian/static) %($jacobian/dynamic)\n"/>
        -->
      </admst:for-each>
      <admst:value-to select="/@jacobian"/>
    </admst:for-each>
  </admst:for-each>
  <admst:reverse select="jacobian"/>
</admst:template>

<admst:template match="adms.implicit.xml.nature">
  <admst:reverse select="/argv|/discipline|/nature"/>
  <admst:for-each select="/nature">
    <admst:value-to select="ddt_nature" path="/nature[name='%(../../ddt_name)']"/>
    <admst:value-to select="idt_nature" path="/nature[name='%(../../idt_name)']"/>
  </admst:for-each>
</admst:template>

<admst:template match="adms.implicit.xml">
  <admst:apply-templates select="." match="adms.implicit.xml.nature"/>
  <admst:apply-templates select="/module" match="adms.implicit.xml.module"/>
</admst:template>

<!-- Call Whiteley Research extensions -->
<!-- Split up contributions, so that each contribution will be "pure". -->
<admst:apply-templates select="module" match="split_contrib"/>
<!-- Support ddx calls where the first argument is an expression. -->
<admst:apply-templates select="module" match="eddx_fix"/>

<admst:apply-templates select="." match="adms.implicit.xml"/>

<!--admst:sendmail>
  <admst:subject>automatic mailing from %(/simulator/fullname)</admst:subject>
  <admst:arguments recipient="%(/simulator/fullname)"/>
  <admst:to recipient="r29173@freescale.com"/>
  <admst:message>
  </admst:message>
</admst:sendmail-->

</admst>
