
!!  ---------------------------------------------------------------
!!  Xic/WRspice Help System Database
!!  $Id: spOpRangeAnal.hlp,v 1.9 2015/11/03 05:24:27 stevew Exp $
!!  Copyright (C) Whiteley Research Inc. 2003.  All Rights Reserved
!!  ---------------------------------------------------------------

!!TAG WRspice
!! This file in sync with manual.

!!KEYWORD
spOpRangeAnal.hlp
!!TITLE
spOpRangeAnal.hlp
!!HTML 

!!SUBTOPICS
marganal
oprng_analysis
oprngfile 
monte
atomic
optimize


!! margin.tex 012709
!!KEYWORD
marganal
!!TITLE
Circuit Margin Analysis
!!HTML
    <i>WRspice</i> has provision for automated operating range and
    Monte Carlo analysis.  Both types of analysis perform repeated
    simulation runs with varying parameters, and record whether or not
    the circuit "worked" with that parameter set.  Writing the code
    that tests whether the circuit is functioning properly or not is
    probably the major challenge in applying these analyses.  It is
    usually helpful to have a thorough understanding of how the
    circuit behaves before performing margin analysis.  The margin
    analysis is one of the later steps in circuit design.

    <p>
    Both types of margin analysis can use a file format which contains
    the SPICE deck plus executable statements.  There are actually two
    formats recognized, one for compatibility with the JSPICE3
    program, and a new format particular to <i>WRspice</i>.  Use of
    one of these formats is the most straightforward method of
    initiating margin analysis, however there are short-cuts and hooks
    for more advanced users.  The scripting capability is a powerful
    tool, and in general allows much tedium to be automated.
!!LATEX marganal margin.tex
{\WRspice} has provision for automated operating range and Monte Carlo
analysis.  Both types of analysis perform repeated simulation runs
with varying parameters, and record whether or not the circuit
``worked'' with that parameter set. Writing the code that tests
whether the circuit is functioning properly or not is probably the
major challenge in applying these analyses.  It is usually helpful
to have a thorough understanding of how the circuit behaves before
performing margin analysis.  The margin analysis is one of the later
steps in circuit design.

Both types of margin analysis can use a file format which contains the
SPICE deck plus executable statements.  There are actually two formats
recognized, one for compatibility with the JSPICE3 program, and a new
format particular to {\WRspice}.  Use of one of these formats is the
most straightforward method of initiating margin analysis, however
there are short-cuts and hooks for more advanced users.  The scripting
capability is a powerful tool, and in general allows much tedium to be
automated.

!!SUBTOPICS
oprng_analysis
monte
atomic
optimize

!! margin.tex 032520
!!KEYWORD
oprng_analysis
!!TITLE
Operating Range Analysis
!!HTML 
    In operating range analysis, a suitably configured source file
    containing a circuit description is evaluated over a two
    dimensional area of parameter space, producing an output file
    describing a true/false result at each evaluated point.  The
    algorithm and implementation are designed to be as efficient as
    possible to speed execution.  Results can be viewed graphically
    during or after simulation.

    <p>
    As with conventional circuit and command files, operating range
    analysis files can be sourced by simply typing in the file name. 
    If the file name happens to conflict with a <i>WRspice</i>
    command, then the file can be input with the <a
    href="source"><b>source</b></a> command by typing
    <blockquote>
    <tt>source</tt> <i>filename</i>
    </blockquote>
    In <a href="batchmode">batch mode</a>, the operating range
    analysis is performed immediately.  Otherwise, actual operating
    range analysis is performed with the <a
    href="check"><b>check</b></a> command.  In batch mode, the
    <b>check</b> command is run automatically, if the file has certain
    properties to be described.

    <p>
    In order to initiate margin analysis with the <b>check</b>
    command, the current circuit must be from a margin analysis file,
    or have appropriate bound codeblocks.  Every circuit suitable for
    margin analysis must have a control block which contains a shell
    routine which will evaluate the circuit variables and establish
    whether or not the operation is correct.  If operation is
    incorrect, a vector named "<tt>checkFAIL</tt>" must be set to a
    non-zero value.  Alternatively, the script can return the value 1
    to indicate trial failure.  These control statements can be
    supplied in the circuit file in a block initiated with a
    <tt>.control</tt> line and ending with a <tt>.endc</tt> line, or
    through another file added as a codeblock and bound to the
    "controls" of the circuit, through use of the <a
    href="codeblock"><b>codeblock</b></a> command.

    <p>
    A second block of statements, the "header" or "exec" block, is
    typically required, though it is not an error if none is provided. 
    This block provides initializing statements, and is executed at
    the start of operating range analysis, or at the start of each
    trial in <a href="monte">Monte Carlo</a> analysis.  This block can
    be provided in the circuit file within an <tt>.exec</tt> and an
    <tt>.endc</tt> line, or can be a bound codeblock, bound to the
    "execs" of the circuit.

    <p>
    Monte Carlo analysis files differ from operating range files only
    in the header or <tt>.exec</tt> lines (or header codeblock). 
    During Monte Carlo analysis, the header block is executed before
    every simulation so that variables can be updated.  In operating
    range analysis variables are initialized by the header block only
    once, at the start of analysis.

    <p>
    If the circuit has a line with the characters <tt>.monte</tt>,
    then Monte Carlo analysis is assumed, and the -m option to the
    <b>check</b> command is unnecessary.  Similarly, a <tt>.checkall</tt>
    line will imply the checking of all points in operating range
    analysis, making the -a option to the <b>check</b> command unnecessary. 
    A line containing the characters <tt>.check</tt> will indicate
    (the default) operating range analysis.  One of these lines must
    appear if the file is to be analyzed in batch mode.  These lines
    also suppress the automatic execution of the <tt>.exec</tt> lines
    and the <tt>.control</tt> lines as the file is sourced (the
    <tt>.exec</tt> lines are actually executed, but no vectors are
    saved, to enable correct shell variable expansion).  A line
    containing the string <tt>.noexec</tt> appearing in the circuit
    file will have the same effect.

    <p>
    There are a number of vectors with defined names which control
    operating range and Monte Carlo analysis.  In addition, there are
    relevant shell variables.  The vectors created for use in an
    analysis run are assigned to a plot structure created for the
    analysis.  This plot becomes the current plot after the analysis
    starts.  These vectors are usually set in the header
    (<tt>.exec</tt>) block, unless the defaults are used.  They can
    also be set by hand, or under the control of another script, if
    the current plot is the <tt>constants</tt> plot, before starting
    the analysis.  The pre-named vectors are as follows:

    <dl>
    <dt><tt>checkPNTS</tt> (real, length >= 1)<dd>
    These are the points of the scale variable (e.g., <tt>time</tt> in
    transient analysis) at which the pass/fail test is applied.  If a
    fail is encountered, the simulation is stopped and the next trial
    started.  If not specified, the pass/fail test is applied after
    the trial is finished.  The <tt>checkPNTS</tt> vector is usually
    set in the header to a list of values with the <a
    href="compose"><b>compose</b></a> command.
    </dl>

    <dl>
    <dt><tt>checkVAL1</tt> (real, length 1)<dd>
    This is the initial central value of the first parameter to be
    varied during operating range analysis.  It is not used in Monte
    Carlo analysis.
    </dl>

    <dl>
    <dt><tt>checkDEL1</tt> (real, length 1)<dd>
    The first central value will be incremented or decremented by this
    value between trials in operating range analysis.  It is not used
    in Monte Carlo analysis.
    </dl>

    <dl>
    <dt><tt>checkSTP1</tt> (integer, length 1)<dd>
    This is the number of trials above and below the central value. 
    In Monte Carlo analysis, it partially specifies the number of
    simulation runs to perform, and specifies the X-axis of the visual
    array used to monitor progress (with the <a
    href="mplot"><b>mplot</b></a> command).  In operating range
    analysis, the default is zero.  In Monte Carlo analysis, the
    default is 3.
    </dl>

    <dl>
    <dt><tt>checkVAL2 checkDEL2 checkSTP2</tt><dd>
    These are as above, but relate to the second parameter to be
    varied in the circuit in operating range analysis.  In Monte Carlo
    analysis, only <tt>checkSTP2</tt> is used, in a manner analogous
    to <tt>checkSTP1</tt>.  The total number of simulations in Monte
    Carlo analysis is (2*<tt>checkSTP1</tt> + 1)*(2*<tt>checkSTP2</tt>
    + 1), the same as would be checked in operating range analysis. 
    The <tt>checkSTP2</tt> variable sets the number of cells in the
    Y-axis of the plot produced by <b>mplot</b>.
    </dl>

    <dl>
    <dt><tt>checkFAIL</tt>  (integer, length 1, 0 or nonzero)<dd>
    This is the global pass/fail flag, which is set after each trial,
    nonzero indicates failure.  This variable is used in both
    operating range and Monte Carlo analysis.  This variable is set by
    the code which evaluates the pass/fail criteria.
    </dl>

    <dl>
    <dt><tt>opmin1, opmax1</tt> (real, length >= 1)<dd>
    The operating range analysis can be directed to find the operating
    range extrema of the first parameter for each value of the second
    parameter.  These vectors contain the values found, and are
    automatically generated if the range finding feature is enabled. 
    They are not generated in Monte Carlo analysis.
    </dl>

    <dl>
    <dt><tt>opmin2, opmax2</tt> (real, length >= 1)<dd>
    The operating range analysis can be directed to find the operating
    range extrema of the second parameter for each value of the first
    parameter.  These vectors contain the values found, and are
    automatically generated if the range finding feature is enabled. 
    They are not generated in Monte Carlo analysis.
    </dl>

    <dl>
    <dt><tt>range, r_scale</tt> (real, length >= 1)<dd>
    If the range finder was active, these vectors are automatically
    created and added to the plot.  The <tt>range</tt> vector and its
    scale <tt>r_scale</tt> contain all of the extrema data, formatted
    in such a way that the path is the contour of the boundary of the
    pass region.  The <a href="plot"><b>plot</b></a> command can be
    used to display this contour by entering "<tt>plot range</tt>".
    </dl>

    <dl>
    <dt><tt>value</tt> (real, length variable)<dd>
    This vector can be used to pass trial values to the circuit,
    otherwise shell variables are used.  This pertains to operating
    range and Monte Carlo analysis.  The name of this vector can be
    redefined by setting a shell variable named "value" to a new name.
    </dl>

    <dl>
    <dt><tt>checkN1, checkN2</tt> (integer, length 1)<dd>
    These are the indices into the value array of the two parameters
    being varied in operating range analysis.  The other entries are
    fixed.  These vectors are not used if shell variables pass the
    trial values to the circuit, and are not used in Monte Carlo
    analysis.

    <p>
    The name of these vectors can be redefined by setting a shell
    variable of the same name ("checkN1" or "checkN2").  The value of
    this variable, if a non-numeric string token, is taken as the name
    of a vector containing the index.  If the variable is set to a
    positive integer, that integer will be taken as the index, and no
    vector is used.
    </dl>

    The shell variables are:

    <dl>
    <dt><tt>checkiterate</tt> (shell variable, integer 0-10)<dd>
    This is the binary search depth used in finding operating range
    extrema.  If not set or set to zero, the search is skipped.  The
    binary search is used to find the exact values of the operating
    region boundary, and has no relevance to the usual set of
    pass/fail outputs generated with the <b>check</b> command.  If
    nonzero, during operating range analysis and not in all-points
    mode, the extrema for each row and column are found, and saved in
    the <tt>opmin1</tt>, <tt>opmax1</tt>, <tt>opmin2</tt>, and
    <tt>opmax2</tt> vectors, which are then used to generate the
    <tt>range</tt> and <tt>r_scale</tt> vectors described above. 

    <p>
    If both of the input vectors <tt>checkSTP1</tt> and
    <tt>checkSTP2</tt> are unset or set to zero, the range finder
    behaves somewhat differently.  In this case, if the all-points
    mode is active, and the file is using an input "value" vector
    rather than shell variables for alterable parameters, then the
    range of each of these parameters is determined.  A masking
    facility allows some of these inputs to be skipped.  If the
    all-points mode is not set, the range for the two variables is
    found.  The range finder is described in more detail below.  The
    range finder is not used in Monte Carlo analysis, and the
    <tt>checkiterate</tt> variable is ignored in that case.
    </dl>

    <dl>
    <dt><tt>value1, value2</tt><dd>
    The <tt>value1</tt> and <tt>value2</tt> variables are set to the
    current trial values to be used in the circuit (parameters 1 and
    2).  The SPICE deck should reference these variables (as
    <tt>$value1</tt> and <tt>$value2</tt>) as the parameters to vary. 
    Alternatively, the vector <tt>value</tt> array can be used for
    this purpose.  These variables can be used in Monte Carlo
    analysis, but are not set implicitly.

    <p>
    Instead of using shell substitution and the
    <tt>value1</tt>/<tt>value2</tt> variables to set varying circuit
    parameters, one can use an internal parameter passing method
    which is probably more efficient.

    <p>
    The form, given before the analysis,
    <blockquote>
    <tt>set value1="%</tt><i>devicelist</i><tt>,</tt><i>paramlist</i><tt>"</tt>
    </blockquote>

    sets up a direct push into the named <i>parameters</i> of listed
    <i>devices</i>, avoiding shell expansion and vectors.  Note that
    the list must follow a magic '<tt>%</tt>' character, which tells
    the system to use the <i>devlist</i>,<i>paramlist</i> syntax, as
    used in the <a href="psetting"><b>sweep</b></a> command.

    <p>
    The <tt>jjoprng2.cir</tt> file in the examples illustrates use
    of this syntax.
    </dl>

    <p>
    If any of the shell variables <tt>value1</tt>, <tt>value2</tt>, or
    a <i>shell</i> variable named "value" are set to a string, then
    the shell variable or vector named in the string will have the
    same function as the assigned-to variable.  For example, if in the
    header one has "<tt>set value1 = C1</tt>", then the variable
    reference <tt>$C1</tt> would be used in the file to introduce
    variations, rather than <tt>$value1</tt>.  Similarly, if we have
    issued "<tt>set value = myvec</tt>", the vector <tt>myvec</tt>
    would contain values to vary (using the pointer vectors
    <tt>checkN1</tt> and <tt>checkN2</tt>), and a reference would have
    the form <tt>$&myvec[$&checkN1]</tt>).  Note that the alternate
    variables are not automatically defined before the circuit is
    parsed, so that they should be set to some value in the header. 
    The default <tt>$value1</tt> and <tt>$value2</tt> are predefined
    to zero.

    <p>
    The "checkN1" and "checkN2" names can also be set as a shell
    variable, the value of which if a positive integer will supply the
    index, or if a string token will redefine the name of the vector
    which provides the index.

    <p>
    The <tt>checkVAL1</tt>, <tt>checkDEL1</tt>, etc.  vectors to be
    used must be defined and properly initialized, either in the deck
    or directly from the shell, before analysis.

    <p>
    The operating range analysis sets the shell variables
    <tt>value1</tt> and <tt>value2</tt> to the variables being varied. 
    In addition, vector variables can be set.  This is needed for
    scripts such as optimization where the parameter to be varied is
    required to be under program control.  If a vector called
    <tt>value</tt> is defined, and a vector called <tt>checkN1</tt> is
    defined, and <tt>checkN1</tt> >= 0 and <tt>checkN1</tt> &#60 the
    length of value, then <tt>value[checkN1]</tt> is set to
    <tt>$value1</tt>.  Similarly, if a vector called <tt>value</tt> is
    defined, and a vector called <tt>checkN2</tt> is defined, and
    <tt>checkN2</tt> >= 0 and <tt>checkN2</tt> &#60 the length of value,
    then <tt>value[checkN2]</tt> is set to <tt>$value2</tt>.  Thus,
    instead of invoking <tt>$value1</tt> and <tt>$value2</tt> in the
    SPICE text, one can instead invoke <tt>$&value[$&checkN1]</tt>,
    <tt>$&value[$&checkN2]</tt>, where we have previously defined the
    vectors <tt>value</tt>, <tt>checkN1</tt>, <tt>checkN2</tt>.  Thus,
    the file could have a number of parameters set to
    <tt>$&value[0]</tt>, <tt>$&value[1]</tt>, ...  .  If
    <tt>checkN1</tt> is set to 2, for example, <tt>$&value[2]</tt>
    would be varied as parameter 1.  The unreferenced values would be
    fixed at predefined entries.  As mentioned above, the "value1",
    "value2", "value", "checkN1", and "checkN2" names can be redefined
    by assigning the name of a new variable to the shell variable name
    being reassigned, using the <a href="set"><b>set</b></a> command.

    <p>
    There are a number of ways to introduce the trial variations into
    the circuit.  Of these, we have explicitly identified shell
    variable and vector substitution.  Below is a review of these
    methods.

    <ol>
    <li>Perhaps the most direct method is to include the forms
    <tt>$value1</tt> and <tt>$value2</tt> (if two dimensional) for
    substitution in the current circuit.  The variables will be
    replaced by the appropriate numerical values before each trial, as
    for shell variable substitution.

    <p>
    <li>If a variable named "<tt>value1</tt>" is set to a string token
    with the <a href="set"><b>set</b></a> command, then a variable of
    the same name as the string token will hold the trial values,
    instead of <tt>value1</tt>.  The same applies to <tt>value2</tt>. 
    Thus, for example, if the circuit contains expansion forms of the
    variables <tt>foo1</tt> and <tt>foo2</tt> (i.e., <tt>$foo1</tt>
    and <tt>$foo2</tt>), one could perform an analysis using these
    variables by giving

    <blockquote>
      <tt>set value1 = foo1 value2 = foo2<br>
    </blockquote>

    <p>
    <li>The method above allows the SPICE <a
    href="options">options</a> to be set.  These are the built-in
    keywords, which can be set with the <b>set</b> command or in a
    <tt>.options</tt> line in an input file, which control or provide
    parameters to the simulation.

    <p>
    The most important example is temperature, using the <tt>temp</tt>
    option.  To include temperaure as one of the parameters to vary,
    one could provide, for example

    <blockquote>
      <tt>set value1=temp<br>
    </blockquote>

    <p>
    <li>If there are existing vectors named "<tt>checkN1</tt>" and (if
    two dimensions) "<tt>checkN2</tt>" that contain integer values,
    and the variable named "<tt>value</tt>" is set to the name of an
    existing vector (or a vector named "<tt>value</tt>" exists), then
    the vector components indexed by <tt>checkN1</tt> and
    <tt>checkN2</tt> will hold trial values, if within the size of the
    vector.  For example:

    <blockquote>
      <tt>let vec[10] = 0<br>
      let checkN1 = 5 checkN2 = 6<br>
      set value = vec<br>
    </blockquote>

    <p>
    The first line creates a vector named "<tt>vec</tt>" of size
    sufficient to contain the indices.  The iterated values will be
    placed in <tt>vec[5]</tt> and <tt>vec[6]</tt>.  The circuit should
    reference these values, either through shell substitution (e.g.,
    <tt>$&vec[5]</tt>) or directly as vectors.

    <p>
    Alternatively, a variable named "<tt>checkN1</tt>" can be set.  If
    the value of this variable is an integer, that integer will be
    used as the index.  If the variable is a name token, then the
    index will be supplied by a vector of the given name.  The same
    applies to <tt>checkN2</tt>.  The following example illustrates
    these alternatives:

    <blockquote>
      <tt>let vec[10] = 0<br>
      set checkN1 = 5<br>
      let foo = 6<br>
      set checkN2 = foo<br>
    </blockquote>

    <p>
    <li>Given that it is possible to set a vector as if a variable,
    by using the <b>set</b> command with the syntax

    <blockquote>
      <tt>set &</tt><i>vector</i> <tt>=</tt> <i>value</i>
    </blockquote>

    <p>
    it is possible to place trial values into vectors during analysis. 
    The form above is equivalent to

    <blockquote>
      <tt>let</tt> <i>vector</i> <tt>=</tt> <i>value</i>
    </blockquote>

    <p>
    Note, however, that the '<tt>&</tt>' character has special
    significance to the <i>WRspice</i> shell, so when this form if
    given on the command line the ampersand should be quoted, e.g., by
    preceding it with a backslash.

    <p>
    Thus, suppose that the circuit depends on a vector named
    <tt>delta</tt>.  One can set up trial substitution using this
    vector as

    <blockquote>
      <tt>set value1 = '&delta'<br>
    </blockquote>

    <p>
    <li>The construct above can be extended to "special" vectors,
    which enable device and model parameters to be set ahead of the
    next analysis.  These special vectors have the form

    <blockquote>
      <tt>@</tt><i>devname</i><tt>[</tt><i>param</i><tt>]</tt>
    </blockquote>

    where <i>devname</i> is the name of a device or model in the
    circuit, and <i>param</i> is one of the parameter keywords for the
    device or model.  These keywords can be listed with the <a
    href=show><b>show</b></a> command.

    <p>
    For example, if the circuit contains a MOS device <tt>m1</tt> one
    might have

    <blockquote>
      <tt>set value1 = '&@m1[w]'<br>
    </blockquote>

    This will perform the analysis while setting the <tt>m1</tt>
    <tt>w</tt> (device width) parameter as parameter 1.
    </ol>

    <p>
    The range is constructed by row, where columns represent different
    values for <tt>value1</tt>.  A second pass fills in concave
    contours in column order, thus the same pattern should be obtained
    independently of the parameter ordering.  Patterns with islands or
    reentrancy may not be displayed correctly.  The only way to make
    the algorithm completely foolproof is to check every point, which
    is achieved by giving the <tt>-a</tt> option to the <b>check</b>
    command, or by using <tt>.checkall</tt>.

    <p>
    During the analysis, a binary search can be employed to determine
    the actual values of the edges of the operating region.  This
    feature is enabled by setting the shell variable
    <tt>checkiterate</tt> to some value between 1 and 10.  This is the
    depth of the binary search used to find the endpoint.  A binary
    search will be performed during conventional operating range
    analysis only, and is skipped (other than in the exception noted
    below) if in all-points mode (<tt>-a</tt> flag or
    <tt>.checkall</tt> line given).  The search is skipped if there
    are no pass points in the row or column.  The computed values are
    stored in the <tt>opmin1</tt>, etc.  vectors, where the zeroth
    element corresponds to the lowest value of the fixed parameter. 
    For example, <tt>opmin1[0]</tt> is the minimum value of parameter
    1 when parameter 2 is value2 - steps2*delta2.  Entries of these
    vectors corresponding to points that were not found are zero.

    <p>
    The value to set for the <tt>checkiterate</tt> variable is a
    trade-off between accuracy and execution time.  If the boundary is
    found within the parameter range defined by the input vectors (and
    as plotted with the <b>mplot</b> command), the error is bounded by
    <i>delta</i>/2<sup>n</sup>, where <i>delta</i> is the appropriate
    <tt>checkDEL1</tt> or <tt>checkDEL2</tt> value, and n is the
    <tt>checkiterate</tt> value.  If the extremum is found outside of
    the given parameter space, the error may be
    <i>val</i>/2<sup>n</sup>, where <i>val</i> is the value at edge of
    the parameter space nearest the solution.

    <p>
    After an operating range analysis with range finding is complete,
    two new vectors, <tt>range</tt> and <tt>r_scale</tt>, are created
    from the <tt>opmin1</tt>, etc.  vectors and added to the current
    plot.  These vectors incorporate all of the nonzero entries in
    such a way that they form a path describing the boundary of the
    operating region, with <tt>range</tt> containing Y-data and
    <tt>r_scale</tt> containing X-data.  This contour can be displayed
    by plotting the range vector with the <b>plot</b> command.

    <p>
    The algorithm used the evaluate a row is shown below.  This is the
    normal algorithm; if the <tt>-a</tt> flag is given to the
    <b>check</b> command, or a <tt>.checkall</tt> line was found in
    the file, the points are simply stepped through, and no binary
    searching is done.

    <pre>
    for each value2 value {
    &#32;   start at left
    &#32;   value1 = central1 - delta1 * nsteps1
    &#32;   loop {
    &#32;       analyze
    &#32;       record point
    &#32;       if (pass) break
    &#32;       value1 = value1 + delta1
    &#32;       if (value1 > central1 + delta1 * nsteps1) break
    &#32;   }
    &#32;   if (pass)
    &#32;       do binary search for lower extremum
    &#32;   start at right
    &#32;   value1 = central1 + delta1 * nsteps1
    &#32;   loop {
    &#32;       analyze
    &#32;       record point
    &#32;       if (pass) break
    &#32;       value1 = value1 - delta1
    &#32;       if (value1 &#60; central1 - delta1 * nsteps1) break
    &#32;   }
    &#32;   if (pass)
    &#32;       do binary search for upper extremum
    }
    </pre>

    <p>
    If both <tt>checkSTP1</tt> and <tt>checkSTP2</tt> are zero or not
    defined, the range finder can have an additional operating mode. 
    This mode is made active if the all-points mode is active
    (<tt>-a</tt> option or <tt>.checkall</tt> given), and a vector is
    being used to supply trial values, rather than shell variables. 
    If a vector named "value" is defined, or a vector defined whose
    name is assigned to the shell variable named "value", the range of
    each of the components can be computed.  Note that the vector can
    have arbitrarily many entries, and each of these ranges can be
    found.  The range finding can be skipped for certain entries by
    defining a mask vector.  This is a vector with the same length as
    the "value" vector, and the same name as the <tt>value</tt> vector
    but suffixed with "<tt>_mask</tt>" as in "<tt>value_mask</tt>". 
    Each non-zero entry in the mask signifies that the corresponding
    variable in the <tt>value</tt> array will <i>not</i> be tested for
    range.  Additionally, any entry in the <tt>value</tt> vector which
    is zero will not be tested.  If no mask vector is defined, the
    range will be computed for all nonzero entries.  The results are
    placed, somewhat arbitrarily, in the <tt>opmin1</tt> and
    <tt>opmax1</tt> vectors, which will have lengths equal to that of
    the value <tt>vector</tt>.  Skipped entries will be zero.  No
    <tt>range</tt> vector will be produced, since it is not relevant
    in this mode.

    <p>
    If not in all-points mode, the range will be computed for the
    shell variables.  The <tt>opmin1</tt>, etc.  will contain the
    maximum and minimum values (length 1).  The <tt>range</tt> vector
    will contain the four points found.  Note that the central value
    must be a pass point in either of these modes, or the range
    finding is skipped.  There is no output file produced when both
    <tt>checkSTP1</tt> and <tt>checkSTP2</tt> are zero or undefined.

    <p>
    One can keep track of the progress of the analysis in two ways. 
    <i>WRspice</i> will print the analysis point on the screen, plus
    indicate whether the circuit failed or passed at the point, if the
    <tt>-v</tt> option is given to the <b>check</b> command.  Shell
    <b>echo</b> commands can be used in the executable blocks to
    provide more information on screen, and echoed output is printed
    whether or not <tt>-v</tt> is given.  The second method uses the
    <a href="mplot"><b>mplot</b></a> command, which graphically
    records the pass/fail points.  If "<tt>mplot -on</tt>" is given
    before the analysis, the results are plotted as simulation
    proceeds.

    <p>
    During operating range analysis, a file named
    <i>basename</i>.<tt>d</tt><i>xx</i> is created in the current
    directory, where <i>basename</i> is the base name of the input
    file, and <i>xx</i> is 00-99, set automatically to avoid
    clobbering existing files.  The output file name is stored in the
    <a href="mplot_cur"><tt>mplot_cur</tt></a> shell variable.

    <p>
    There is a special <a href="echof"><b>echof</b></a> command that
    allows text to be printed in the output file.  The <b>echof</b>
    command is used exactly as the <a href="echo"><b>echo</b></a>
    command.  If there is no output file open, the command returns
    with no action.  The <b>echof</b> command can be used in either
    <tt>.control</tt> or <tt>.exec</tt> blocks in the input file.
!!LATEX oprng_anal margin.tex
In operating range analysis, a suitably configured source file
containing a circuit description is evaluated over a two dimensional
area of parameter space, producing an output file describing a
true/false result at each evaluated point.  The algorithm and
implementation are designed to be as efficient as possible to speed
execution.  Results can be viewed graphically during or after
simulation.

\index{check command}
As with conventional circuit and command files, operating range
analysis files can be sourced by simply typing in the file name.  If
the file name happens to conflict with a {\WRspice} command, then the
file can be input with the {\cb source} command by typing
\begin{quote}
{\vt source} {\it filename}
\end{quote}
In batch mode, the operating range analysis is performed immediately. 
Otherwise, actual operating range analysis is performed with the {\cb
check} command (see \ref{checkcom}).  In batch mode, the {\cb check}
command is run automatically, if the file has certain properties to be
described.

In order to initiate margin analysis with the {\cb check} command, the
current circuit must be from a margin analysis file, or have
appropriate bound codeblocks.  Every circuit suitable for margin
analysis must have a control block which contains a shell routine
which will evaluate the circuit variables and establish whether or not
the operation is correct.  If operation is incorrect, a vector named
``{\et checkFAIL}'' must be set to a non-zero value.  Alternatively,
the script can return the value 1 to indicate trial failure.  These
control statements can be supplied in the circuit file in a block
initiated with a {\vt .control} line and ending with a {\vt .endc}
line, or through another file added as a codeblock and bound to the
``controls'' of the circuit, through use of the {\cb codeblock}
command.

\index{operating range files}
\index{.check line}
\index{.endc line}
A second block of statements, the ``header'' or ``exec'' block, is
typically required, though it is not an error if none is provided. 
This block provides initializing statements, and is executed at the
start of operating range analysis, or at the start of each trial in
Monte Carlo analysis.  This block can be provided in the circuit file
within an {\vt .exec} and an {\vt .endc} line, or can be a bound
codeblock, bound to the ``execs'' of the circuit.

\index{Monte Carlo analysis}
Monte Carlo analysis files differ from operating range files only in
the header or {\vt .exec} lines (or header codeblock).  During Monte
Carlo analysis, the header block is executed before every simulation
so that variables can be updated.  In operating range analysis
variables are initialized by the header block only once, at the start
of analysis.

\index{.monte line}
If the circuit has a line with the characters {\vt .monte}, then Monte
Carlo analysis is assumed, and the {\vt -m} option to the {\cb check}
command is unnecessary.  Similarly, a {\vt .checkall} line will imply
the checking of all points in operating range analysis, making the
{\vt -a} option to the check command unnecessary.  A line containing
the characters {\vt .check} will indicate (the default) operating
range analysis.  One of these lines must appear if the file is to be
analyzed in batch mode.  These lines also suppress the automatic
execution of the {\vt .exec} lines and the {\vt .control} lines as the
file is sourced (the {\vt .exec} lines are actually executed, but no
vectors are saved, to enable correct shell variable expansion).  A
line containing the string {\vt .noexec} appearing in the circuit file
will have the same effect.

There are a number of vectors with defined names which control
operating range and Monte Carlo analysis.  In addition, there are
relevant shell variables.  The vectors created for use in an analysis
run are assigned to a plot structure created for the analysis.  This
plot becomes the current plot after the analysis starts.  These
vectors are usually set in the header ({\vt .exec}) block, unless the
defaults are used.  They can also be set by hand, or under the control
of another script, if the current plot is the {\vt constants} plot,
before starting the analysis.  The pre-named vectors are as follows:

\begin{description}
\item{\et checkPNTS} (real, length $>= 1$)\\
\index{operating range analysis!checkPNTS}
These are the points of the scale variable (e.g., {\et time} in
transient analysis) at which the pass/fail test is applied.  If a fail
is encountered, the simulation is stopped and the next trial started. 
If not specified, the pass/fail test is applied after the trial is
finished.  The {\et checkPNTS} vector is usually set in the header
to a list of values with the {\cb compose} command.

\item{\et checkVAL1} (real, length 1)\\
\index{operating range analysis!checkVAL1}
This is the initial central value of the first parameter to be varied
during operating range analysis.  It is not used in Monte Carlo
analysis.

\item{\et checkDEL1} (real, length 1)\\
\index{operating range analysis!checkDEL1}
The first central value will be incremented or decremented by this
value between trials in operating range analysis.  It is not used in
Monte Carlo analysis.

\item{\et checkSTP1} (integer, length 1)\\
\index{operating range analysis!checkSTP1}
This is the number of trials above and below the central value.  In
Monte Carlo analysis, it partially specifies the number of simulation
runs to perform, and specifies the X-axis of the visual array used
to monitor progress (with the {\cb mplot} command).  In operating
range analysis, the default is zero.  In Monte Carlo analysis, the
default is 3.

\item{\et checkVAL2 checkDEL2 checkSTP2}\\
\index{operating range analysis!checkVAL2}
\index{operating range analysis!checkDEL2}
\index{operating range analysis!checkSTP2}
These are as above, but relate to the second parameter to be varied in
the circuit in operating range analysis.  In Monte Carlo analysis,
only {\et checkSTP2} is used, in a manner analogous to {\et
checkSTP1}.  The total number of simulations in Monte Carlo analysis
is {\vt (2*checkSTP1 + 1)*(2*checkSTP2 + 1)}, the same as would be
checked in operating range analysis.  The {\et checkSTP2} variable sets
the number of cells in the Y-axis of the plot produced by {\cb mplot}.

\item{\et checkFAIL}  (integer, length 1, 0 or nonzero)\\
\index{operating range analysis!checkFAIL}
This is the global pass/fail flag, which is set after each trial, nonzero
indicates failure.  This variable is used in both operating range and
Monte Carlo analysis.  This variable is set by the code which evaluates
the pass/fail criteria.

\item{\et opmin1, opmax1} (real, length $>= 1$)\\
\index{operating range analysis!opmin1}
\index{operating range analysis!opmax1}
The operating range analysis can be directed to find the operating
range extrema of the first parameter for each value of the second
parameter.  These vectors contain the values found, and are automatically
generated if the range finding feature is enabled.  They are not generated
in Monte Carlo analysis.

\item{\et opmin2, opmax2} (real, length $>= 1$)\\
\index{operating range analysis!opmin2}
\index{operating range analysis!opmax2}
The operating range analysis can be directed to find the operating
range extrema of the second parameter for each value of the first
parameter.  These vectors contain the values found, and are automatically
generated if the range finding feature is enabled.  They are not generated
in Monte Carlo analysis.

\item{\et range, r\_scale} (real, length $>= 1$)\\
\index{operating range analysis!range}
\index{operating range analysis!r\_scale}
If the range finder was active, these vectors are automatically
created and added to the plot.  The {\et range} vector and its scale
{\et r\_scale} contain all of the extrema data, formatted in such a
way that the path is the contour of the boundary of the pass region. 
The {\cb plot} command can be used to display this contour by entering
``{\vt plot range}''.

\item{\et value} (real, length variable)\\
\index{operating range analysis!value}
This vector can be used to pass trial values to the circuit, otherwise
shell variables are used.  This pertains to operating range and Monte
Carlo analysis.  The name of this vector can be redefined by setting
a shell variable named ``value'' to a new name.

\item{\et checkN1, checkN2} (integer, length 1)\\
\index{operating range analysis!checkN1}
\index{operating range analysis!checkN2}
These are the indices into the {\et value} array of the two parameters being
varied in operating range analysis.  The other entries are fixed. 
These vectors are not used if shell variables pass the trial values to
the circuit, and are not used in Monte Carlo analysis.

The name of these vectors can be redefined by setting a shell variable
of the same name (``checkN1'' or ``checkN2'').  The value of this
variable, if a non-numeric string token, is taken as the name of a
vector containing the index.  If the variable is set to a positive
integer, that integer will be taken as the index, and no vector is
used.

\end{description}

The shell variables are:

\begin{description}
\item{\et checkiterate} (integer 0-10)\\
\index{operating range analysis!checkiterate}
\index{checkiterate variable}
This sets the binary search depth used in finding operating range
extrema.  If not set or set to zero, the search is skipped.  The
binary search is used to find the exact values of the operating region
boundary, and has no relevance to the usual set of pass/fail outputs
generated with the {\cb check} command.  If nonzero, during operating
range analysis and {\it not} in all-points mode, the extrema for each
row and column are found, and saved in the {\et opmin1}, {\et opmax1},
{\et opmin2}, and {\et opmax2} vectors, which are then used to
generate the {\et range} and {\et r\_scale} vectors described above.

If both of the input vectors {\et checkSTP1} and {\et checkSTP2} are
unset or set to zero, the range finder behaves somewhat differently. 
In this case, if the all-points mode is active, and the file is using
an input ``value'' vector rather than shell variables for alterable
parameters, then the range of each of these parameters is determined. 
A masking facility allows some of these inputs to be skipped.  If the
all-points mode is not set, the range for the two variables is found. 
The range finder is described in more detail below.  The range finder
is not used in Monte Carlo analysis, and the {\et checkiterate}
variable is ignored in that case.

\item{\et value1, value2}\\
\index{operating range analysis!value1}
\index{operating range analysis!value2}
The {\et value1} and {\et value2} variables are set to the current
trial values to be used in the circuit (parameters 1 and 2).  The
SPICE deck should reference these variables (as {\vt \$value1} and
{\vt \$value2}) as the parameters to vary.  Alternatively, the {\it
vector} {\et value} array can be used for this purpose.  These
variables can be used in Monte Carlo analysis, but are not set
implicitly.

Instead of using shell substitution and the {\vt value1}/{\vt value2}
variables to set varying circuit parameters, one can use an internal
parameter passing method which is probably more efficient.
 
The form, given before the analysis,
\begin{quote}
{\vt set value1="\%}{\it devicelist\/}{\vt ,}{\it paramlist\/}{\vt "}
\end{quote}
sets up a direct push into the named {\it parameters} of listed {\it
devices}, avoiding shell expansion and vectors.  Note that the list
must follow a magic `{\vt \%}' character, which tells the system to
use the {\it devlist\/},{\it paramlist} syntax, as used in the {\cb
sweep} command (see \ref{psetting}).

The {\vt jjoprng2.cir} file in the examples illustrates use of this
syntax.

\end{description}

If any of the shell variables {\et value1}, {\et value2}, or a {\it
shell} variable named ``{\et value}'' are set to a string, then the
shell variable or vector named in the string will have the same
function as the assigned-to variable.  For example, if in the header
one has {\vt set value1 = C1}, then the variable reference {\vt \$C1}
would be used in the file to introduce variations, rather than {\vt
\$value1}.  Similarly, if we have issued {\vt set value = myvec}, the
vector {\et myvec} would contain values to vary (using the pointer
vectors {\et checkN1} and {\et checkN2}), and a reference would have
the form {\vt \$\&myvec[\$\&checkN1]}.  Note that the alternate
variables are not automatically defined before the circuit is parsed,
so that they should be set to some value in the header.  The default
{\vt \$value1} and {\vt \$value2} are predefined to zero.

The ``checkN1'' and ``checkN2'' names can also be set as a shell
variable, the value of which if a positive integer will supply the
index, or if a string token will redefine the name of the vector which
provides the index.

The {\et checkVAL1}, {\et checkDEL1}, etc. vectors to be used must be
defined and properly initialized, either in the deck or directly from
the shell, before analysis.

The operating range analysis sets the shell variables {\et value1} and
{\et value2} to the variables being varied.  In addition, vector
variables can be set.  This is needed for scripts such as optimization
where the parameter to be varied is required to be under program
control.  If a vector called {\et value} is defined, and a vector
called {\et checkN1} is defined, and {\vt checkN1 >= 0} and {\vt
checkN1 <} the length of {\et value}, then {\vt value[checkN1]} is set
to {\vt \$value1}.  Similarly, if a vector called {\et value} is
defined, and a vector called {\et checkN2} is defined, and {\vt
checkN2 >= 0} and {\vt checkN2 <} the length of {\et value}, then {\vt
value[checkN2]} is set to {\vt \$value2}.  Thus, instead of invoking
{\vt \$value1} and {\vt \$value2} in the SPICE text, one can instead
invoke {\vt \$\&value[\$\&checkN1], \$\&value[\$\&checkN2]}, where we
have previously defined the vectors {\et value}, {\et checkN1}, {\et
checkN2}.  Thus, the file could have a number of parameters set to
{\vt \$\&value[0], \$\&value[1], ...} .  If {\et checkN1} is set to 2,
for example, {\vt \$\&value[2]} would be varied as parameter 1.  The
unreferenced values would be fixed at predefined entries.  As
mentioned above, the ``{\et value1}'', ``{\et value2}'', ``{\et
value}'', ``{\et checkN1}'', and ``{\et chackN2}'' names can be
redefined by assigning the name of a new variable to the shell
variable name being reassigned, using the {\cb set} command.

There are a number of ways to introduce the trial variations into the
circuit.  Of these, we have explicitly identified shell variable and
vector substitution.  Below is a review of these methods.

\begin{enumerate}
\item{
Perhaps the most direct method is to include the forms {\vt \$value1}
and {\vt \$value2} (if two dimensional) for substitution in the
current circuit.  The variables will be replaced by the appropriate
numerical values before each trial, as for shell variable
substitution.
}

\item{
If a variable named ``{\vt value1}'' is set to a string token with the
{\cb set} command, then a variable of the same name as the string
token will hold the trial values, instead of {\vt value1}.  The same
applies to {\vt value2}.  Thus, for example, if the circuit contains
expansion forms of the variables {\vt foo1} and {\vt foo2} (i.e., {\vt
\$foo1} and {\vt \$foo2}), one could perform an analysis using these
variables by giving

\begin{quote}
{\vt set value1 = foo1 value2 = foo2}
\end{quote}
}
       
\item{
The method above allows the SPICE options to be set.  These are the
built-in keywords, which can be set with the {\cb set} command or in a
{\vt .options} line in an input file, which control or provide
parameters to the simulation.

The most important example is temperature, using the {\vt temp}
option.  To include temperaure as one of the parameters to vary, one
could provide, for example

\begin{quote}
{\vt set value1=temp}
\end{quote}
}

\item{
If there are existing vectors named ``{\vt checkN1}'' and (if two
dimensions) ``{\vt checkN2}'' that contain integer values, and the
variable named ``{\vt value}'' is set to the name of an existing
vector (or a vector named ``{\vt value}'' exists), then the vector
components indexed by {\vt checkN1} and {\vt checkN2} will hold trial
values, if within the size of the vector.  For example:

\begin{quote}
{\vt let vec[10] = 0}\\
{\vt let checkN1 = 5 checkN2 = 6}\\
{\vt set value = vec}
\end{quote}

The first line creates a vector named ``{\vt vec}'' of size sufficient
to contain the indices.  The iterated values will be placed in {\vt
vec[5]} and {\vt vec[6]}.  The circuit should reference these values,
either through shell substitution (e.g., {\vt \$\&vec[5]}) or directly
as vectors.

Alternatively, a variable named ``{\vt checkN1}'' can be set.  If the
value of this variable is an integer, that integer will be used as the
index.  If the variable is a name token, then the index will be
supplied by a vector of the given name.  The same applies to {\vt
checkN2}.  The following example illustrates these alternatives:

\begin{quote}
{\vt let vec[10] = 0}\\
{\vt set checkN1 = 5}\\
{\vt let foo = 6}\\
{\vt set checkN2 = foo}
\end{quote}
}

\item{
Given that it is possible to set a vector as if a variable, by using
the {\cb set} command with the syntax

\begin{quote}
{\vt set \&}{\it vector} {\vt =} {\it value}
\end{quote}

it is possible to place trial values into vectors during analysis. 
The form above is equivalent to

\begin{quote}
{\vt let} {\it vector} {\vt =} {\it value}
\end{quote}

Note, however, that the `{\vt \&}' character has special significance
to the {\WRspice} shell, so when this form if given on the command
line the ampersand should be quoted, e.g., by preceding it with a
backslash.

Thus, suppose that the circuit depends on a vector named {\vt delta}. 
One can set up trial substitution using this vector as

\begin{quote}
{\vt set value1 = '\&delta'}
\end{quote}
}

\item{
The construct above can be extended to ``special'' vectors,
which enable device and model parameters to be set ahead of the
next analysis.  These special vectors have the form

\begin{quote}
{\vt @}{\it devname\/}{\vt [}{\it param\/}{\vt ]}
\end{quote}

where {\it devname} is the name of a device or model in the circuit,
and {\it param} is one of the parameter keywords for the device or
model.  These keywords can be listed with the {\cb show} command.

For example, if the circuit contains a MOS device {\vt m1} one might
have

\begin{quote}
{\vt set value1 = '\&@m1[w]'}
\end{quote}

This will perform the analysis while setting the {\vt m1}
{\vt w} (device width) parameter as parameter 1.
}
\end{enumerate}

The range is constructed by row, where columns represent different values
for {\et value1}.  A second pass fills in concave contours in column
order, thus the same pattern should be obtained independently of the
parameter ordering.  Patterns with islands or reentrancy may not
be displayed correctly.  The only way to make the algorithm completely
foolproof is to check every point, which is achieved by giving the
{\vt -a} option to the {\cb check} command, or by using {\vt .checkall}.

\index{operating range analysis!finding endpoints}
During the analysis, a binary search can be employed to determine the
actual values of the edges of the operating region.  This feature is
enabled by setting the shell variable {\et checkiterate} to some value
between 1 and 10.  This is the depth of the binary search used to find
the endpoint.  A binary search will be performed during conventional
operating range analysis only, and is skipped (other than in the
exception noted below) if in all-points mode ({\vt -a} flag or {\vt
.checkall} line given).  The search is skipped if there are no pass
points in the row or column.  The computed values are stored in the
{\et opmin1}, etc. vectors, where the zeroth element corresponds to
the lowest value of the fixed parameter.  For example, {\vt opmin1[0]}
is the minimum value of parameter 1 when parameter 2 is value2 -
steps2*delta2.  Entries of these vectors corresponding to points that
were not found are zero.

The value to set for the {\et checkiterate} variable is a trade-off
between accuracy and execution time.  If the boundary is found within
the parameter range defined by the input vectors (and as plotted with
the {\cb mplot} command), the error is bounded by $delta/2^n$, where
{\it delta} is the appropriate {\et checkDEL1} or {\et checkDEL2}
value, and {\it n} is the {\et checkiterate} value.  If the extremum
is found outside of the given parameter space, the error may be
$val/2^n$, where {\it val} is the value at the edge of the parameter
space nearest the solution.

After an operating range analysis with range finding is complete, two
new vectors, {\et range} and {\et r\_scale}, are created from the {\et
opmin1}, etc. vectors and added to the current plot.  These vectors
incorporate all of the nonzero entries in such a way that they form a
path describing the boundary of the operating region, with {\et range}
containing Y-data and {\et r\_scale} containing X-data.  This contour
can be displayed by plotting the {\et range} vector with the {\cb
plot} command.

The algorithm used the evaluate a row is shown below.  This is the
normal algorithm; if the {\vt -a} flag is given to the {\cb check}
command, or a {\vt .checkall} line was found in the file, the points
are simply stepped through, and no binary searching is done.

{\raggedright
\qquad for each value2 value \{\\
\qquad\qquad start at left\\
\qquad\qquad value1 = central1 - delta1 * nsteps1\\
\qquad\qquad loop \{\\
\qquad\qquad\qquad analyze\\
\qquad\qquad\qquad record point\\
\qquad\qquad\qquad if (pass) break\\
\qquad\qquad\qquad value1 = value1 + delta1\\
\qquad\qquad\qquad if (value1 $>$ central1 + delta1 * nsteps1) break\\
\qquad\qquad \}\\
\qquad\qquad if (pass)\\
\qquad\qquad\qquad do binary search for lower extremum\\[2ex]
\qquad\qquad start at right\\
\qquad\qquad value1 = central1 + delta1 * nsteps1\\
\qquad\qquad loop \{\\
\qquad\qquad\qquad analyze\\
\qquad\qquad\qquad record point\\
\qquad\qquad\qquad if (pass) break\\
\qquad\qquad\qquad value1 = value1 - delta1\\
\qquad\qquad\qquad if (value1 $<$ central1 - delta1 * nsteps1) break\\
\qquad\qquad \}\\
\qquad\qquad if (pass)\\
\qquad\qquad\qquad do binary search for upper extremum\\
\qquad \}\\[2ex]}

If both {\et checkSTP1} and {\et checkSTP2} are zero or not defined,
the range finder can have an additional operating mode.  This mode is
made active if the all-points mode is active ({\vt -a} option or {\vt
.checkall} given), and a vector is being used to supply trial values,
rather than shell variables.  If a vector named ``value'' is defined,
or a vector defined whose name is assigned to the shell variable named
``value'', the range of each of the components can be computed.  Note
that the vector can have arbitrarily many entries, and each of these
ranges can be found.  The range finding can be skipped for certain
entries by defining a mask vector.  This is a vector with the same
length as the {\et value} vector, and the same name as the {\et value}
vector but suffixed with ``{\vt \_mask}'' as in {\et value\_mask}. 
Each non-zero entry in the mask signifies that the corresponding
variable in the {\et value} array will {\it not} be tested for range. 
Additionally, any entry in the {\et value} vector which is zero will
not be tested.  If no mask vector is defined, the range will be
computed for all nonzero entries.  The results are placed, somewhat
arbitrarily, in the {\et opmin1} and {\et opmax1} vectors, which will
have lengths equal to that of the {\et value} vector.  Skipped entries
will be zero.  No {\et range} vector will be produced, since it is not
relevant in this mode.

If not in all-points mode, the range will be computed for the shell
variables.  The {\et opmin1}, etc. will contain the maximum and
minimum values (length 1).  The {\et range} vector will contain the
four points found.  Note that the central value must be a pass point
in either of these modes, or the range finding is skipped.  There is
no output file produced when both {\et checkSTP1} and {\et checkSTP2}
are zero or undefined.

One can keep track of the progress of the analysis in two ways. 
{\WRspice} will print the analysis point on the screen, plus indicate
whether the circuit failed or passed at the point, if the {\vt -v}
option is given to the {\cb check} command.  Shell {\cb echo} commands
can be used in the executable blocks to provide more information on
screen, and echoed output is printed whether or not {\vt -v} is given. 
The second method uses the {\cb mplot} command, which graphically
records the pass/fail points.  If ``{\vt mplot -on}'' is given before
the analysis, the results are plotted as simulation proceeds.

During operating range analysis, a file named {\it basename\/}.{\vt
d}{\it xx} is created in the current directory, where {\it basename}
is the base name of the input file, and {\it xx} is 00--99, set
automatically to avoid clobbering existing files.  The output file
name is stored in the {\et mplot\_cur} shell variable.

There is a special {\cb echof} command that allows text to be printed
in the output file.  The {\cb echof} command is used exactly as the
{\cb echo} command.  If there is no output file open, the command
returns with no action.  The {\cb echof} command can be used in either
{\vt .control} or {\vt .exec} blocks in the input file.

!!SUBTOPICS
oprngfile
findrange
!!SEEALSO
analyses
marganal

!! margin.tex 040110
!!KEYWORD
oprngfile 
!!TITLE
Operating Range Input File Format
!!HTML  
    There are two recognized file formats which can be used as input
    for <a href="oprng_analysis">operating range</a> analysis.  One,
    the "old format", is retained for compatibility with an older
    version of SPICE.  <i>WRspice</i> recognizes a second "new format"
    which is more consistent with standard <i>WRspice</i> input file
    organization.  In both cases, the input file which specifies
    operating range analysis consists of three sections:

    <p>
    <ol>
    <li>an initializing header</br>
    <li>a body of control statements</br>
    <li>the circuit description
    </ol>

    <p>
    In the old format, the file must begin with a line containing only
    the string
    <blockquote>
      <tt>.check</tt>
    </blockquote>
    which is followed by shell commands.  The header block in the old
    format is terminated with a line containing only the string
    <blockquote>
      <tt>.control</tt>
    </blockquote>
    which also begins the control statement block.

    <p>
    In the new format, the first line of the file is taken to be a
    title line and is otherwise ignored, consistent with other types
    of input files for <i>WRspice</i>.  The header statements are found within
    a block which starts with a line containing only the string
    <blockquote>
      <tt>.exec</tt>
    </blockquote>
    and ends with a line containing only the string
    <blockquote>
      <tt>.endc</tt>
    </blockquote>
    in other words, a standard <a href=".exec"><tt>.exec</tt></a>
    block.  The comment prefix "*@" can also be used to enter header
    block text.  The new format file for margin analysis should also
    contain a line with only the string
    <blockquote>
      <tt>.check</tt>
    </blockquote>
    somewhere in the text.  Unlike the old format, the ordering of the
    <tt>.exec</tt> block and the <tt>.check</tt> line is unimportant.

    <p>
    The lines in the header block initialize internally defined
    variables.  The variables are those described as user-set,
    including the <tt>checkiterate</tt> shell variable.  Variables
    which are not used (such as those for variable 2 in a one
    dimensional case) can be ignored.

    <p>
    An example header is given below:

    <p>
    <pre></pre>
    Old format:
    <pre>
      .check
      compose checkPNTS values 50p 100p 150p 200p
      checkVAL1 = 12
      checkDEL1 = .5
      checkSTP1 = 5
      checkVAL2 = .5
      checkDEL2 = .1
      checkSTP2 = 2
    </pre>

    New format:
    <pre>
      * Title for this file
      .check
      .exec
      compose checkPNTS values 50p 100p 150p 200p
      checkVAL1 = 12
      checkDEL1 = .5
      checkSTP1 = 5
      checkVAL2 = .5
      checkDEL2 = .1
      checkSTP2 = 2
      .endc
    </pre>

    <p>
    The variables <tt>checkFAIL</tt>, <tt>checkSTP1</tt>, and
    <tt>checkSTP2</tt> are integers.  The other variables are real,
    except for <tt>checkPNTS</tt> which is a real vector.

    <p>
    The header block can also be supplied as a bound codeblock.  This
    is accomplished, for example, with the command
    <blockquote>
      <tt>codeblock -abe</tt> <i>filename</i>
    </blockquote>
    where <i>filename</i> is the name of a file which contains the
    statements to be used in the header block.  If an <tt>exec</tt>
    codeblock is bound to the circuit, the bound block is executed
    rather than any locally specified header block.

    <p>
    The control statement block is almost identical in the old and new
    formats.  In the old format, the control block immediately follows
    the header block, though in the new format this is not necessary. 
    The control statements are evaluated at each of the
    <tt>checkPNTS</tt>, and set the <tt>checkFAIL</tt> flag if the logic
    determines that the circuit run has failed.

    <p>
    This control block begins with a line containing only the string
    <blockquote>
      <tt>.control</tt>
    </blockquote>
    and ends with a line containing only
    <blockquote>
      <tt>.endc</tt>
    </blockquote>
    i.e., the standard form for a <i>WRspice</i> control block.

    <p>
    The enclosed lines are <i>WRspice</i> script statements that perform a
    logical comparison of circuit variables and set the <tt>checkFAIL</tt>
    variable accordingly.

    <p>
    The control block can also be supplied as a bound codeblock.  This
    is accomplished, for example, with the command
    <blockquote>
      <tt>codeblock -ab</tt> <i>filename</i>
    </blockquote>
    where <i>filename</i> is the name of a file which contains the
    statements to be used in the control block.  If a control
    codeblock is bound to the circuit, the bound block is executed
    rather than any locally specified control block.

    <p>
    In the old format, the circuit description starts immediately
    after the end of the control block, with the title line.  In the
    new format, the title line is the first line of the file, and the
    circuit description is by definition what is left after removing
    the <tt>.exec</tt> and <tt>.control</tt> blocks.

    <p>
    This circuit description section of the file consists of
    conventional <i>WRspice</i> format circuit description lines.  The
    parameters to be varied are replaced with <tt>$value1</tt> and
    <tt>$value2</tt>.  Alternatively, one can define a vector called
    value, and unit length vectors <tt>checkN1</tt> and
    <tt>checkN2</tt>.  Then, the parameters to be varied can be
    replaced with <tt>$&value[$&checkN1]</tt> and
    <tt>$&value[$&checkN2]</tt>.  During analysis, the
    <tt>$value1</tt> and <tt>$value2</tt> (and the value vector
    entries, if used) are replaced with the current values of the
    variables.

    <p>
    Note that in the circuit description, it is often useful to use the
    concatenation character % to add a suffix.  For examples, the file
    line might be
    <blockquote>
      <tt>v1 0 1 pulse (0 5m 10p ...)</tt>
    </blockquote>
    where we want to vary the "5m".  If the value of <tt>$value1</tt> is 5, one
    could replace this line with
    <blockquote>
      <tt>v1 0 1 pulse (0 $value1%m 10p ...)</tt>
    </blockquote>

    <p>
    Without the %, the variable substitution would fail. 
    Alternatively, one could set <tt>$value1</tt> to 5e-3, and not use
    the "m" suffix in the file.

    <p>
    The concatenation character can be set to a different character
    with the <a href="var_catchar"><tt>var_catchar</tt></a> variable. 
    If this variable is set to a string consisting of a single
    punctuation character, then that character becomes the
    concatenation character.
!!LATEX oprngfile margin.tex
\index{operating range analysis!file format}
There are two recognized file formats which can be used as input for
operating range analysis.  One, the ``old format'', is retained for
compatibility with an older version of SPICE.  {\WRspice} recognizes a
second ``new format'' which is more consistent with standard {\WRspice}
input file organization.  In both cases, the input file which
specifies operating range analysis consists of three sections:

\begin{enumerate}
\item an initializing header
\item a body of control statements
\item the circuit description
\end{enumerate}

%SU-------------------------------------
\subsection{Initializing Header}
In the old format, the file must begin with a line containing only the
string
\begin{quote}
{\vt .check}
\end{quote}
which is followed by shell commands.  The header block in the old format
is terminated with a line containing only the string
\begin{quote}
{\vt .control}
\end{quote}
which also begins the control statement block.

In the new format, the first line of the file is taken to be a title
line and is otherwise ignored, consistent with other types of input files
for {\WRspice}.  The header statements are found within a block which
starts with a line containing only the string
\begin{quote}
{\vt .exec}
\end{quote}
and ends with a line containing only the string
\begin{quote}
{\vt .endc}
\end{quote}
in other words, a standard {\vt .exec} block.  The comment prefix
{\vt *@} can also be used to enter header block text, as in described
in \ref{control}.  The new format file for margin analysis should also
contain a line with only the string
\begin{quote}
{\vt .check}
\end{quote}
somewhere in the text.  Unlike the old format, the ordering of the
{\vt .exec block} and the {\vt .check} line is unimportant.

The lines in the header block initialize internally defined variables.  The
variables are those listed above as user-set, including the
{\et checkiterate} shell variable.  Variables which are not used (such as
those for variable 2 in a one dimensional case) can be ignored.

An example header is given below:\\
\begin{quote}
Old format:\\
{\raggedright\vt
.check\\
compose checkPNTS values 50p 100p 150p 200p\\
checkVAL1 = 12\\
checkDEL1 = .5\\
checkSTP1 = 5\\
checkVAL2 = .5\\
checkDEL2 = .1\\
checkSTP2 = 2\\}
\end{quote}
\begin{quote}
New format:\\
{\raggedright\vt
* Title for this file\\
.check\\
.exec\\
compose checkPNTS values 50p 100p 150p 200p\\
checkVAL1 = 12\\
checkDEL1 = .5\\
checkSTP1 = 5\\
checkVAL2 = .5\\
checkDEL2 = .1\\
checkSTP2 = 2\\}
.endc\\
\end{quote}

The variables {\et checkFAIL}, {\et checkSTP1}, and {\et checkSTP2}
are integers.  The other variables are real, except for {\et
checkPNTS} which is a real vector.

The header block can also be supplied as a bound codeblock.
This is accomplished, for example, with the command
\begin{quote}\vt
codeblock -abe {\it filename}
\end{quote}
where {\it filename} is the name of a file which contains the
statements to be used in the header block.  If an {\vt .exec} codeblock
is bound to the circuit, the bound block is executed rather than any
locally specified header block.

%SU-------------------------------------
\subsection{Control Statements}
The control statement block is almost identical in the old and new
formats.  In the old format, the control block immediately follows the
header block, though in the new format this is not necessary.  The
control statements are evaluated at each of the {\et checkPNTS}, and
set the {\et checkFAIL} flag if the logic determines that the circuit
run has failed.

This control block begins with a line containing only the string
\begin{quote}
{\vt .control}
\end{quote}
and ends with a line containing only
\begin{quote}
{\vt .endc}
\end{quote}
i.e., the standard form for a {\WRspice} control block (see \ref{control}).

The enclosed lines are {\WRspice} script statements that perform a
logical comparison of circuit variables and set the {\et checkFAIL}
variable accordingly.

The control block can also be supplied as a bound codeblock.
This is accomplished, for example, with the command
\begin{quote}\vt
codeblock -ab {\it filename}
\end{quote}
where {\it filename} is the name of a file which contains the statements
to be used in the control block.  If a {\vt .control} codeblock is bound to
the circuit, the bound block is executed rather than any locally
specified control block.

%SU-------------------------------------
\subsection{Circuit Description}
In the old format, the circuit description starts immediately after the
end of the control block, with the title line.  In the new format, the
title line is the first line of the file, and the circuit description is
by definition what is left after removing the {\vt .exec} and {\vt .control}
blocks.

This circuit description section of the file consists of conventional
{\WRspice} format circuit description lines.  The parameters to be
varied are replaced with {\vt \$value1} and {\vt \$value2}. 
Alternatively, one can define a vector called {\et value}, and unit
length vectors {\et checkN1} and {\et checkN2}.  Then, the parameters
to be varied can be replaced with {\vt \$\&value[\$\&checkN1]} and
{\vt \$\&value[\$\&checkN2]}.  During analysis, the {\vt \$value1} and
{\vt \$value2} (and the value vector entries, if used) are replaced
with the current values of the variables.

\index{concatenation character}
Note that in the circuit description, it is often useful to use the
concatenation character {\vt \%} to add a suffix.  For examples, the file
line might be
\begin{quote}
{\vt v1 0 1 pulse (0 5m 10p ...)}
\end{quote}
where we want to vary the ``{\vt 5m}''.  If the value of {\vt \$value1}
is 5, one
could replace this line with
\begin{quote}
{\vt v1 0 1 pulse (0 \$value1\%m 10p ...)}
\end{quote}

Without the {\vt \%}, the variable substitution would fail.  Alternatively,
one could set {\vt \$value1} to 5e-3, and not use the ``{\vt m}'' suffix
in the file.

The concatenation character can be set to a different character with
the {\et var\_catchar} variable.  If this variable is set to a string
consisting of a single punctuation character, then that character
becomes the concatenation character.

!!SEEALSO
expressions

!! margin.tex 012709
!!KEYWORD
monte
!!TITLE
Monte Carlo Analysis
!!HTML
    <i>WRspice</i> has a built-in facility for performing Monte Carlo
    analysis, where one or more circuit variables are set according to
    a random distribution, and the circuit analyzed for functionality. 
    The file format and operation is very similar to <a
    href="oprng_analysis">operating range analysis</a>.

    <p>
    As in operating range analysis, a complete input file consists of
    three sections:  a header, an executable script analyzing
    operation, and the circuit deck.  Unlike operating range analysis,
    however, the header block is executed before every simulation run,
    so that circuit variables may be changed (not just initialized) in
    the header.  As in operating range analysis, an "old format" and a
    "new format" are recognized.  These formats are identical in Monte
    Carlo analysis, except that instead of a line containing the string
    <tt>.check</tt>, Monte Carlo files contain the keyword
    <tt>.monte</tt>.  This must be the first line of the file in the
    old format, but can appear anywhere in a new format file.  If both
    keywords appear in the file (not a good idea), then Monte Carlo
    analysis is assumed.

    <p>
    As with conventional circuit and command files, Monte Carlo
    analysis files can be sourced by simply typing in the file name. 
    If the file name happens to conflict with a command, then the file
    can be input with the <a href="source"><b>source</b></a> command. 
    If not in batch mode, the analysis is initiated with the <a
    href="check"><b>check</b></a> command, otherwise the analysis is
    performed immediately.

    <p>
    Monte Carlo analysis is enforced by supplying the <tt>-m</tt>
    option to the <b>check</b> command, which initiates analysis.  The
    <tt>-m</tt> option is only necessary if the input file does not
    contain a <tt>.monte</tt> line.  If the <tt>-r</tt> option is
    given, the simulations will be parceled out to remote servers,
    allowing parallelism in computation.

    <p>
    Output from a Monte Carlo run is saved in a file with base name
    that of the circuit, with a suffix "<tt>.m</tt><i>xx</i>", where
    <ii>xx</i> is a sequentially assigned number so as to make the
    file name unique.  The output file name is stored in the <a
    href="mplot_cur"><tt>mplot_cur</tt></a> shell variable.

    <p>
    The number of runs performed in Monte Carlo analysis is set by the
    <tt>checkSTP1</tt> and <tt>checkSTP2</tt> variables, as in
    operating range analysis.  The number of points will be
    (2*<tt>checkSTP1</tt> + 1)*(2*<tt>checkSTP2</tt> + 1).  If the
    values are not given, they default to 3 (49 points).

    <p>
    In Monte Carlo analysis, the header block is executed before each
    simulation.  In the header block, shell variables and vectors may
    be set for each new trial.  These variables and vectors can be
    used in the SPICE text to modify circuit parameters.  The names of
    the variables used, and whether to use vectors or variables, is up
    to the user (variables are a little more efficient).  Monte Carlo
    analysis does not use predefined names for parameter data. 
    Typically, the <a href="gauss"><tt>gauss</tt></a> function is
    used to specify a random value for the variables in the header
    block. 

    <p>
    It is possible to use <a href=".param"><tt>.param</tt></a> defines
    to introduce random values in Monte Carlo analysis, as well as
    shell variables and vectors.  Parameters defined in
    <tt>.param</tt> lines are recomputed at the start of each trial,
    before the <tt>.exec</tt> block is evaluated.  Random values can
    be set by calling the random number generation functions (<a
    href="unif"><tt>unif</tt></a>, <a href="aunif"><tt>aunif</tt></a>,
    <a href="gauss"><tt>gauss</tt></a>, <a
    href="agauss"><tt>agauss</tt></a>, <a
    href="limit"><tt>limit</tt></a>).
 
    <p>
    Parameters are visible in the <tt>.exec</tt> block if the
    <tt>.exec</tt> block is defined in the same file as the circuit
    (directly or through an <a href=".include"><tt>.include</tt></a>). 
    Parameters are <b>not</b> visible in the <tt>.control</tt> block. 
    Parameters are not visible in <a href="codeblock">bound
    codeblocks</a>.

    <p>
    There is a special <a href="echof"><b>echof</b></a> command that
    allows text to be printed in the output file.  This is the means
    by which the trial values are recorded, as there is no default
    recording mechanism.  The file by default records only the success
    or failure of each run.  The <b>echof</b> command is used exactly
    as the <a href="echo"><b>echo</b></a> command.  If there is no
    output file open, the command returns with no action.  The
    <b>echof</b> command can be used in either <tt>.control</tt> or
    <tt>.exec</tt> blocks in the input file.

    <p>
    Monte Carlo results can be viewed during analysis ar afterward
    with the <a href="mplot">mplot</a> command.  Giving "<tt>mplot
    -on</tt>" will display results while simulating, as in operating
    range analysis.  The display consists of 2*<tt>checkSTP1</tt> + 1
    X 2*<tt>checkSTP2</tt> + 1 squares, as in operating range
    analysis, with each square indicating pass or fail.  In Monte
    Carlo analysis, the squares are simply filled in in sequence, and
    their placement has nothing to do with the actual circuit values.
!!LATEX monte margin.tex
{\WRspice} has a built-in facility for performing Monte Carlo
analysis, where one or more circuit variables are set according to
a random distribution, and the circuit analyzed for functionality. 
The file formats and operation are very similar to operating range
analysis.

As in operating range analysis, a complete input file consists of
three sections: a header, an executable script analyzing operation,
and the circuit deck.  Unlike operating range analysis, however, the
header block is executed before every simulation run, so that circuit
variables may be changed (not just initialized) in the header.  As in
operating range analysis, an ``old format'' and a ``new format'' are
recognized.  These formats are identical in Monte Carlo analysis,
except that instead of a line containing the string {\vt .check}, Monte
Carlo files contain the keyword {\vt .monte}.  This must be the first
line of the file in the old format, but can appear anywhere in a new
format file.  If both keywords appear in the file (not a good idea),
then Monte Carlo analysis is assumed.

As with conventional circuit and command files, Monte Carlo analysis
files can be sourced by simply typing in the file name.  If the file
name happens to conflict with a command, then the file can be input
with the {\cb source} command.  If not in batch mode, the analysis is
initiated with the {\cb check} command, otherwise the analysis is
performed immediately.

\index{.monte line}
Monte Carlo analysis is enforced by supplying the {\vt -m} option to
the {\cb check} command, which initiates analysis.  The {\vt -m}
option is only necessary if the input file does not contain a {\vt
.monte} line.  If the {\vt -r} option is given, the simulations will
be parceled out to remote servers, allowing parallelism in
computation.

Output from a Monte Carlo run is saved in a file with base name that
of the circuit, with a suffix ``{\vt .m}{\it xx}'', where {\it xx} is
a sequentially assigned number so as to make the file name unique. 
The output file name is stored in the {\et mplot\_cur} shell variable.

The number of runs performed in Monte Carlo analysis is set by the
{\et checkSTP1} and {\et checkSTP2} variables, as in operating range
analysis.  The number of points will be {\vt (2*checkSTP1 +
1)*(2*checkSTP2 + 1)}.  If the values are not given, they default to 3
(49 points).

In Monte Carlo analysis, the header block is executed before each
simulation.  In the header block, shell variables and vectors may be
set for each new trial.  These variables and vectors can be used in
the SPICE text to modify circuit parameters.  The names of the
variables used, and whether to use vectors or variables, is up to the
user (variables are a little more efficient).  Monte Carlo analysis
does not use predefined names for parameter data.  Typically, the {\vt
gauss} function is used to specify a random value for the variables
in the header block.

It is possible to use {\vt .param} defines to introduce random values
in Monte Carlo analysis, as well as shell variables and vectors. 
Parameters defined in {\vt .param} lines are recomputed at the start
of each trial, before the {\vt .exec} block is evaluated.  Random
values can be set by calling the random number generation functions
({\vt unif}, {\vt aunif}, {\vt gauss}, {\vt agauss}, {\vt limit}).

Parameters are visible in the {\vt .exec} block if the {\vt .exec}
block is defined in the same file as the circuit (directly or through
an {\vt .include}).  Parameters are {\bf not} visible in the {\vt
.control} block.  Parameters are not visible in bound codeblocks.

\index{echof command}
There is a special {\cb echof} command that allows text to be
printed in the output file.  This is the means by which the trial
values are recorded, as there is no default recording mechanism. 
The file by default records only the success or failure of each run. 
The {\cb echof} command is used exactly as the {\cb echo} command. 
If there is no output file open, the command returns with no action. 
The {\cb echof} command can be used in either {\vt .control} or {\vt
.exec} blocks in the input file.

\index{mplot command}
Monte Carlo results can be viewed during analysis ar afterward with
the {\cb mplot} command.  Giving ``{\vt mplot -on}'' will display
results while simulating, as in operating range analysis.  The display
consists of {\vt (2*checkSTP1 + 1) * (2*checkSTP2 + 1)} squares, as in
operating range analysis, with each square indicating pass or fail. 
In Monte Carlo analysis, the squares are simply filled in in sequence,
and their placement has nothing to do with the actual circuit values.

!!SEEALSO
analyses
marganal

!! margin.tex 030419
!!KEYWORD
atomic
!!TITLE
Atomic Monte Carlo and Range Analysis
!!HTML 
    <font color=red>This is a very new capability under
    development.</font>

    <p>
    <i>WRspice</i> provides an interface to the primitive operations
    used for <a href="oprng_analysis">operating range</a> and <a
    href="monte">Monte Carlo</a> analysis.  This allows the user to
    write scripts to implement custom statistical analysis procedures. 
    The scripting is more flexible than the built-in analysis
    described elsewhere.

    <p>
    <font color=red>
    ADD HERE.
    </font>
!!LATEX atomic margin.tex
{\bf This is a very new capability under development.}

{\WRspice} provides an interface to the primitive operations used for
operating range and Monte Carlo analysis.  This allows the user to
write scripts to implement custom statistical analysis procedures. 
The scripting is more flexible than the built-in analysis described
elsewhere.

!!SEEALSO
analyses
marganal

!! margin.tex 012709
!!KEYWORD
optimize
!!TITLE
Circuit Margin Optimization
!!HTML 
    There are three scripts which implement a margin optimization
    algorithm used by Clark Hamilton at NIST.  These files (kept in
    the scripts directory) are <tt>optimize</tt>, <tt>margins</tt>,
    and <tt>merit</tt>.  The main script is <tt>optimize</tt>, which
    is invoked with the name of the file to be optimized as an
    argument.

    <p>
    This facility is for advanced users.  The present status of the
    scripts is unknown, and it is possible that they may require
    modification before use.  They are provided as an example of how
    the <i>WRspice</i> scripting facility can be employed for
    optimization.

    <p>
    An example input file, which defines and initializes various
    variables and vectors as well as providing a circuit to optimize,
    is shown below.  To perform optimization, one gives
    "<tt>optimize</tt> <i>filename</i>".

    <p>
    <pre>
    .check
    set checkiterate = 3
    let checkN1 = 0
    compose checkPNTS values 1n 2n
    let value[19] = 0
    let flags[19] = 0
    let flags[0] = 1
    let value[0] = .8
    .control
    if (TIME >= checkPNTS[0])
    &#32   checkFAIL = 0
    &#32   if ((abs(v(1)) > 1.5) or (abs(v(1)) &#60 .5))
    &#32       checkFAIL = 1
    &#32   endif
    endif
    .endc
    optimization test
    i1 0 1 pulse(0 1 0 1n)
    r1 1 0 $&value[0]
    .tran .01n 1.1n
    .end
    </pre>

    <p>
    This is the simplest way to input the file, alternatively one
    could set the shell variables and vectors externally and/or use a
    bound codeblock for pass/fail evaluation.

    <p>
    The <tt>margins</tt> script, called by <tt>optimize</tt> calls the
    <a href="check"><b>check</b></a> command.  The variable
    <tt>checkiterate</tt> must be set to a nonzero value up to 10. 
    This is the binary search depth for finding the operating range.

    <p>
    The vectors <tt>checkN1</tt> and <tt>value</tt> must be defined,
    <tt>checkN1</tt> is the index into the value array of the variable
    being adjusted.  It is altered by the scripts, but it and
    <tt>value</tt> must be defined before the script is input or in
    the header as shown.

    <p>
    The vector <tt>checkPNTS</tt> is the array of points where
    analysis is performed.  Note that due to some strangeness, at
    least two entries must exist.

    <p>
    The <tt>value</tt> array is initialized to the starting values. 
    The <tt>flags</tt> vector contains 1 for each entry in the array
    which is to be varied, the others are treated as constants.

    <p>
    The lengths of the vectors <tt>value</tt> and <tt>flags</tt> is
    20, which is assumed in the optimization script.

    <p>
    After the analysis is complete, the <tt>value</tt> array will
    contain the optimized values.  Two other arrays, <tt>lower</tt>
    and <tt>upper</tt>, are created, and contain the lower and upper
    limit for each value index.

    <p>
    The scripts provided can be customized by the user for more
    specific applications, or used as templates for different types of
    analysis.  It is recommended that such scripts be defined as <a
    href="codeblock">codeblocks</a> to speed execution.
!!LATEX optimize margin.tex
There are three scripts which implement a margin optimization
algorithm used by Clark Hamilton at NIST.  These files (kept in the
scripts directory) are {\vt optimize}, {\vt margins}, and {\vt merit}. 
The main script is {\vt optimize}, which is invoked with the name of
the file to be optimized as an argument.

This facility is for advanced users.  The present status of the
scripts is unknown, and it is possible that they may require
modification before use.  They are provided as an example of how the
{\WRspice} scripting facility can be employed for optimization.

An example input file, which defines and initializes various variables
and vectors as well as providing a circuit to optimize, is shown
below.  To perform optimization, one gives ``{\vt optimize} {\it
filename}''.

\begin{verbatim}
    .check
    set checkiterate = 3
    let checkN1 = 0
    compose checkPNTS values 1n 2n
    let value[19] = 0
    let flags[19] = 0
    let flags[0] = 1
    let value[0] = .8
    .control
    if (TIME >= checkPNTS[0])
    &#32   checkFAIL = 0
    &#32   if ((abs(v(1)) > 1.5) or (abs(v(1)) < .5))
    &#32       checkFAIL = 1
    &#32   endif
    endif
    .endc
    optimization test
    i1 0 1 pulse(0 1 0 1n)
    r1 1 0 $&value[0]
    .tran .01n 1.1n
    .end
\end{verbatim}

This is the simplest way to input the file, alternatively one could
set the shell variables and vectors externally and/or use a bound
codeblock for pass/fail evaluation.

The {\vt margins} script, called by {\vt optimize} calls the {\et
check} command.  The variable {\vt checkiterate} must be set to a
nonzero value up to 10.  This is the binary search depth for finding
the operating range.

The vectors {\et checkN1} and {\et value} must be defined, {\et
checkN1} is the index into the value array of the variable being
adjusted.  It is altered by the scripts, but it and {\et value} must
be defined before the script is input or in the header as shown.

The vector {\et checkPNTS} is the array of points where analysis is
performed.  Note that due to some strangeness, at least two entries
must exist.

The {\et value} array is initialized to the starting values.  The {\et
flags} vector contains 1 for each entry in the array which is to be
varied, the others are treated as constants.

The lengths of the vectors {\et value} and {\et flags} is 20, which is
assumed in the optimization script.

After the analysis is complete, the {\et value} array will contain the
optimized values.  Two other arrays, {\et lower} and {\et upper}, are
created, and contain the lower and upper limit for each value index.

The scripts provided can be customized by the user for more specific
applications, or used as templates for different types of analysis. 
It is recommended that such scripts be defined as codeblocks to speed
execution.

!!SEEALSO
marganal

