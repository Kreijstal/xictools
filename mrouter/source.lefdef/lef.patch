diff -r -c source.lefdef/lef.orig/clef/lefiLayer.h lef/clef/lefiLayer.h
*** source.lefdef/lef.orig/clef/lefiLayer.h	Fri Feb  5 14:39:14 2016
--- lef/clef/lefiLayer.h	Thu Dec 31 09:41:38 2020
***************
*** 215,221 ****
  EXTERN const char* lefiLayer_propName (const lefiLayer* obj, int  index);
  EXTERN const char* lefiLayer_propValue (const lefiLayer* obj, int  index);
  EXTERN double lefiLayer_propNumber (const lefiLayer* obj, int  index);
! EXTERN const char lefiLayer_propType (const lefiLayer* obj, int  index);
  EXTERN int lefiLayer_propIsNumber (const lefiLayer* obj, int  index);
  EXTERN int lefiLayer_propIsString (const lefiLayer* obj, int  index);
  
--- 215,221 ----
  EXTERN const char* lefiLayer_propName (const lefiLayer* obj, int  index);
  EXTERN const char* lefiLayer_propValue (const lefiLayer* obj, int  index);
  EXTERN double lefiLayer_propNumber (const lefiLayer* obj, int  index);
! EXTERN char lefiLayer_propType (const lefiLayer* obj, int  index);
  EXTERN int lefiLayer_propIsNumber (const lefiLayer* obj, int  index);
  EXTERN int lefiLayer_propIsString (const lefiLayer* obj, int  index);
  
diff -r -c source.lefdef/lef.orig/clef/lefiMacro.h lef/clef/lefiMacro.h
*** source.lefdef/lef.orig/clef/lefiMacro.h	Fri Feb  5 14:39:14 2016
--- lef/clef/lefiMacro.h	Thu Dec 31 09:41:38 2020
***************
*** 198,204 ****
  EXTERN const char* lefiPin_propName (const lefiPin* obj, int  index);
  EXTERN const char* lefiPin_propValue (const lefiPin* obj, int  index);
  EXTERN double lefiPin_propNum (const lefiPin* obj, int  index);
! EXTERN const char lefiPin_propType (const lefiPin* obj, int  index);
  EXTERN int lefiPin_propIsNumber (const lefiPin* obj, int  index);
  EXTERN int lefiPin_propIsString (const lefiPin* obj, int  index);
  
--- 198,204 ----
  EXTERN const char* lefiPin_propName (const lefiPin* obj, int  index);
  EXTERN const char* lefiPin_propValue (const lefiPin* obj, int  index);
  EXTERN double lefiPin_propNum (const lefiPin* obj, int  index);
! EXTERN char lefiPin_propType (const lefiPin* obj, int  index);
  EXTERN int lefiPin_propIsNumber (const lefiPin* obj, int  index);
  EXTERN int lefiPin_propIsString (const lefiPin* obj, int  index);
  
***************
*** 246,252 ****
  EXTERN const char* lefiMacro_propName (const lefiMacro* obj, int  index);
  EXTERN const char* lefiMacro_propValue (const lefiMacro* obj, int  index);
  EXTERN double lefiMacro_propNum (const lefiMacro* obj, int  index);
! EXTERN const char lefiMacro_propType (const lefiMacro* obj, int  index);
  EXTERN int lefiMacro_propIsNumber (const lefiMacro* obj, int  index);
  EXTERN int lefiMacro_propIsString (const lefiMacro* obj, int  index);
  
--- 246,252 ----
  EXTERN const char* lefiMacro_propName (const lefiMacro* obj, int  index);
  EXTERN const char* lefiMacro_propValue (const lefiMacro* obj, int  index);
  EXTERN double lefiMacro_propNum (const lefiMacro* obj, int  index);
! EXTERN char lefiMacro_propType (const lefiMacro* obj, int  index);
  EXTERN int lefiMacro_propIsNumber (const lefiMacro* obj, int  index);
  EXTERN int lefiMacro_propIsString (const lefiMacro* obj, int  index);
  
diff -r -c source.lefdef/lef.orig/clef/lefiNonDefault.h lef/clef/lefiNonDefault.h
*** source.lefdef/lef.orig/clef/lefiNonDefault.h	Fri Feb  5 14:39:14 2016
--- lef/clef/lefiNonDefault.h	Thu Dec 31 09:41:38 2020
***************
*** 44,50 ****
  EXTERN const char* lefiNonDefault_propName (const lefiNonDefault* obj, int  index);
  EXTERN const char* lefiNonDefault_propValue (const lefiNonDefault* obj, int  index);
  EXTERN double lefiNonDefault_propNumber (const lefiNonDefault* obj, int  index);
! EXTERN const char lefiNonDefault_propType (const lefiNonDefault* obj, int  index);
  EXTERN int lefiNonDefault_propIsNumber (const lefiNonDefault* obj, int  index);
  EXTERN int lefiNonDefault_propIsString (const lefiNonDefault* obj, int  index);
  
--- 44,50 ----
  EXTERN const char* lefiNonDefault_propName (const lefiNonDefault* obj, int  index);
  EXTERN const char* lefiNonDefault_propValue (const lefiNonDefault* obj, int  index);
  EXTERN double lefiNonDefault_propNumber (const lefiNonDefault* obj, int  index);
! EXTERN char lefiNonDefault_propType (const lefiNonDefault* obj, int  index);
  EXTERN int lefiNonDefault_propIsNumber (const lefiNonDefault* obj, int  index);
  EXTERN int lefiNonDefault_propIsString (const lefiNonDefault* obj, int  index);
  
diff -r -c source.lefdef/lef.orig/clef/lefiPropType.h lef/clef/lefiPropType.h
*** source.lefdef/lef.orig/clef/lefiPropType.h	Fri Feb  5 14:39:14 2016
--- lef/clef/lefiPropType.h	Thu Dec 31 09:41:38 2020
***************
*** 40,45 ****
  /* Struct holds the data type for one property, if the property is            */
  /* either REAL or INTEGER.                                                    */
  
! EXTERN const char lefiPropType_propType (const lefiPropType* obj, char*  name);
  
  #endif
--- 40,45 ----
  /* Struct holds the data type for one property, if the property is            */
  /* either REAL or INTEGER.                                                    */
  
! EXTERN char lefiPropType_propType (const lefiPropType* obj, char*  name);
  
  #endif
diff -r -c source.lefdef/lef.orig/clef/lefiViaRule.h lef/clef/lefiViaRule.h
*** source.lefdef/lef.orig/clef/lefiViaRule.h	Fri Feb  5 14:39:14 2016
--- lef/clef/lefiViaRule.h	Thu Dec 31 09:41:38 2020
***************
*** 91,97 ****
  EXTERN const char* lefiViaRule_propName (const lefiViaRule* obj, int  index);
  EXTERN const char* lefiViaRule_propValue (const lefiViaRule* obj, int  index);
  EXTERN double lefiViaRule_propNumber (const lefiViaRule* obj, int  index);
! EXTERN const char lefiViaRule_propType (const lefiViaRule* obj, int  index);
  EXTERN int lefiViaRule_propIsNumber (const lefiViaRule* obj, int  index);
  EXTERN int lefiViaRule_propIsString (const lefiViaRule* obj, int  index);
  
--- 91,97 ----
  EXTERN const char* lefiViaRule_propName (const lefiViaRule* obj, int  index);
  EXTERN const char* lefiViaRule_propValue (const lefiViaRule* obj, int  index);
  EXTERN double lefiViaRule_propNumber (const lefiViaRule* obj, int  index);
! EXTERN char lefiViaRule_propType (const lefiViaRule* obj, int  index);
  EXTERN int lefiViaRule_propIsNumber (const lefiViaRule* obj, int  index);
  EXTERN int lefiViaRule_propIsString (const lefiViaRule* obj, int  index);
  
diff -r -c source.lefdef/lef.orig/clef/xlefiLayer.cpp lef/clef/xlefiLayer.cpp
*** source.lefdef/lef.orig/clef/xlefiLayer.cpp	Fri Feb  5 14:39:14 2016
--- lef/clef/xlefiLayer.cpp	Thu Dec 31 09:41:38 2020
***************
*** 553,559 ****
      return ((LefDefParser::lefiLayer*)obj)->propNumber(index);
  }
  
! const char lefiLayer_propType (const ::lefiLayer* obj, int  index) {
      return ((const LefDefParser::lefiLayer*)obj)->propType(index);
  }
  
--- 553,559 ----
      return ((LefDefParser::lefiLayer*)obj)->propNumber(index);
  }
  
! char lefiLayer_propType (const ::lefiLayer* obj, int  index) {
      return ((const LefDefParser::lefiLayer*)obj)->propType(index);
  }
  
diff -r -c source.lefdef/lef.orig/clef/xlefiMacro.cpp lef/clef/xlefiMacro.cpp
*** source.lefdef/lef.orig/clef/xlefiMacro.cpp	Fri Feb  5 14:39:14 2016
--- lef/clef/xlefiMacro.cpp	Thu Dec 31 09:41:38 2020
***************
*** 577,583 ****
      return ((LefDefParser::lefiPin*)obj)->propNum(index);
  }
  
! const char lefiPin_propType (const ::lefiPin* obj, int  index) {
      return ((const LefDefParser::lefiPin*)obj)->propType(index);
  }
  
--- 577,583 ----
      return ((LefDefParser::lefiPin*)obj)->propNum(index);
  }
  
! char lefiPin_propType (const ::lefiPin* obj, int  index) {
      return ((const LefDefParser::lefiPin*)obj)->propType(index);
  }
  
***************
*** 727,733 ****
      return ((LefDefParser::lefiMacro*)obj)->propNum(index);
  }
  
! const char lefiMacro_propType (const ::lefiMacro* obj, int  index) {
      return ((const LefDefParser::lefiMacro*)obj)->propType(index);
  }
  
--- 727,733 ----
      return ((LefDefParser::lefiMacro*)obj)->propNum(index);
  }
  
! char lefiMacro_propType (const ::lefiMacro* obj, int  index) {
      return ((const LefDefParser::lefiMacro*)obj)->propType(index);
  }
  
diff -r -c source.lefdef/lef.orig/clef/xlefiNonDefault.cpp lef/clef/xlefiNonDefault.cpp
*** source.lefdef/lef.orig/clef/xlefiNonDefault.cpp	Fri Feb  5 14:39:14 2016
--- lef/clef/xlefiNonDefault.cpp	Thu Dec 31 09:41:38 2020
***************
*** 61,67 ****
      return ((LefDefParser::lefiNonDefault*)obj)->propNumber(index);
  }
  
! const char lefiNonDefault_propType (const ::lefiNonDefault* obj, int  index) {
      return ((const LefDefParser::lefiNonDefault*)obj)->propType(index);
  }
  
--- 61,67 ----
      return ((LefDefParser::lefiNonDefault*)obj)->propNumber(index);
  }
  
! char lefiNonDefault_propType (const ::lefiNonDefault* obj, int  index) {
      return ((const LefDefParser::lefiNonDefault*)obj)->propType(index);
  }
  
diff -r -c source.lefdef/lef.orig/clef/xlefiPropType.cpp lef/clef/xlefiPropType.cpp
*** source.lefdef/lef.orig/clef/xlefiPropType.cpp	Fri Feb  5 14:39:14 2016
--- lef/clef/xlefiPropType.cpp	Thu Dec 31 09:41:38 2020
***************
*** 37,43 ****
  #include "lefiPropType.hpp"
  
  // Wrappers definitions.
! const char lefiPropType_propType (const ::lefiPropType* obj, char*  name) {
      return ((const LefDefParser::lefiPropType*)obj)->propType(name);
  }
  
--- 37,43 ----
  #include "lefiPropType.hpp"
  
  // Wrappers definitions.
! char lefiPropType_propType (const ::lefiPropType* obj, char*  name) {
      return ((const LefDefParser::lefiPropType*)obj)->propType(name);
  }
  
diff -r -c source.lefdef/lef.orig/clef/xlefiViaRule.cpp lef/clef/xlefiViaRule.cpp
*** source.lefdef/lef.orig/clef/xlefiViaRule.cpp	Fri Feb  5 14:39:14 2016
--- lef/clef/xlefiViaRule.cpp	Thu Dec 31 09:41:38 2020
***************
*** 181,187 ****
      return ((LefDefParser::lefiViaRule*)obj)->propNumber(index);
  }
  
! const char lefiViaRule_propType (const ::lefiViaRule* obj, int  index) {
      return ((const LefDefParser::lefiViaRule*)obj)->propType(index);
  }
  
--- 181,187 ----
      return ((LefDefParser::lefiViaRule*)obj)->propNumber(index);
  }
  
! char lefiViaRule_propType (const ::lefiViaRule* obj, int  index) {
      return ((const LefDefParser::lefiViaRule*)obj)->propType(index);
  }
  
diff -r -c source.lefdef/lef.orig/clef/xlefrReader.cpp lef/clef/xlefrReader.cpp
*** source.lefdef/lef.orig/clef/xlefrReader.cpp	Fri Feb  5 14:39:14 2016
--- lef/clef/xlefrReader.cpp	Thu Dec 31 09:41:38 2020
***************
*** 286,296 ****
  }
  
  void lefrSetMacroOriginCbk (::lefrMacroNumCbkFnType p0) {
!     LefDefParser::lefrSetMacroOriginCbk((LefDefParser::lefrMacroNumCbkFnType) p0);
  }
  
  void lefrSetMacroSizeCbk (::lefrMacroNumCbkFnType p0) {
!     LefDefParser::lefrSetMacroSizeCbk((LefDefParser::lefrMacroNumCbkFnType) p0);
  }
  
  void lefrSetMacroFixedMaskCbk (::lefrIntegerCbkFnType p0) {
--- 286,296 ----
  }
  
  void lefrSetMacroOriginCbk (::lefrMacroNumCbkFnType p0) {
!     LefDefParser::lefrSetMacroOriginCbk((LefDefParser::lefrMacroNumCbkFnType) (void*)p0);
  }
  
  void lefrSetMacroSizeCbk (::lefrMacroNumCbkFnType p0) {
!     LefDefParser::lefrSetMacroSizeCbk((LefDefParser::lefrMacroNumCbkFnType) (void*)p0);
  }
  
  void lefrSetMacroFixedMaskCbk (::lefrIntegerCbkFnType p0) {
diff -r -c source.lefdef/lef.orig/lef/crypt.cpp lef/lef/crypt.cpp
*** source.lefdef/lef.orig/lef/crypt.cpp	Mon Mar 14 15:20:23 2016
--- lef/lef/crypt.cpp	Thu Dec 31 09:41:38 2020
***************
*** 1,116 ****
! // *****************************************************************************
! // *****************************************************************************
! // Copyright 2012 - 2013, Cadence Design Systems
! // 
! // This  file  is  part  of  the  Cadence  LEF/DEF  Open   Source
! // Distribution,  Product Version 5.8. 
! // 
! // Licensed under the Apache License, Version 2.0 (the "License");
! //    you may not use this file except in compliance with the License.
! //    You may obtain a copy of the License at
! // 
! //        http://www.apache.org/licenses/LICENSE-2.0
! // 
! //    Unless required by applicable law or agreed to in writing, software
! //    distributed under the License is distributed on an "AS IS" BASIS,
! //    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
! //    implied. See the License for the specific language governing
! //    permissions and limitations under the License.
! // 
! // For updates, support, or to become part of the LEF/DEF Community,
! // check www.openeda.org for details.
! // 
! //  $Author: dell $
! //  $Revision: #6 $
! //  $Date: 2015/01/20 $
! //  $State:  $
! // *****************************************************************************
! // *****************************************************************************
! 
! /*
!  * FILE: crypt.cpp
!  *
!  */
! 
! #include <stdio.h>
! #include <stdarg.h>
! 
! #include "lefiKRDefs.hpp"
! 
! BEGIN_LEFDEF_PARSER_NAMESPACE
! 
! #ifdef WIN32
! #   include <io.h>
! #else // not WIN32 
! #   include <unistd.h>
! 
! #endif // WIN32 
! 
! 
! FILE *
! encOpenFileForRead(char *filename)
! {
!     return fopen(filename, "r");
! }
! 
! FILE *
! encOpenFileForWrite(char    *filename,
!                     int     encrypt_f)
! {
!     return fopen(filename, "w");
! }
! 
! int
! encCloseFile(FILE *fp)
! {
!     return fclose(fp);
! }
! 
! void
! encClearBuf(FILE *fp)
! {
! }
! 
! void
! encReadingEncrypted()
! {
! }
! 
! void
! encWritingEncrypted()
! {
! }
! 
! int
! encIsEncrypted(unsigned char *buf)
! {
!     return false;
! }
! 
! int
! encFgetc(FILE *fp)
! {
!     return fgetc(fp);
! }
! 
! int
! encFputc(char   c,
!          FILE   *fp)
! {
!     return fputc(c, fp);
! }
! 
! void
! encPrint(FILE   *fp,
!          char   *format,
!          ...)
! {
!     va_list ap;
! 
!     va_start(ap, format);
!     vfprintf(fp, format, ap);
!     va_end(ap);
! }
! 
! END_LEFDEF_PARSER_NAMESPACE
! 
--- 1,117 ----
! // *****************************************************************************
! // *****************************************************************************
! // Copyright 2012 - 2013, Cadence Design Systems
! // 
! // This  file  is  part  of  the  Cadence  LEF/DEF  Open   Source
! // Distribution,  Product Version 5.8. 
! // 
! // Licensed under the Apache License, Version 2.0 (the "License");
! //    you may not use this file except in compliance with the License.
! //    You may obtain a copy of the License at
! // 
! //        http://www.apache.org/licenses/LICENSE-2.0
! // 
! //    Unless required by applicable law or agreed to in writing, software
! //    distributed under the License is distributed on an "AS IS" BASIS,
! //    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
! //    implied. See the License for the specific language governing
! //    permissions and limitations under the License.
! // 
! // For updates, support, or to become part of the LEF/DEF Community,
! // check www.openeda.org for details.
! // 
! //  $Author: dell $
! //  $Revision: #6 $
! //  $Date: 2015/01/20 $
! //  $State:  $
! // *****************************************************************************
! // *****************************************************************************
! 
! /*
!  * FILE: crypt.cpp
!  *
!  */
! 
! #include <stdio.h>
! #include <stdarg.h>
! 
! #include "lefiKRDefs.hpp"
! 
! // S. Whiteley, move this below include.
! // BEGIN_LEFDEF_PARSER_NAMESPACE
! 
! #ifdef WIN32
! #   include <io.h>
! #else // not WIN32 
! #   include <unistd.h>
! 
! #endif // WIN32 
! 
! BEGIN_LEFDEF_PARSER_NAMESPACE
! 
! FILE *
! encOpenFileForRead(char *filename)
! {
!     return fopen(filename, "r");
! }
! 
! FILE *
! encOpenFileForWrite(char    *filename, int)
! {
!     return fopen(filename, "w");
! }
! 
! int
! encCloseFile(FILE *fp)
! {
!     return fclose(fp);
! }
! 
! void
! encClearBuf(FILE *)
! {
! }
! 
! void
! encReadingEncrypted()
! {
! }
! 
! void
! encWritingEncrypted()
! {
! }
! 
! int
! encIsEncrypted(unsigned char *)
! {
!     return false;
! }
! 
! int
! encFgetc(FILE *fp)
! {
!     return fgetc(fp);
! }
! 
! int
! encFputc(char   c,
!          FILE   *fp)
! {
!     return fputc(c, fp);
! }
! 
! void
! encPrint(FILE   *fp,
!          char   *format,
!          ...)
! {
!     va_list ap;
! 
!     va_start(ap, format);
!     vfprintf(fp, format, ap);
!     va_end(ap);
! }
! 
! END_LEFDEF_PARSER_NAMESPACE
! 
diff -r -c source.lefdef/lef.orig/lef/lef.y lef/lef/lef.y
*** source.lefdef/lef.orig/lef/lef.y	Fri Feb  5 14:39:14 2016
--- lef/lef/lef.y	Sun Jan 14 11:44:35 2024
***************
*** 2,7 ****
--- 2,12 ----
  // ************************************************************************** 
  // ATTENTION: THIS IS AN AUTO-GENERATED FILE. DO NOT CHANGE IT!               
  // ************************************************************************** 
+ //====
+ // Updated to add missing semicolons for compatibility with bison-3.
+ // Bison no longer repairs this error.
+ // Stephen Whiteley, Whiteley Research Inc.
+ //====
  // ************************************************************************** 
  // Copyright 2012 - 2015, Cadence Design Systems                                     
  //                                                                            
***************
*** 160,166 ****
                  if (lefCallbacks->UnitsCbk) {
                    if (lefData->unitsWarnings++ < lefSettings->UnitsWarnings) {
                      lefData->outMsg = (char*)lefMalloc(10000);
!                     sprintf (lefData->outMsg,
                         "Error found when processing LEF file '%s'\nUnit %d is a version 5.6 or later syntax\nYour lef file is defined with version %g.",
                      lefData->lefrFileName, values, lefData->versionNum);
                      lefError(1501, lefData->outMsg);
--- 165,171 ----
                  if (lefCallbacks->UnitsCbk) {
                    if (lefData->unitsWarnings++ < lefSettings->UnitsWarnings) {
                      lefData->outMsg = (char*)lefMalloc(10000);
!                     snprintf (lefData->outMsg, 10000,
                         "Error found when processing LEF file '%s'\nUnit %d is a version 5.6 or later syntax\nYour lef file is defined with version %g.",
                      lefData->lefrFileName, values, lefData->versionNum);
                      lefError(1501, lefData->outMsg);
***************
*** 174,180 ****
      }
      if (lefData->unitsWarnings++ < lefSettings->UnitsWarnings) {
         lefData->outMsg = (char*)lefMalloc(10000);
!        sprintf (lefData->outMsg,
            "The value %d defined for LEF UNITS DATABASE MICRONS is invalid\n. Correct value is 100, 200, 400, 800, 1000, 2000, 4000, 8000, 10000, or 20000", values);
         lefError(1502, lefData->outMsg);
         lefFree(lefData->outMsg);
--- 179,185 ----
      }
      if (lefData->unitsWarnings++ < lefSettings->UnitsWarnings) {
         lefData->outMsg = (char*)lefMalloc(10000);
!        snprintf (lefData->outMsg, 10000,
            "The value %d defined for LEF UNITS DATABASE MICRONS is invalid\n. Correct value is 100, 200, 400, 800, 1000, 2000, 4000, 8000, 10000, or 20000", values);
         lefError(1502, lefData->outMsg);
         lefFree(lefData->outMsg);
***************
*** 338,344 ****
             return 1;
          if (!lefData->hasVer) {
                char temp[300];
!               sprintf(temp, "No VERSION statement found, using the default value %2g.", lefData->versionNum);
                lefWarning(2001, temp);            
          }        
          //only pre 5.6, 5.6 it is obsolete
--- 343,349 ----
             return 1;
          if (!lefData->hasVer) {
                char temp[300];
!               snprintf(temp, 300, "No VERSION statement found, using the default value %2g.", lefData->versionNum);
                lefWarning(2001, temp);            
          }        
          //only pre 5.6, 5.6 it is obsolete
***************
*** 363,369 ****
           lefData->versionNum = convert_name2num($3);
           if (lefData->versionNum > CURRENT_VERSION) {
              char temp[120];
!             sprintf(temp,
                 "Lef parser %.1f does not support lef file with version %s. Parser will stop processing.", CURRENT_VERSION, $3);
              lefError(1503, temp);
              return 1;
--- 368,374 ----
           lefData->versionNum = convert_name2num($3);
           if (lefData->versionNum > CURRENT_VERSION) {
              char temp[120];
!             snprintf(temp, 120,
                 "Lef parser %.1f does not support lef file with version %s. Parser will stop processing.", CURRENT_VERSION, $3);
              lefError(1503, temp);
              return 1;
***************
*** 656,662 ****
          if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
            if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
               lefData->outMsg = (char*)lefMalloc(10000);
!              sprintf (lefData->outMsg,
                  "END LAYER name %s is different from the LAYER name %s.\nCorrect the LEF file before rerunning it through the LEF parser.", $3, lefData->layerName);
               lefError(1507, lefData->outMsg);
               lefFree(lefData->outMsg);
--- 661,667 ----
          if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
            if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
               lefData->outMsg = (char*)lefMalloc(10000);
!              snprintf (lefData->outMsg, 10000,
                  "END LAYER name %s is different from the LAYER name %s.\nCorrect the LEF file before rerunning it through the LEF parser.", $3, lefData->layerName);
               lefError(1507, lefData->outMsg);
               lefFree(lefData->outMsg);
***************
*** 697,703 ****
            if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg, "The DIRECTION statement which is required in a LAYER with TYPE ROUTING is not defined in LAYER %s.\nUpdate your lef file and add the DIRECTION statement for layer %s.", $3, $3);
                lefError(1511, lefData->outMsg);
                lefFree(lefData->outMsg);
                CHKERR(); 
--- 702,708 ----
            if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000, "The DIRECTION statement which is required in a LAYER with TYPE ROUTING is not defined in LAYER %s.\nUpdate your lef file and add the DIRECTION statement for layer %s.", $3, $3);
                lefError(1511, lefData->outMsg);
                lefFree(lefData->outMsg);
                CHKERR(); 
***************
*** 732,738 ****
      {
        if (lefData->versionNum < 5.7) {
           lefData->outMsg = (char*)lefMalloc(10000);
!          sprintf(lefData->outMsg,
             "ARRAYSPACING is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
           lefError(1685, lefData->outMsg);
           lefFree(lefData->outMsg);
--- 737,743 ----
      {
        if (lefData->versionNum < 5.7) {
           lefData->outMsg = (char*)lefMalloc(10000);
!          snprintf(lefData->outMsg, 10000,
             "ARRAYSPACING is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
           lefError(1685, lefData->outMsg);
           lefFree(lefData->outMsg);
***************
*** 850,856 ****
      {
        if (lefData->versionNum < 5.7) {
           lefData->outMsg = (char*)lefMalloc(10000);
!          sprintf(lefData->outMsg,
             "SPACINGTABLE ORTHOGONAL is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
           lefError(1694, lefData->outMsg);
           lefFree(lefData->outMsg);
--- 855,861 ----
      {
        if (lefData->versionNum < 5.7) {
           lefData->outMsg = (char*)lefMalloc(10000);
!          snprintf(lefData->outMsg, 10000,
             "SPACINGTABLE ORTHOGONAL is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
           lefError(1694, lefData->outMsg);
           lefFree(lefData->outMsg);
***************
*** 1005,1011 ****
              if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
                 if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                    lefData->outMsg = (char*)lefMalloc(10000);
!                   sprintf (lefData->outMsg,
                      "ANTENNALENGTHFACTOR statement is a version 5.3 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNALENGTHFACTOR syntax, which is incorrect.", lefData->versionNum);
                    lefError(1526, lefData->outMsg);
                    lefFree(lefData->outMsg);
--- 1010,1016 ----
              if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
                 if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                    lefData->outMsg = (char*)lefMalloc(10000);
!                   snprintf (lefData->outMsg, 10000,
                      "ANTENNALENGTHFACTOR statement is a version 5.3 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNALENGTHFACTOR syntax, which is incorrect.", lefData->versionNum);
                    lefError(1526, lefData->outMsg);
                    lefFree(lefData->outMsg);
***************
*** 1188,1194 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                   "ANTENNAAREARATIO statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1531, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1193,1199 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                   "ANTENNAAREARATIO statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1531, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1199,1205 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                   "ANTENNADIFFAREARATIO statement is a version 5.4 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNAAREARATIO syntax, which is incorrect.", lefData->versionNum);
                 lefError(1704, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1204,1210 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                   "ANTENNADIFFAREARATIO statement is a version 5.4 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNAAREARATIO syntax, which is incorrect.", lefData->versionNum);
                 lefError(1704, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1226,1232 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "ANTENNADIFFAREARATIO statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1532, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1231,1237 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "ANTENNADIFFAREARATIO statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1532, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1237,1243 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                   "ANTENNADIFFAREARATIO statement is a version 5.4 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNADIFFAREARATIO syntax, which is incorrect.", lefData->versionNum);
                 lefError(1704, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1242,1248 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                   "ANTENNADIFFAREARATIO statement is a version 5.4 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNADIFFAREARATIO syntax, which is incorrect.", lefData->versionNum);
                 lefError(1704, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1265,1271 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "ANTENNACUMAREARATIO statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1535, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1270,1276 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "ANTENNACUMAREARATIO statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1535, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1276,1282 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                   "ANTENNACUMAREARATIO statement is a version 5.4 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNACUMAREARATIO syntax, which is incorrect.", lefData->versionNum);
                 lefError(1536, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1281,1287 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                   "ANTENNACUMAREARATIO statement is a version 5.4 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNACUMAREARATIO syntax, which is incorrect.", lefData->versionNum);
                 lefError(1536, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1303,1309 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "ANTENNACUMDIFFAREARATIO statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1538, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1308,1314 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "ANTENNACUMDIFFAREARATIO statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1538, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1314,1320 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                   "ANTENNACUMDIFFAREARATIO statement is a version 5.4 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNACUMDIFFAREARATIO syntax, which is incorrect.", lefData->versionNum);
                 lefError(1539, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1319,1325 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                   "ANTENNACUMDIFFAREARATIO statement is a version 5.4 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNACUMDIFFAREARATIO syntax, which is incorrect.", lefData->versionNum);
                 lefError(1539, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1365,1371 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "ANTENNASIDEAREARATIO statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1543, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1370,1376 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "ANTENNASIDEAREARATIO statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1543, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1376,1382 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                   "ANTENNASIDEAREARATIO statement is a version 5.4 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNASIDEAREARATIO syntax, which is incorrect.", lefData->versionNum);
                 lefError(1544, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1381,1387 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                   "ANTENNASIDEAREARATIO statement is a version 5.4 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNASIDEAREARATIO syntax, which is incorrect.", lefData->versionNum);
                 lefError(1544, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1403,1409 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "ANTENNADIFFSIDEAREARATIO statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1546, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1408,1414 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "ANTENNADIFFSIDEAREARATIO statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1546, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1414,1420 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                   "ANTENNADIFFSIDEAREARATIO statement is a version 5.4 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNADIFFSIDEAREARATIO syntax, which is incorrect.", lefData->versionNum);
                 lefError(1547, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1419,1425 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                   "ANTENNADIFFSIDEAREARATIO statement is a version 5.4 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNADIFFSIDEAREARATIO syntax, which is incorrect.", lefData->versionNum);
                 lefError(1547, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1442,1448 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "ANTENNACUMSIDEAREARATIO statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1549, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1447,1453 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "ANTENNACUMSIDEAREARATIO statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1549, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1453,1459 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                   "ANTENNACUMSIDEAREARATIO statement is a version 5.4 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNACUMSIDEAREARATIO syntax, which is incorrect.", lefData->versionNum);
                 lefError(1550, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1458,1464 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                   "ANTENNACUMSIDEAREARATIO statement is a version 5.4 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNACUMSIDEAREARATIO syntax, which is incorrect.", lefData->versionNum);
                 lefError(1550, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1480,1486 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "ANTENNACUMDIFFSIDEAREARATIO statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1552, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1485,1491 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "ANTENNACUMDIFFSIDEAREARATIO statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1552, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1491,1497 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                   "ANTENNACUMDIFFSIDEAREARATIO statement is a version 5.4 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNACUMDIFFSIDEAREARATIO syntax, which is incorrect.", lefData->versionNum);
                 lefError(1553, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1496,1502 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                   "ANTENNACUMDIFFSIDEAREARATIO statement is a version 5.4 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNACUMDIFFSIDEAREARATIO syntax, which is incorrect.", lefData->versionNum);
                 lefError(1553, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1519,1525 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "ANTENNASIDEAREAFACTOR statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1555, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1524,1530 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "ANTENNASIDEAREAFACTOR statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1555, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1530,1536 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                   "ANTENNASIDEAREAFACTOR statement is a version 5.4 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNASIDEAREAFACTOR syntax, which is incorrect.", lefData->versionNum);
                 lefError(1556, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1535,1541 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                   "ANTENNASIDEAREAFACTOR statement is a version 5.4 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNASIDEAREAFACTOR syntax, which is incorrect.", lefData->versionNum);
                 lefError(1556, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1559,1565 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "ANTENNAMODEL statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1558, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1564,1570 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "ANTENNAMODEL statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1558, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1570,1576 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                   "ANTENNAMODEL statement is a version 5.4 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNAMODEL syntax, which is incorrect.", lefData->versionNum);
                 lefError(1559, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1575,1581 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                   "ANTENNAMODEL statement is a version 5.4 or earlier syntax.\nYour lef file with version %g, has both old and new ANTENNAMODEL syntax, which is incorrect.", lefData->versionNum);
                 lefError(1559, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1585,1591 ****
      {
        if (lefData->versionNum < 5.7) {
           lefData->outMsg = (char*)lefMalloc(10000);
!          sprintf(lefData->outMsg,
             "ANTENNACUMROUTINGPLUSCUT is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
           lefError(1686, lefData->outMsg);
           lefFree(lefData->outMsg);
--- 1590,1596 ----
      {
        if (lefData->versionNum < 5.7) {
           lefData->outMsg = (char*)lefMalloc(10000);
!          snprintf(lefData->outMsg, 10000,
             "ANTENNACUMROUTINGPLUSCUT is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
           lefError(1686, lefData->outMsg);
           lefFree(lefData->outMsg);
***************
*** 1606,1612 ****
      {
        if (lefData->versionNum < 5.7) {
           lefData->outMsg = (char*)lefMalloc(10000);
!          sprintf(lefData->outMsg,
             "ANTENNAGATEPLUSDIFF is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
           lefError(1687, lefData->outMsg);
           lefFree(lefData->outMsg);
--- 1611,1617 ----
      {
        if (lefData->versionNum < 5.7) {
           lefData->outMsg = (char*)lefMalloc(10000);
!          snprintf(lefData->outMsg, 10000,
             "ANTENNAGATEPLUSDIFF is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
           lefError(1687, lefData->outMsg);
           lefFree(lefData->outMsg);
***************
*** 1627,1633 ****
      {
        if (lefData->versionNum < 5.7) {
           lefData->outMsg = (char*)lefMalloc(10000);
!          sprintf(lefData->outMsg,
             "ANTENNAAREAMINUSDIFF is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
           lefError(1688, lefData->outMsg);
           lefFree(lefData->outMsg);
--- 1632,1638 ----
      {
        if (lefData->versionNum < 5.7) {
           lefData->outMsg = (char*)lefMalloc(10000);
!          snprintf(lefData->outMsg, 10000,
             "ANTENNAAREAMINUSDIFF is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
           lefError(1688, lefData->outMsg);
           lefFree(lefData->outMsg);
***************
*** 1669,1675 ****
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         sprintf(lefData->outMsg,
            "ANTENNAAREADIFFREDUCEPWL is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1689, lefData->outMsg);
          lefFree(lefData->outMsg);
--- 1674,1680 ----
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         snprintf(lefData->outMsg, 10000,
            "ANTENNAAREADIFFREDUCEPWL is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1689, lefData->outMsg);
          lefFree(lefData->outMsg);
***************
*** 1690,1696 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "SLOTWIREWIDTH statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1564, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1695,1701 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "SLOTWIREWIDTH statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1564, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1714,1720 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "SLOTWIRELENGTH statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1565, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1719,1725 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "SLOTWIRELENGTH statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1565, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1738,1744 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "SLOTWIDTH statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1566, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1743,1749 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "SLOTWIDTH statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1566, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1762,1768 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "SLOTLENGTH statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1567, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1767,1773 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "SLOTLENGTH statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1567, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1786,1792 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "MAXADJACENTSLOTSPACING statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1568, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1791,1797 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "MAXADJACENTSLOTSPACING statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1568, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1810,1816 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "MAXCOAXIALSLOTSPACING statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1569, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1815,1821 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "MAXCOAXIALSLOTSPACING statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1569, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1834,1840 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "MAXEDGESLOTSPACING statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1570, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1839,1845 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "MAXEDGESLOTSPACING statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1570, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1857,1863 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "SPLITWIREWIDTH statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1571, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1862,1868 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "SPLITWIREWIDTH statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1571, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1875,1881 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "MINIMUMDENSITY statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1572, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1880,1886 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "MINIMUMDENSITY statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1572, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1893,1899 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "MAXIMUMDENSITY statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1573, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1898,1904 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "MAXIMUMDENSITY statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1573, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1911,1917 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "DENSITYCHECKWINDOW statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1574, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1916,1922 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "DENSITYCHECKWINDOW statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1574, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1929,1935 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "DENSITYCHECKSTEP statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1575, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1934,1940 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "DENSITYCHECKSTEP statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1575, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1947,1953 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "FILLACTIVESPACING statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1576, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1952,1958 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "FILLACTIVESPACING statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1576, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1972,1978 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "MAXWIDTH statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1578, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 1977,1983 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "MAXWIDTH statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1578, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 1997,2003 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "MINWIDTH statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1580, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 2002,2008 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "MINWIDTH statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1580, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 2013,2019 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "MINENCLOSEDAREA statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1581, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 2018,2024 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "MINENCLOSEDAREA statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1581, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 2052,2058 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "PROTRUSION RULE statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1582, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 2057,2063 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "PROTRUSION RULE statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1582, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 2068,2074 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "SPACINGTABLE statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1583, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 2073,2079 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "SPACINGTABLE statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1583, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 2094,2100 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "ENCLOSURE statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1584, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 2099,2105 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "ENCLOSURE statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1584, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 2113,2119 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "PREFERENCLOSURE statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1585, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 2118,2124 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "PREFERENCLOSURE statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1585, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 2131,2137 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "RESISTANCE statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1586, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 2136,2142 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "RESISTANCE statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1586, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 2156,2162 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "DIAGMINEDGELENGTH statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1588, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 2161,2167 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "DIAGMINEDGELENGTH statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1588, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 2298,2304 ****
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         sprintf(lefData->outMsg,
            "TWOWIDTHS is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1697, lefData->outMsg);
          lefFree(lefData->outMsg);
--- 2303,2309 ----
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         snprintf(lefData->outMsg, 10000,
            "TWOWIDTHS is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1697, lefData->outMsg);
          lefFree(lefData->outMsg);
***************
*** 2358,2364 ****
      {
        if (lefData->versionNum < 5.7) {
           lefData->outMsg = (char*)lefMalloc(10000);
!          sprintf(lefData->outMsg,
             "LENGTH is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
           lefError(1691, lefData->outMsg);
           lefFree(lefData->outMsg);
--- 2363,2369 ----
      {
        if (lefData->versionNum < 5.7) {
           lefData->outMsg = (char*)lefMalloc(10000);
!          snprintf(lefData->outMsg, 10000,
             "LENGTH is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
           lefError(1691, lefData->outMsg);
           lefFree(lefData->outMsg);
***************
*** 2375,2381 ****
      {
        if (lefData->versionNum < 5.7) {
           lefData->outMsg = (char*)lefMalloc(10000);
!          sprintf(lefData->outMsg,
             "EXCEPTEXTRACUT is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
           lefError(1690, lefData->outMsg);
           lefFree(lefData->outMsg);
--- 2380,2386 ----
      {
        if (lefData->versionNum < 5.7) {
           lefData->outMsg = (char*)lefMalloc(10000);
!          snprintf(lefData->outMsg, 10000,
             "EXCEPTEXTRACUT is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
           lefError(1690, lefData->outMsg);
           lefFree(lefData->outMsg);
***************
*** 2400,2406 ****
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         sprintf(lefData->outMsg,
            "MINIMUMCUT WITHIN is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1700, lefData->outMsg);
          lefFree(lefData->outMsg);
--- 2405,2411 ----
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         snprintf(lefData->outMsg, 10000,
            "MINIMUMCUT WITHIN is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1700, lefData->outMsg);
          lefFree(lefData->outMsg);
***************
*** 2419,2425 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                   "FROMABOVE statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1596, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 2424,2430 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                   "FROMABOVE statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1596, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 2438,2444 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                   "FROMBELOW statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1597, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 2443,2449 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                   "FROMBELOW statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1597, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 2458,2464 ****
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                   "LENGTH WITHIN statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1598, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 2463,2469 ----
           if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
              if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                   "LENGTH WITHIN statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1598, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 2486,2492 ****
    {
      if (lefData->versionNum < 5.7) {
        lefData->outMsg = (char*)lefMalloc(10000);
!       sprintf(lefData->outMsg,
          "MAXEDGES is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
        lefError(1710, lefData->outMsg);
        lefFree(lefData->outMsg);
--- 2491,2497 ----
    {
      if (lefData->versionNum < 5.7) {
        lefData->outMsg = (char*)lefMalloc(10000);
!       snprintf(lefData->outMsg, 10000,
          "MAXEDGES is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
        lefError(1710, lefData->outMsg);
        lefFree(lefData->outMsg);
***************
*** 2538,2544 ****
             if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
                if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                   lefData->outMsg = (char*)lefMalloc(10000);
!                  sprintf (lefData->outMsg,
                     "ANTENNAAREAFACTOR with DIFFUSEONLY statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                   lefError(1599, lefData->outMsg);
                   lefFree(lefData->outMsg);
--- 2543,2549 ----
             if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
                if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                   lefData->outMsg = (char*)lefMalloc(10000);
!                  snprintf (lefData->outMsg, 10000,
                     "ANTENNAAREAFACTOR with DIFFUSEONLY statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                   lefError(1599, lefData->outMsg);
                   lefFree(lefData->outMsg);
***************
*** 2549,2555 ****
             if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
                if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                   lefData->outMsg = (char*)lefMalloc(10000);
!                  sprintf (lefData->outMsg,
                     "ANTENNAAREAFACTOR with DIFFUSEONLY statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                   lefError(1599, lefData->outMsg);
                   lefFree(lefData->outMsg);
--- 2554,2560 ----
             if (lefCallbacks->LayerCbk) { // write error only if cbk is set 
                if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                   lefData->outMsg = (char*)lefMalloc(10000);
!                  snprintf (lefData->outMsg, 10000,
                     "ANTENNAAREAFACTOR with DIFFUSEONLY statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                   lefError(1599, lefData->outMsg);
                   lefFree(lefData->outMsg);
***************
*** 2642,2648 ****
    | T_STRING NUMBER
      {
        char temp[32];
!       sprintf(temp, "%.11g", $2);
        if (lefCallbacks->LayerCbk) {
          char propTp;
          propTp = lefSettings->lefProps.lefrLayerProp.propType($1);
--- 2647,2653 ----
    | T_STRING NUMBER
      {
        char temp[32];
!       snprintf(temp, 32, "%.11g", $2);
        if (lefCallbacks->LayerCbk) {
          char propTp;
          propTp = lefSettings->lefProps.lefrLayerProp.propType($1);
***************
*** 2792,2798 ****
          if (lefCallbacks->MaxStackViaCbk) { // write error only if cbk is set 
             if (lefData->maxStackViaWarnings++ < lefSettings->MaxStackViaWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                  "MAXVIASTACK statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1604, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 2797,2803 ----
          if (lefCallbacks->MaxStackViaCbk) { // write error only if cbk is set 
             if (lefData->maxStackViaWarnings++ < lefSettings->MaxStackViaWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                  "MAXVIASTACK statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1604, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 2878,2884 ****
           if (lefCallbacks->ViaCbk) { // write error only if cbk is set 
              if (lefData->viaRuleWarnings++ < lefSettings->ViaRuleWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                  "VIARULE statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1709, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 2883,2889 ----
           if (lefCallbacks->ViaCbk) { // write error only if cbk is set 
              if (lefData->viaRuleWarnings++ < lefSettings->ViaRuleWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                  "VIARULE statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1709, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 2957,2963 ****
    T_STRING NUMBER
      { 
        char temp[32];
!       sprintf(temp, "%.11g", $2);
        if (lefCallbacks->ViaCbk) {
           char propTp;
           propTp = lefSettings->lefProps.lefrViaProp.propType($1);
--- 2962,2968 ----
    T_STRING NUMBER
      { 
        char temp[32];
!       snprintf(temp, 32, "%.11g", $2);
        if (lefCallbacks->ViaCbk) {
           char propTp;
           propTp = lefSettings->lefProps.lefrViaProp.propType($1);
***************
*** 3101,3107 ****
           if (lefCallbacks->ViaCbk) {  // write error only if cbk is set 
              if (lefData->viaWarnings++ < lefSettings->ViaWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                  "A LAYER statement is missing in the VIA %s.\nAt least one LAYERis required per VIA statement.", $3);
                lefError(1606, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 3106,3112 ----
           if (lefCallbacks->ViaCbk) {  // write error only if cbk is set 
              if (lefData->viaWarnings++ < lefSettings->ViaWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                  "A LAYER statement is missing in the VIA %s.\nAt least one LAYERis required per VIA statement.", $3);
                lefError(1606, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 3113,3119 ****
           if (lefCallbacks->ViaCbk) { // write error only if cbk is set 
              if (lefData->viaWarnings++ < lefSettings->ViaWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                  "END VIA name %s is different from the VIA name %s.\nCorrect the LEF file before rerunning it through the LEF parser.", $3, lefData->viaName);
                lefError(1607, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 3118,3124 ----
           if (lefCallbacks->ViaCbk) { // write error only if cbk is set 
              if (lefData->viaWarnings++ < lefSettings->ViaWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                  "END VIA name %s is different from the VIA name %s.\nCorrect the LEF file before rerunning it through the LEF parser.", $3, lefData->viaName);
                lefError(1607, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 3190,3196 ****
           if (lefCallbacks->ViaRuleCbk) {  // write error only if cbk is set 
              if (lefData->viaRuleWarnings++ < lefSettings->ViaRuleWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                  "DEFAULT statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1605, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 3195,3201 ----
           if (lefCallbacks->ViaRuleCbk) {  // write error only if cbk is set 
              if (lefData->viaRuleWarnings++ < lefSettings->ViaRuleWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                  "DEFAULT statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1605, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 3247,3253 ****
    | T_STRING NUMBER
      {
        char temp[32];
!       sprintf(temp, "%.11g", $2);
        if (lefCallbacks->ViaRuleCbk) {
           char propTp;
           propTp = lefSettings->lefProps.lefrViaRuleProp.propType($1);
--- 3252,3258 ----
    | T_STRING NUMBER
      {
        char temp[32];
!       snprintf(temp, 32, "%.11g", $2);
        if (lefCallbacks->ViaRuleCbk) {
           char propTp;
           propTp = lefSettings->lefProps.lefrViaRuleProp.propType($1);
***************
*** 3350,3356 ****
           if (lefCallbacks->ViaRuleCbk) { // write error only if cbk is set 
             if (lefData->viaRuleWarnings++ < lefSettings->ViaRuleWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                  "ENCLOSURE statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1707, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 3355,3361 ----
           if (lefCallbacks->ViaRuleCbk) { // write error only if cbk is set 
             if (lefData->viaRuleWarnings++ < lefSettings->ViaRuleWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                  "ENCLOSURE statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1707, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 3454,3460 ****
              !lefData->lefrViaRule.layer(1)->hasRect() &&
              !lefData->lefrViaRule.layer(2)->hasRect()) {
              lefData->outMsg = (char*)lefMalloc(10000);
!             sprintf (lefData->outMsg, 
                       "VIARULE GENERATE '%s' cut layer definition should have RECT statement.\nCorrect the LEF file before rerunning it through the LEF parser.", 
                        lefData->viaRuleName);
              lefWarning(1714, lefData->outMsg); 
--- 3459,3465 ----
              !lefData->lefrViaRule.layer(1)->hasRect() &&
              !lefData->lefrViaRule.layer(2)->hasRect()) {
              lefData->outMsg = (char*)lefMalloc(10000);
!             snprintf (lefData->outMsg, 10000, 
                       "VIARULE GENERATE '%s' cut layer definition should have RECT statement.\nCorrect the LEF file before rerunning it through the LEF parser.", 
                        lefData->viaRuleName);
              lefWarning(1714, lefData->outMsg); 
***************
*** 3467,3473 ****
          if (lefCallbacks->ViaRuleCbk) {  // write error only if cbk is set 
             if (lefData->viaRuleWarnings++ < lefSettings->ViaRuleWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "END VIARULE name %s is different from the VIARULE name %s.\nCorrect the LEF file before rerunning it through the LEF parser.", $3, lefData->viaRuleName);
                lefError(1615, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 3472,3478 ----
          if (lefCallbacks->ViaRuleCbk) {  // write error only if cbk is set 
             if (lefData->viaRuleWarnings++ < lefSettings->ViaRuleWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "END VIARULE name %s is different from the VIARULE name %s.\nCorrect the LEF file before rerunning it through the LEF parser.", $3, lefData->viaRuleName);
                lefError(1615, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 3687,3693 ****
          if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
            if (lefData->nonDefaultWarnings++ < lefSettings->NonDefaultWarnings) {
               lefData->outMsg = (char*)lefMalloc(10000);
!              sprintf (lefData->outMsg,
                  "END NONDEFAULTRULE name %s is different from the NONDEFAULTRULE name %s.\nCorrect the LEF file before rerunning it through the LEF parser.", $2, lefData->nonDefaultRuleName);
               lefError(1619, lefData->outMsg);
               lefFree(lefData->nonDefaultRuleName);
--- 3692,3698 ----
          if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
            if (lefData->nonDefaultWarnings++ < lefSettings->NonDefaultWarnings) {
               lefData->outMsg = (char*)lefMalloc(10000);
!              snprintf (lefData->outMsg, 10000,
                  "END NONDEFAULTRULE name %s is different from the NONDEFAULTRULE name %s.\nCorrect the LEF file before rerunning it through the LEF parser.", $2, lefData->nonDefaultRuleName);
               lefError(1619, lefData->outMsg);
               lefFree(lefData->nonDefaultRuleName);
***************
*** 3710,3716 ****
            if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
              if (lefData->nonDefaultWarnings++ < lefSettings->NonDefaultWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                   "HARDSPACING statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1620, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 3715,3721 ----
            if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
              if (lefData->nonDefaultWarnings++ < lefSettings->NonDefaultWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                   "HARDSPACING statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1620, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 3742,3748 ****
         if (lefData->versionNum < 5.6) {
            if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
               lefData->outMsg = (char*)lefMalloc(10000);
!              sprintf (lefData->outMsg,
                 "USEVIA statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
               lefError(1621, lefData->outMsg);
               lefFree(lefData->outMsg);
--- 3747,3753 ----
         if (lefData->versionNum < 5.6) {
            if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
               lefData->outMsg = (char*)lefMalloc(10000);
!              snprintf (lefData->outMsg, 10000,
                 "USEVIA statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
               lefError(1621, lefData->outMsg);
               lefFree(lefData->outMsg);
***************
*** 3760,3766 ****
            if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
               if (lefData->nonDefaultWarnings++ < lefSettings->NonDefaultWarnings) {
                  lefData->outMsg = (char*)lefMalloc(10000);
!                 sprintf (lefData->outMsg,
                    "USEVIARULE statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                  lefError(1622, lefData->outMsg);
                  lefFree(lefData->outMsg);
--- 3765,3771 ----
            if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
               if (lefData->nonDefaultWarnings++ < lefSettings->NonDefaultWarnings) {
                  lefData->outMsg = (char*)lefMalloc(10000);
!                 snprintf (lefData->outMsg, 10000,
                    "USEVIARULE statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                  lefError(1622, lefData->outMsg);
                  lefFree(lefData->outMsg);
***************
*** 3779,3785 ****
            if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
               if (lefData->nonDefaultWarnings++ < lefSettings->NonDefaultWarnings) {
                  lefData->outMsg = (char*)lefMalloc(10000);
!                 sprintf (lefData->outMsg,
                    "MINCUTS statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                  lefError(1623, lefData->outMsg);
                  lefFree(lefData->outMsg);
--- 3784,3790 ----
            if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
               if (lefData->nonDefaultWarnings++ < lefSettings->NonDefaultWarnings) {
                  lefData->outMsg = (char*)lefMalloc(10000);
!                 snprintf (lefData->outMsg, 10000,
                    "MINCUTS statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                  lefError(1623, lefData->outMsg);
                  lefFree(lefData->outMsg);
***************
*** 3825,3831 ****
        if (lefCallbacks->NonDefaultCbk) {
           char temp[32];
           char propTp;
!          sprintf(temp, "%.11g", $2);
           propTp = lefSettings->lefProps.lefrNondefProp.propType($1);
           lefData->lefrNonDefault.addNumProp($1, $2, temp, propTp);
        }
--- 3830,3836 ----
        if (lefCallbacks->NonDefaultCbk) {
           char temp[32];
           char propTp;
!          snprintf(temp, 32, "%.11g", $2);
           propTp = lefSettings->lefProps.lefrNondefProp.propType($1);
           lefData->lefrNonDefault.addNumProp($1, $2, temp, propTp);
        }
***************
*** 3851,3857 ****
        if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
           if (lefData->nonDefaultWarnings++ < lefSettings->NonDefaultWarnings) {
              lefData->outMsg = (char*)lefMalloc(10000);
!             sprintf (lefData->outMsg,
                 "END LAYER name %s is different from the LAYER name %s.\nCorrect the LEF file before rerunning it through the LEF parser.", $3, lefData->layerName);
              lefError(1624, lefData->outMsg);
              lefFree(lefData->outMsg);
--- 3856,3862 ----
        if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
           if (lefData->nonDefaultWarnings++ < lefSettings->NonDefaultWarnings) {
              lefData->outMsg = (char*)lefMalloc(10000);
!             snprintf (lefData->outMsg, 10000,
                 "END LAYER name %s is different from the LAYER name %s.\nCorrect the LEF file before rerunning it through the LEF parser.", $3, lefData->layerName);
              lefError(1624, lefData->outMsg);
              lefFree(lefData->outMsg);
***************
*** 3875,3881 ****
        if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
           if (lefData->nonDefaultWarnings++ < lefSettings->NonDefaultWarnings) {
              lefData->outMsg = (char*)lefMalloc(10000);
!             sprintf (lefData->outMsg,
                 "A SPACING statement is required in the LAYER statement in NONDEFAULTRULE for lef file with version 5.5 and earlier.\nYour lef file is defined with version %g. Update your lef to add a LAYER statement and try again.",
                  lefData->versionNum);
              lefError(1626, lefData->outMsg);
--- 3880,3886 ----
        if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
           if (lefData->nonDefaultWarnings++ < lefSettings->NonDefaultWarnings) {
              lefData->outMsg = (char*)lefMalloc(10000);
!             snprintf (lefData->outMsg, 10000,
                 "A SPACING statement is required in the LAYER statement in NONDEFAULTRULE for lef file with version 5.5 and earlier.\nYour lef file is defined with version %g. Update your lef to add a LAYER statement and try again.",
                  lefData->versionNum);
              lefError(1626, lefData->outMsg);
***************
*** 3910,3916 ****
           if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
              if (lefData->nonDefaultWarnings++ < lefSettings->NonDefaultWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                   "RESISTANCE RPERSQ statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1627, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 3915,3921 ----
           if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
              if (lefData->nonDefaultWarnings++ < lefSettings->NonDefaultWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                   "RESISTANCE RPERSQ statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1627, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 3934,3940 ****
           if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
              if (lefData->nonDefaultWarnings++ < lefSettings->NonDefaultWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                   "CAPACITANCE CPERSQDIST statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1628, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 3939,3945 ----
           if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
              if (lefData->nonDefaultWarnings++ < lefSettings->NonDefaultWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                   "CAPACITANCE CPERSQDIST statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1628, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 3957,3963 ****
           if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
              if (lefData->nonDefaultWarnings++ < lefSettings->NonDefaultWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                   "EDGECAPACITANCE statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1629, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 3962,3968 ----
           if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
              if (lefData->nonDefaultWarnings++ < lefSettings->NonDefaultWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                   "EDGECAPACITANCE statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1629, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 3977,3983 ****
           if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
              if (lefData->nonDefaultWarnings++ < lefSettings->NonDefaultWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                   "DIAGWIDTH statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1630, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 3982,3988 ----
           if (lefCallbacks->NonDefaultCbk) { // write error only if cbk is set 
              if (lefData->nonDefaultWarnings++ < lefSettings->NonDefaultWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                   "DIAGWIDTH statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                 lefError(1630, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 4012,4018 ****
          if (lefCallbacks->SiteCbk) { // write error only if cbk is set 
             if (lefData->siteWarnings++ < lefSettings->SiteWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "END SITE name %s is different from the SITE name %s.\nCorrect the LEF file before rerunning it through the LEF parser.", $3, lefData->siteName);
                lefError(1631, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 4017,4023 ----
          if (lefCallbacks->SiteCbk) { // write error only if cbk is set 
             if (lefData->siteWarnings++ < lefSettings->SiteWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "END SITE name %s is different from the SITE name %s.\nCorrect the LEF file before rerunning it through the LEF parser.", $3, lefData->siteName);
                lefError(1631, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 4130,4136 ****
          if (lefCallbacks->MacroEndCbk) { // write error only if cbk is set 
             if (lefData->macroWarnings++ < lefSettings->MacroWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "END MACRO name %s is different from the MACRO name %s.\nCorrect the LEF file before rerunning it through the LEF parser.", $3, lefData->macroName);
                lefError(1634, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 4135,4141 ----
          if (lefCallbacks->MacroEndCbk) { // write error only if cbk is set 
             if (lefData->macroWarnings++ < lefSettings->MacroWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "END MACRO name %s is different from the MACRO name %s.\nCorrect the LEF file before rerunning it through the LEF parser.", $3, lefData->macroName);
                lefError(1634, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 4224,4230 ****
    T_STRING NUMBER
      {
        char temp[32];
!       sprintf(temp, "%.11g", $2);
        if (lefCallbacks->MacroCbk) {
           char propTp;
           propTp = lefSettings->lefProps.lefrMacroProp.propType($1);
--- 4229,4235 ----
    T_STRING NUMBER
      {
        char temp[32];
!       snprintf(temp, 32, "%.11g", $2);
        if (lefCallbacks->MacroCbk) {
           char propTp;
           propTp = lefSettings->lefProps.lefrMacroProp.propType($1);
***************
*** 4266,4272 ****
                   lefWarning(2033, "The statement COVER BUMP is a LEF verion 5.5 syntax.\nYour LEF file is version 5.4 or earlier which is incorrect but will be allowed\nbecause this application does not enforce strict version checking.\nOther tools that enforce strict checking will have a syntax error when reading this file.\nYou can change the VERSION statement in this LEF file to 5.5 or higher to stop this warning.");
                else {
                   lefData->outMsg = (char*)lefMalloc(10000);
!                  sprintf (lefData->outMsg,
                      "COVER BUMP statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                   lefError(1635, lefData->outMsg);
                   lefFree(lefData->outMsg);
--- 4271,4277 ----
                   lefWarning(2033, "The statement COVER BUMP is a LEF verion 5.5 syntax.\nYour LEF file is version 5.4 or earlier which is incorrect but will be allowed\nbecause this application does not enforce strict version checking.\nOther tools that enforce strict checking will have a syntax error when reading this file.\nYou can change the VERSION statement in this LEF file to 5.5 or higher to stop this warning.");
                else {
                   lefData->outMsg = (char*)lefMalloc(10000);
!                  snprintf (lefData->outMsg, 10000,
                      "COVER BUMP statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                   lefError(1635, lefData->outMsg);
                   lefFree(lefData->outMsg);
***************
*** 4287,4293 ****
                  lefWarning(2034, "The statement BLOCK BLACKBOX is a LEF verion 5.5 syntax.\nYour LEF file is version 5.4 or earlier which is incorrect but will be allowed\nbecause this application does not enforce strict version checking.\nOther tools that enforce strict checking will have a syntax error when reading this file.\nYou can change the VERSION statement in this LEF file to 5.5 or higher to stop this warning.");
                else {
                   lefData->outMsg = (char*)lefMalloc(10000);
!                  sprintf (lefData->outMsg,
                      "BLOCK BLACKBOX statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                   lefError(1636, lefData->outMsg);
                   lefFree(lefData->outMsg);
--- 4292,4298 ----
                  lefWarning(2034, "The statement BLOCK BLACKBOX is a LEF verion 5.5 syntax.\nYour LEF file is version 5.4 or earlier which is incorrect but will be allowed\nbecause this application does not enforce strict version checking.\nOther tools that enforce strict checking will have a syntax error when reading this file.\nYou can change the VERSION statement in this LEF file to 5.5 or higher to stop this warning.");
                else {
                   lefData->outMsg = (char*)lefMalloc(10000);
!                  snprintf (lefData->outMsg, 10000,
                      "BLOCK BLACKBOX statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                   lefError(1636, lefData->outMsg);
                   lefFree(lefData->outMsg);
***************
*** 4305,4311 ****
          if (lefCallbacks->MacroCbk) { // write error only if cbk is set 
             if (lefData->macroWarnings++ < lefSettings->MacroWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "BLOCK SOFT statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1637, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 4310,4316 ----
          if (lefCallbacks->MacroCbk) { // write error only if cbk is set 
             if (lefData->macroWarnings++ < lefSettings->MacroWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "BLOCK SOFT statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1637, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 4321,4327 ****
        {
          if (lefData->versionNum < 5.7) {
            lefData->outMsg = (char*)lefMalloc(10000);
!           sprintf(lefData->outMsg,
              "BUMP is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
            lefError(1698, lefData->outMsg);
            lefFree(lefData->outMsg);
--- 4326,4332 ----
        {
          if (lefData->versionNum < 5.7) {
            lefData->outMsg = (char*)lefMalloc(10000);
!           snprintf(lefData->outMsg, 10000,
              "BUMP is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
            lefError(1698, lefData->outMsg);
            lefFree(lefData->outMsg);
***************
*** 4332,4342 ****
    | K_PAD     {$$ = (char*)"PAD"; } 
    | K_VIRTUAL {$$ = (char*)"VIRTUAL"; }
    | K_PAD  pad_type 
!       {  sprintf(lefData->temp_name, "PAD %s", $2);
          $$ = lefData->temp_name; 
          if (lefData->versionNum < 5.5) {
             if (strcmp("AREAIO", $2) != 0) {
!              sprintf(lefData->temp_name, "PAD %s", $2);
               $$ = lefData->temp_name; 
             } else if (lefCallbacks->MacroCbk) { 
               if (lefData->macroWarnings++ < lefSettings->MacroWarnings) {
--- 4337,4347 ----
    | K_PAD     {$$ = (char*)"PAD"; } 
    | K_VIRTUAL {$$ = (char*)"VIRTUAL"; }
    | K_PAD  pad_type 
!       {  snprintf(lefData->temp_name, 258, "PAD %s", $2);
          $$ = lefData->temp_name; 
          if (lefData->versionNum < 5.5) {
             if (strcmp("AREAIO", $2) != 0) {
!              snprintf(lefData->temp_name, 258, "PAD %s", $2);
               $$ = lefData->temp_name; 
             } else if (lefCallbacks->MacroCbk) { 
               if (lefData->macroWarnings++ < lefSettings->MacroWarnings) {
***************
*** 4344,4350 ****
                    lefWarning(2035, "The statement PAD AREAIO is a LEF verion 5.5 syntax.\nYour LEF file is version 5.4 or earlier which is incorrect but will be allowed\nbecause this application does not enforce strict version checking.\nOther tools that enforce strict checking will have a syntax error when reading this file.\nYou can change the VERSION statement in this LEF file to 5.5 or higher to stop this warning.");
                 else {
                    lefData->outMsg = (char*)lefMalloc(10000);
!                   sprintf (lefData->outMsg,
                       "PAD AREAIO statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                    lefError(1638, lefData->outMsg);
                    lefFree(lefData->outMsg);
--- 4349,4355 ----
                    lefWarning(2035, "The statement PAD AREAIO is a LEF verion 5.5 syntax.\nYour LEF file is version 5.4 or earlier which is incorrect but will be allowed\nbecause this application does not enforce strict version checking.\nOther tools that enforce strict checking will have a syntax error when reading this file.\nYou can change the VERSION statement in this LEF file to 5.5 or higher to stop this warning.");
                 else {
                    lefData->outMsg = (char*)lefMalloc(10000);
!                   snprintf (lefData->outMsg, 10000,
                       "PAD AREAIO statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                    lefError(1638, lefData->outMsg);
                    lefFree(lefData->outMsg);
***************
*** 4362,4371 ****
        // in 'frameworks'
        }
    | K_CORE core_type
!       {sprintf(lefData->temp_name, "CORE %s", $2);
        $$ = lefData->temp_name;} 
    | K_ENDCAP endcap_type
!       {sprintf(lefData->temp_name, "ENDCAP %s", $2);
        $$ = lefData->temp_name;} 
  
  pad_type: 
--- 4367,4376 ----
        // in 'frameworks'
        }
    | K_CORE core_type
!       {snprintf(lefData->temp_name, 258, "CORE %s", $2);
        $$ = lefData->temp_name;} 
    | K_ENDCAP endcap_type
!       {snprintf(lefData->temp_name, 258, "ENDCAP %s", $2);
        $$ = lefData->temp_name;} 
  
  pad_type: 
***************
*** 4388,4394 ****
          if (lefCallbacks->MacroCbk) { // write error only if cbk is set 
             if (lefData->macroWarnings++ < lefSettings->MacroWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "SPACER statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1639, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 4393,4399 ----
          if (lefCallbacks->MacroCbk) { // write error only if cbk is set 
             if (lefData->macroWarnings++ < lefSettings->MacroWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "SPACER statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1639, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 4407,4413 ****
          if (lefCallbacks->MacroCbk) { // write error only if cbk is set 
             if (lefData->macroWarnings++ < lefSettings->MacroWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "ANTENNACELL statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1640, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 4412,4418 ----
          if (lefCallbacks->MacroCbk) { // write error only if cbk is set 
             if (lefData->macroWarnings++ < lefSettings->MacroWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "ANTENNACELL statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1640, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 4426,4432 ****
          if (lefCallbacks->MacroCbk) { // write error only if cbk is set 
             if (lefData->macroWarnings++ < lefSettings->MacroWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "WELLTAP statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1641, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 4431,4437 ----
          if (lefCallbacks->MacroCbk) { // write error only if cbk is set 
             if (lefData->macroWarnings++ < lefSettings->MacroWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "WELLTAP statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1641, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 4631,4637 ****
          if (lefCallbacks->MacroCbk) { // write error only if cbk is set 
             if (lefData->macroWarnings++ < lefSettings->MacroWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "END PIN name %s is different from the PIN name %s.\nCorrect the LEF file before rerunning it through the LEF parser.", $3, lefData->pinName);
                lefError(1643, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 4636,4642 ----
          if (lefCallbacks->MacroCbk) { // write error only if cbk is set 
             if (lefData->macroWarnings++ < lefSettings->MacroWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "END PIN name %s is different from the PIN name %s.\nCorrect the LEF file before rerunning it through the LEF parser.", $3, lefData->pinName);
                lefError(1643, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 4952,4958 ****
             if (lefCallbacks->PinCbk) { // write error only if cbk is set 
               if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                  lefData->outMsg = (char*)lefMalloc(10000);
!                 sprintf (lefData->outMsg,
                     "ANTENNASIZE statement is a version 5.3 and earlier syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                  lefError(1644, lefData->outMsg);
                  lefFree(lefData->outMsg);
--- 4957,4963 ----
             if (lefCallbacks->PinCbk) { // write error only if cbk is set 
               if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                  lefData->outMsg = (char*)lefMalloc(10000);
!                 snprintf (lefData->outMsg, 10000,
                     "ANTENNASIZE statement is a version 5.3 and earlier syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                  lefError(1644, lefData->outMsg);
                  lefFree(lefData->outMsg);
***************
*** 4973,4979 ****
             if (lefCallbacks->PinCbk) { // write error only if cbk is set 
                if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                   lefData->outMsg = (char*)lefMalloc(10000);
!                  sprintf (lefData->outMsg,
                      "ANTENNAMETALAREA statement is a version 5.3 and earlier syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                   lefError(1645, lefData->outMsg);
                   lefFree(lefData->outMsg);
--- 4978,4984 ----
             if (lefCallbacks->PinCbk) { // write error only if cbk is set 
                if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                   lefData->outMsg = (char*)lefMalloc(10000);
!                  snprintf (lefData->outMsg, 10000,
                      "ANTENNAMETALAREA statement is a version 5.3 and earlier syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                   lefError(1645, lefData->outMsg);
                   lefFree(lefData->outMsg);
***************
*** 4994,5000 ****
             if (lefCallbacks->PinCbk) { // write error only if cbk is set 
                if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                   lefData->outMsg = (char*)lefMalloc(10000);
!                  sprintf (lefData->outMsg,
                      "ANTENNAMETALLENGTH statement is a version 5.3 and earlier syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                   lefError(1646, lefData->outMsg);
                   lefFree(lefData->outMsg);
--- 4999,5005 ----
             if (lefCallbacks->PinCbk) { // write error only if cbk is set 
                if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                   lefData->outMsg = (char*)lefMalloc(10000);
!                  snprintf (lefData->outMsg, 10000,
                      "ANTENNAMETALLENGTH statement is a version 5.3 and earlier syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                   lefError(1646, lefData->outMsg);
                   lefFree(lefData->outMsg);
***************
*** 5018,5024 ****
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "ANTENNAPARTIALMETALAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1647, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5023,5029 ----
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "ANTENNAPARTIALMETALAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1647, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 5029,5035 ****
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "ANTENNAPARTIALMETALAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1647, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5034,5040 ----
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "ANTENNAPARTIALMETALAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1647, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 5048,5054 ****
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "ANTENNAPARTIALMETALSIDEAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1648, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5053,5059 ----
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "ANTENNAPARTIALMETALSIDEAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1648, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 5059,5065 ****
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "ANTENNAPARTIALMETALSIDEAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1648, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5064,5070 ----
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "ANTENNAPARTIALMETALSIDEAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1648, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 5078,5084 ****
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "ANTENNAPARTIALCUTAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1649, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5083,5089 ----
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "ANTENNAPARTIALCUTAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1649, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 5089,5095 ****
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "ANTENNAPARTIALCUTAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1649, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5094,5100 ----
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "ANTENNAPARTIALCUTAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1649, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 5108,5114 ****
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "ANTENNADIFFAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1650, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5113,5119 ----
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "ANTENNADIFFAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1650, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 5119,5125 ****
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "ANTENNADIFFAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1650, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5124,5130 ----
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "ANTENNADIFFAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1650, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 5138,5144 ****
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "ANTENNAGATEAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1651, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5143,5149 ----
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "ANTENNAGATEAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1651, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 5149,5155 ****
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "ANTENNAGATEAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1651, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5154,5160 ----
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "ANTENNAGATEAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1651, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 5168,5174 ****
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "ANTENNAMAXAREACAR statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1652, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5173,5179 ----
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "ANTENNAMAXAREACAR statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1652, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 5179,5185 ****
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "ANTENNAMAXAREACAR statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1652, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5184,5190 ----
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "ANTENNAMAXAREACAR statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1652, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 5198,5204 ****
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "ANTENNAMAXSIDEAREACAR statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1653, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5203,5209 ----
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "ANTENNAMAXSIDEAREACAR statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1653, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 5209,5215 ****
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "ANTENNAMAXSIDEAREACAR statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1653, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5214,5220 ----
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "ANTENNAMAXSIDEAREACAR statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1653, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 5228,5234 ****
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "ANTENNAMAXCUTCAR statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1654, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5233,5239 ----
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "ANTENNAMAXCUTCAR statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1654, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 5239,5245 ****
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "ANTENNAMAXCUTCAR statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1654, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5244,5250 ----
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "ANTENNAMAXCUTCAR statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1654, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 5258,5264 ****
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "ANTENNAMODEL statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1655, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5263,5269 ----
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "ANTENNAMODEL statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1655, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 5269,5275 ****
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "ANTENNAMODEL statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1655, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5274,5280 ----
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "ANTENNAMODEL statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1655, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 5285,5291 ****
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "NETEXPR statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1656, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5290,5296 ----
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "NETEXPR statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1656, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 5301,5307 ****
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "SUPPLYSENSITIVITY statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1657, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5306,5312 ----
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "SUPPLYSENSITIVITY statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1657, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 5317,5323 ****
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "GROUNDSENSITIVITY statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1658, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5322,5328 ----
          if (lefCallbacks->PinCbk) { // write error only if cbk is set 
             if (lefData->pinWarnings++ < lefSettings->PinWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "GROUNDSENSITIVITY statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1658, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 5359,5365 ****
    T_STRING NUMBER
      { 
        char temp[32];
!       sprintf(temp, "%.11g", $2);
        if (lefCallbacks->PinCbk) {
           char propTp;
           propTp = lefSettings->lefProps.lefrPinProp.propType($1);
--- 5364,5370 ----
    T_STRING NUMBER
      { 
        char temp[32];
!       snprintf(temp, 32, "%.11g", $2);
        if (lefCallbacks->PinCbk) {
           char propTp;
           propTp = lefSettings->lefProps.lefrPinProp.propType($1);
***************
*** 5595,5601 ****
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         sprintf(lefData->outMsg,
            "EXCEPTPGNET is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1699, lefData->outMsg);
          lefFree(lefData->outMsg);
--- 5600,5606 ----
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         snprintf(lefData->outMsg, 10000,
            "EXCEPTPGNET is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1699, lefData->outMsg);
          lefFree(lefData->outMsg);
***************
*** 5613,5619 ****
             lefData->lefrGeometriesPtr->addLayerMinSpacing($2);
          else {
             lefData->outMsg = (char*)lefMalloc(10000);
!            sprintf (lefData->outMsg,
                "THE SPACING statement has the value %g in MACRO OBS.\nValue has to be 0 or greater.", $2);
             lefError(1659, lefData->outMsg);
             lefFree(lefData->outMsg);
--- 5618,5624 ----
             lefData->lefrGeometriesPtr->addLayerMinSpacing($2);
          else {
             lefData->outMsg = (char*)lefMalloc(10000);
!            snprintf (lefData->outMsg, 10000,
                "THE SPACING statement has the value %g in MACRO OBS.\nValue has to be 0 or greater.", $2);
             lefError(1659, lefData->outMsg);
             lefFree(lefData->outMsg);
***************
*** 5627,5633 ****
             lefData->lefrGeometriesPtr->addLayerRuleWidth($2);
          else {
             lefData->outMsg = (char*)lefMalloc(10000);
!            sprintf (lefData->outMsg,
                "THE DESIGNRULEWIDTH statement has the value %g in MACRO OBS.\nValue has to be 0 or greater.", $2);
             lefError(1660, lefData->outMsg);
             lefFree(lefData->outMsg);
--- 5632,5638 ----
             lefData->lefrGeometriesPtr->addLayerRuleWidth($2);
          else {
             lefData->outMsg = (char*)lefMalloc(10000);
!            snprintf (lefData->outMsg, 10000,
                "THE DESIGNRULEWIDTH statement has the value %g in MACRO OBS.\nValue has to be 0 or greater.", $2);
             lefError(1660, lefData->outMsg);
             lefFree(lefData->outMsg);
***************
*** 5814,5820 ****
          if (lefCallbacks->DensityCbk) { // write error only if cbk is set 
             if (lefData->macroWarnings++ < lefSettings->MacroWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "DENSITY statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1661, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 5819,5825 ----
          if (lefCallbacks->DensityCbk) { // write error only if cbk is set 
             if (lefData->macroWarnings++ < lefSettings->MacroWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "DENSITY statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1661, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 6060,6066 ****
          if (lefCallbacks->ArrayCbk) { // write error only if cbk is set 
             if (lefData->arrayWarnings++ < lefSettings->ArrayWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "END ARRAY name %s is different from the ARRAY name %s.\nCorrect the LEF file before rerunning it through the LEF parser.", $3, lefData->arrayName);
                lefError(1662, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 6065,6071 ----
          if (lefCallbacks->ArrayCbk) { // write error only if cbk is set 
             if (lefData->arrayWarnings++ < lefSettings->ArrayWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "END ARRAY name %s is different from the ARRAY name %s.\nCorrect the LEF file before rerunning it through the LEF parser.", $3, lefData->arrayName);
                lefError(1662, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 6370,6381 ****
      }
      
  prop_define:
!   K_INTEGER { lefData->lefRealNum = 0 } opt_def_range opt_def_value 
      { 
        if (lefCallbacks->PropCbk) lefData->lefrProp.setPropInteger();
!       lefData->lefPropDefType = 'I'
      }
!   | K_REAL { lefData->lefRealNum = 1 } opt_def_range opt_def_value
      { 
        if (lefCallbacks->PropCbk) lefData->lefrProp.setPropReal();
        lefData->lefPropDefType = 'R';
--- 6375,6386 ----
      }
      
  prop_define:
!   K_INTEGER { lefData->lefRealNum = 0; } opt_def_range opt_def_value
      { 
        if (lefCallbacks->PropCbk) lefData->lefrProp.setPropInteger();
!       lefData->lefPropDefType = 'I';
      }
!   | K_REAL { lefData->lefRealNum = 1; } opt_def_range opt_def_value
      { 
        if (lefCallbacks->PropCbk) lefData->lefrProp.setPropReal();
        lefData->lefPropDefType = 'R';
***************
*** 6384,6400 ****
    | K_STRING
      {
        if (lefCallbacks->PropCbk) lefData->lefrProp.setPropString();
!       lefData->lefPropDefType = 'S'
      }
    | K_STRING QSTRING
      {
        if (lefCallbacks->PropCbk) lefData->lefrProp.setPropQString($2);
!       lefData->lefPropDefType = 'Q'
      }
    | K_NAMEMAPSTRING T_STRING
      {
        if (lefCallbacks->PropCbk) lefData->lefrProp.setPropNameMapString($2);
!       lefData->lefPropDefType = 'S'
      }
  
  opt_range_second:
--- 6389,6405 ----
    | K_STRING
      {
        if (lefCallbacks->PropCbk) lefData->lefrProp.setPropString();
!       lefData->lefPropDefType = 'S';
      }
    | K_STRING QSTRING
      {
        if (lefCallbacks->PropCbk) lefData->lefrProp.setPropQString($2);
!       lefData->lefPropDefType = 'Q';
      }
    | K_NAMEMAPSTRING T_STRING
      {
        if (lefCallbacks->PropCbk) lefData->lefrProp.setPropNameMapString($2);
!       lefData->lefPropDefType = 'S';
      }
  
  opt_range_second:
***************
*** 6482,6488 ****
          if (lefData->versionNum < 5.6) {
             if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "CENTERTOCENTER statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1664, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 6487,6493 ----
          if (lefData->versionNum < 5.6) {
             if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "CENTERTOCENTER statement is a version 5.6 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1664, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 6511,6517 ****
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         sprintf(lefData->outMsg,
            "SAMENET is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1684, lefData->outMsg);
          lefFree(lefData->outMsg);
--- 6516,6522 ----
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         snprintf(lefData->outMsg, 10000,
            "SAMENET is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1684, lefData->outMsg);
          lefFree(lefData->outMsg);
***************
*** 6522,6528 ****
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         sprintf(lefData->outMsg,
            "PARALLELOVERLAP is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1680, lefData->outMsg);
          lefFree(lefData->outMsg);
--- 6527,6533 ----
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         snprintf(lefData->outMsg, 10000,
            "PARALLELOVERLAP is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1680, lefData->outMsg);
          lefFree(lefData->outMsg);
***************
*** 6566,6572 ****
          if (lefData->versionNum < 5.5) {
             if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               sprintf (lefData->outMsg,
                   "ADJACENTCUTS statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1668, lefData->outMsg);
                lefFree(lefData->outMsg);
--- 6571,6577 ----
          if (lefData->versionNum < 5.5) {
             if (lefData->layerWarnings++ < lefSettings->LayerWarnings) {
                lefData->outMsg = (char*)lefMalloc(10000);
!               snprintf (lefData->outMsg, 10000,
                   "ADJACENTCUTS statement is a version 5.5 and later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
                lefError(1668, lefData->outMsg);
                lefFree(lefData->outMsg);
***************
*** 6589,6595 ****
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         sprintf(lefData->outMsg,
            "AREA is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1693, lefData->outMsg);
          lefFree(lefData->outMsg);
--- 6594,6600 ----
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         snprintf(lefData->outMsg, 10000,
            "AREA is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1693, lefData->outMsg);
          lefFree(lefData->outMsg);
***************
*** 6636,6642 ****
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         sprintf(lefData->outMsg,
            "ENDOFLINE is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1681, lefData->outMsg);
          lefFree(lefData->outMsg);
--- 6641,6647 ----
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         snprintf(lefData->outMsg, 10000,
            "ENDOFLINE is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1681, lefData->outMsg);
          lefFree(lefData->outMsg);
***************
*** 6647,6653 ****
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         sprintf(lefData->outMsg,
            "NOTCHLENGTH is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1682, lefData->outMsg);
          lefFree(lefData->outMsg);
--- 6652,6658 ----
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         snprintf(lefData->outMsg, 10000,
            "NOTCHLENGTH is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1682, lefData->outMsg);
          lefFree(lefData->outMsg);
***************
*** 6661,6667 ****
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         sprintf(lefData->outMsg,
            "ENDOFNOTCHWIDTH is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1696, lefData->outMsg);
          lefFree(lefData->outMsg);
--- 6666,6672 ----
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         snprintf(lefData->outMsg, 10000,
            "ENDOFNOTCHWIDTH is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1696, lefData->outMsg);
          lefFree(lefData->outMsg);
***************
*** 6688,6694 ****
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         sprintf(lefData->outMsg,
            "EXCEPTSAMEPGNET is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1683, lefData->outMsg);
          lefFree(lefData->outMsg);
--- 6693,6699 ----
      {
        if (lefData->versionNum < 5.7) {
          lefData->outMsg = (char*)lefMalloc(10000);
!         snprintf(lefData->outMsg, 10000,
            "EXCEPTSAMEPGNET is a version 5.7 or later syntax.\nYour lef file is defined with version %g.", lefData->versionNum);
          lefError(1683, lefData->outMsg);
          lefFree(lefData->outMsg);
***************
*** 6912,6918 ****
                if (lefCallbacks->InputAntennaCbk) { // write warning only if cbk is set 
                  if (lefData->inputAntennaWarnings++ < lefSettings->InputAntennaWarnings) {
                     lefData->outMsg = (char*)lefMalloc(10000);
!                    sprintf (lefData->outMsg,
                        "INPUTPINANTENNASIZE statement is a version 5.3 or earlier syntax.\nYour lef file with version %g, has both old and new INPUTPINANTENNASIZE syntax, which is incorrect.", lefData->versionNum);
                     lefError(1671, lefData->outMsg);
                     lefFree(lefData->outMsg);
--- 6917,6923 ----
                if (lefCallbacks->InputAntennaCbk) { // write warning only if cbk is set 
                  if (lefData->inputAntennaWarnings++ < lefSettings->InputAntennaWarnings) {
                     lefData->outMsg = (char*)lefMalloc(10000);
!                    snprintf (lefData->outMsg, 10000,
                        "INPUTPINANTENNASIZE statement is a version 5.3 or earlier syntax.\nYour lef file with version %g, has both old and new INPUTPINANTENNASIZE syntax, which is incorrect.", lefData->versionNum);
                     lefError(1671, lefData->outMsg);
                     lefFree(lefData->outMsg);
***************
*** 6936,6942 ****
                if (lefCallbacks->OutputAntennaCbk) { // write warning only if cbk is set 
                  if (lefData->outputAntennaWarnings++ < lefSettings->OutputAntennaWarnings) {
                     lefData->outMsg = (char*)lefMalloc(10000);
!                    sprintf (lefData->outMsg,
                        "OUTPUTPINANTENNASIZE statement is a version 5.3 or earlier syntax.\nYour lef file with version %g, has both old and new OUTPUTPINANTENNASIZE syntax, which is incorrect.", lefData->versionNum);
                     lefError(1672, lefData->outMsg);
                     lefFree(lefData->outMsg);
--- 6941,6947 ----
                if (lefCallbacks->OutputAntennaCbk) { // write warning only if cbk is set 
                  if (lefData->outputAntennaWarnings++ < lefSettings->OutputAntennaWarnings) {
                     lefData->outMsg = (char*)lefMalloc(10000);
!                    snprintf (lefData->outMsg, 10000,
                        "OUTPUTPINANTENNASIZE statement is a version 5.3 or earlier syntax.\nYour lef file with version %g, has both old and new OUTPUTPINANTENNASIZE syntax, which is incorrect.", lefData->versionNum);
                     lefError(1672, lefData->outMsg);
                     lefFree(lefData->outMsg);
***************
*** 6960,6966 ****
                if (lefCallbacks->InoutAntennaCbk) { // write warning only if cbk is set 
                  if (lefData->inoutAntennaWarnings++ < lefSettings->InoutAntennaWarnings) {
                     lefData->outMsg = (char*)lefMalloc(10000);
!                    sprintf (lefData->outMsg,
                        "INOUTPINANTENNASIZE statement is a version 5.3 or earlier syntax.\nYour lef file with version %g, has both old and new INOUTPINANTENNASIZE syntax, which is incorrect.", lefData->versionNum);
                     lefError(1673, lefData->outMsg);
                     lefFree(lefData->outMsg);
--- 6965,6971 ----
                if (lefCallbacks->InoutAntennaCbk) { // write warning only if cbk is set 
                  if (lefData->inoutAntennaWarnings++ < lefSettings->InoutAntennaWarnings) {
                     lefData->outMsg = (char*)lefMalloc(10000);
!                    snprintf (lefData->outMsg, 10000,
                        "INOUTPINANTENNASIZE statement is a version 5.3 or earlier syntax.\nYour lef file with version %g, has both old and new INOUTPINANTENNASIZE syntax, which is incorrect.", lefData->versionNum);
                     lefError(1673, lefData->outMsg);
                     lefFree(lefData->outMsg);
***************
*** 6984,6990 ****
             if (lefCallbacks->AntennaInputCbk) { // write warning only if cbk is set 
               if (lefData->antennaInputWarnings++ < lefSettings->AntennaInputWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                sprintf (lefData->outMsg,
                    "ANTENNAINPUTGATEAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.\nEither update your VERSION number or use the 5.3 syntax.", lefData->versionNum);
                 lefError(1674, lefData->outMsg);
                 lefFree(lefData->outMsg);
--- 6989,6995 ----
             if (lefCallbacks->AntennaInputCbk) { // write warning only if cbk is set 
               if (lefData->antennaInputWarnings++ < lefSettings->AntennaInputWarnings) {
                 lefData->outMsg = (char*)lefMalloc(10000);
!                snprintf (lefData->outMsg, 10000,
                    "ANTENNAINPUTGATEAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.\nEither update your VERSION number or use the 5.3 syntax.", lefData->versionNum);
                 lefError(1674, lefData->outMsg);
                 lefFree(lefData->outMsg);
***************
*** 6995,7001 ****
             if (lefCallbacks->AntennaInputCbk) { // write warning only if cbk is set 
               if (lefData->antennaInputWarnings++ < lefSettings->AntennaInputWarnings) {
                  lefData->outMsg = (char*)lefMalloc(10000);
!                 sprintf (lefData->outMsg,
                     "ANTENNAINPUTGATEAREA statement is a version 5.4 or later syntax.\nYour lef file with version %g, has both old and new ANTENNAINPUTGATEAREA syntax, which is incorrect.", lefData->versionNum);
                  lefError(1675, lefData->outMsg);
                  lefFree(lefData->outMsg);
--- 7000,7006 ----
             if (lefCallbacks->AntennaInputCbk) { // write warning only if cbk is set 
               if (lefData->antennaInputWarnings++ < lefSettings->AntennaInputWarnings) {
                  lefData->outMsg = (char*)lefMalloc(10000);
!                 snprintf (lefData->outMsg, 10000,
                     "ANTENNAINPUTGATEAREA statement is a version 5.4 or later syntax.\nYour lef file with version %g, has both old and new ANTENNAINPUTGATEAREA syntax, which is incorrect.", lefData->versionNum);
                  lefError(1675, lefData->outMsg);
                  lefFree(lefData->outMsg);
***************
*** 7018,7024 ****
             if (lefCallbacks->AntennaInoutCbk) { // write warning only if cbk is set 
                if (lefData->antennaInoutWarnings++ < lefSettings->AntennaInoutWarnings) {
                   lefData->outMsg = (char*)lefMalloc(10000);
!                  sprintf (lefData->outMsg,
                      "ANTENNAINOUTDIFFAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.\nEither update your VERSION number or use the 5.3 syntax.", lefData->versionNum);
                   lefError(1676, lefData->outMsg);
                   lefFree(lefData->outMsg);
--- 7023,7029 ----
             if (lefCallbacks->AntennaInoutCbk) { // write warning only if cbk is set 
                if (lefData->antennaInoutWarnings++ < lefSettings->AntennaInoutWarnings) {
                   lefData->outMsg = (char*)lefMalloc(10000);
!                  snprintf (lefData->outMsg, 10000,
                      "ANTENNAINOUTDIFFAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.\nEither update your VERSION number or use the 5.3 syntax.", lefData->versionNum);
                   lefError(1676, lefData->outMsg);
                   lefFree(lefData->outMsg);
***************
*** 7029,7035 ****
             if (lefCallbacks->AntennaInoutCbk) { // write warning only if cbk is set 
                if (lefData->antennaInoutWarnings++ < lefSettings->AntennaInoutWarnings) {
                   lefData->outMsg = (char*)lefMalloc(10000);
!                  sprintf (lefData->outMsg,
                      "ANTENNAINOUTDIFFAREA statement is a version 5.4 or later syntax.\nYour lef file with version %g, has both old and new ANTENNAINOUTDIFFAREA syntax, which is incorrect.", lefData->versionNum);
                   lefError(1677, lefData->outMsg);
                   lefFree(lefData->outMsg);
--- 7034,7040 ----
             if (lefCallbacks->AntennaInoutCbk) { // write warning only if cbk is set 
                if (lefData->antennaInoutWarnings++ < lefSettings->AntennaInoutWarnings) {
                   lefData->outMsg = (char*)lefMalloc(10000);
!                  snprintf (lefData->outMsg, 10000,
                      "ANTENNAINOUTDIFFAREA statement is a version 5.4 or later syntax.\nYour lef file with version %g, has both old and new ANTENNAINOUTDIFFAREA syntax, which is incorrect.", lefData->versionNum);
                   lefError(1677, lefData->outMsg);
                   lefFree(lefData->outMsg);
***************
*** 7052,7058 ****
             if (lefCallbacks->AntennaOutputCbk) { // write warning only if cbk is set 
                if (lefData->antennaOutputWarnings++ < lefSettings->AntennaOutputWarnings) {
                   lefData->outMsg = (char*)lefMalloc(10000);
!                  sprintf (lefData->outMsg,
                      "ANTENNAOUTPUTDIFFAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.\nEither update your VERSION number or use the 5.3 syntax.", lefData->versionNum);
                   lefError(1678, lefData->outMsg);
                   lefFree(lefData->outMsg);
--- 7057,7063 ----
             if (lefCallbacks->AntennaOutputCbk) { // write warning only if cbk is set 
                if (lefData->antennaOutputWarnings++ < lefSettings->AntennaOutputWarnings) {
                   lefData->outMsg = (char*)lefMalloc(10000);
!                  snprintf (lefData->outMsg, 10000,
                      "ANTENNAOUTPUTDIFFAREA statement is a version 5.4 and later syntax.\nYour lef file is defined with version %g.\nEither update your VERSION number or use the 5.3 syntax.", lefData->versionNum);
                   lefError(1678, lefData->outMsg);
                   lefFree(lefData->outMsg);
***************
*** 7063,7069 ****
             if (lefCallbacks->AntennaOutputCbk) { // write warning only if cbk is set 
                if (lefData->antennaOutputWarnings++ < lefSettings->AntennaOutputWarnings) {
                   lefData->outMsg = (char*)lefMalloc(10000);
!                  sprintf (lefData->outMsg,
                      "ANTENNAOUTPUTDIFFAREA statement is a version 5.4 or later syntax.\nYour lef file with version %g, has both old and new ANTENNAOUTPUTDIFFAREA syntax, which is incorrect.", lefData->versionNum);
                   lefError(1679, lefData->outMsg);
                   lefFree(lefData->outMsg);
--- 7068,7074 ----
             if (lefCallbacks->AntennaOutputCbk) { // write warning only if cbk is set 
                if (lefData->antennaOutputWarnings++ < lefSettings->AntennaOutputWarnings) {
                   lefData->outMsg = (char*)lefMalloc(10000);
!                  snprintf (lefData->outMsg, 10000,
                      "ANTENNAOUTPUTDIFFAREA statement is a version 5.4 or later syntax.\nYour lef file with version %g, has both old and new ANTENNAOUTPUTDIFFAREA syntax, which is incorrect.", lefData->versionNum);
                   lefError(1679, lefData->outMsg);
                   lefFree(lefData->outMsg);
diff -r -c source.lefdef/lef.orig/lef/lef_keywords.cpp lef/lef/lef_keywords.cpp
*** source.lefdef/lef.orig/lef/lef_keywords.cpp	Fri Feb  5 14:39:14 2016
--- lef/lef/lef_keywords.cpp	Sun Jan 14 10:23:04 2024
***************
*** 280,286 ****
      char    *retStr;
  
      retStr = (char*) lefMalloc(len);
!     sprintf(retStr, "\"%s\"", string);
      return retStr;
  }
  
--- 280,286 ----
      char    *retStr;
  
      retStr = (char*) lefMalloc(len);
!     snprintf(retStr, len, "\"%s\"", string);
      return retStr;
  }
  
***************
*** 754,761 ****
      }
  
      if (lefData->lefInvalidChar) {
!         outStr = (char*) lefMalloc(500 + strlen(lefData->current_token));
!         sprintf(outStr, "Invalid characters found in \'%s\'.\nThese characters might have created by character types other than English.",
                  lefData->current_token);
          lefError(1008, outStr);
          lefFree(outStr);
--- 754,762 ----
      }
  
      if (lefData->lefInvalidChar) {
!         int xlen = 500 + strlen(lefData->current_token);
!         outStr = (char*) lefMalloc(xlen);
!         snprintf(outStr, xlen, "Invalid characters found in \'%s\'.\nThese characters might have created by character types other than English.",
                  lefData->current_token);
          lefError(1008, outStr);
          lefFree(outStr);
***************
*** 796,804 ****
              if ((numVal >= lefData->leflVal) && (numVal <= lefData->lefrVal))
                  return NUMBER;   // YES, it's really a number 
              else {
!                 char *str = (char*) lefMalloc(strlen(lefData->current_token) + strlen(lefData->lefrFileName) +
!                                               350);
!                 sprintf(str,
                          "ERROR (LEFPARS-203) Number has exceed the limit for an integer. See file %s at line %d.\n",
                          lefData->lefrFileName, lefData->lef_nlines);
                  fflush(stdout);
--- 797,805 ----
              if ((numVal >= lefData->leflVal) && (numVal <= lefData->lefrVal))
                  return NUMBER;   // YES, it's really a number 
              else {
!                 int xlen = strlen(lefData->current_token) + strlen(lefData->lefrFileName) + 350;
!                 char *str = (char*) lefMalloc(xlen);
!                 snprintf(str, xlen,
                          "ERROR (LEFPARS-203) Number has exceed the limit for an integer. See file %s at line %d.\n",
                          lefData->lefrFileName, lefData->lef_nlines);
                  fflush(stdout);
***************
*** 1042,1095 ****
      // PCR 690679, probably missing space before a ';' 
      if (strcmp(s, "parse error") == 0) {
          if ((len > 1) && (lefData->current_token[len] == ';')) {
!             str = (char*) lefMalloc(strlen(lefData->current_token) + strlen(s) + strlen(lefData->lefrFileName)
!                                     + 350);
!             sprintf(str, "ERROR (LEFPARS-%d): %s, see file %s at line %d\nLast token was <%s>, space is missing before <;>\n",
                      msgNum, s, lefData->lefrFileName, lefData->lef_nlines, lefData->current_token);
          } else if ((pvLen > 1) && (lefData->pv_token[pvLen] == ';')) {
!             str = (char*) lefMalloc(strlen(lefData->pv_token) + strlen(s) + strlen(lefData->lefrFileName)
!                                     + 350);
!             sprintf(str, "ERROR (LEFPARS-%d): %s, see file %s at line %d\nLast token was <%s>, space is missing before <;>\n",
                      msgNum, s, lefData->lefrFileName, lefData->lef_nlines - 1, lefData->pv_token);
          } else if ((lefData->current_token[0] == '"') && (lefData->spaceMissing)) {
              // most likely space is missing after the end " 
!             str = (char*) lefMalloc(strlen(lefData->pv_token) + strlen(s) + strlen(lefData->lefrFileName)
!                                     + 350);
!             sprintf(str, "ERROR (LEFPARS-%d): %s, see file %s at line %d\nLast token was <%s\">, space is missing between the closing \" of the string and ;.\n",
                      1010, s, lefData->lefrFileName, lefData->lef_nlines, lefData->current_token);
              lefData->spaceMissing = 0;
          } else {
!             str = (char*) lefMalloc(strlen(lefData->current_token) + strlen(lefData->lefrFileName) + 350);
!             sprintf(str, "ERROR (LEFPARS-%d): Lef parser has encountered an error in file %s at line %d, on token %s.\nProblem can be syntax error on the lef file or an invalid parameter name.\nDouble check the syntax on the lef file with the LEFDEF Reference Manual.\n",
                      msgNum, lefData->lefrFileName, lefData->lef_nlines, lefData->current_token);
          }
      } else if (strcmp(s, "syntax error") == 0) {  // linux machines 
          if ((len > 1) && (lefData->current_token[len] == ';')) {
!             str = (char*) lefMalloc(strlen(lefData->current_token) + strlen(s) + strlen(lefData->lefrFileName)
!                                     + 350);
!             sprintf(str, "ERROR (LEFPARS-%d): %s, see file %s at line %d\nLast token was <%s>, space is missing before <;>\n",
                      msgNum, s, lefData->lefrFileName, lefData->lef_nlines, lefData->current_token);
          } else if ((pvLen > 1) && (lefData->pv_token[pvLen] == ';')) {
!             str = (char*) lefMalloc(strlen(lefData->pv_token) + strlen(s) + strlen(lefData->lefrFileName)
!                                     + 350);
!             sprintf(str, "ERROR (LEFPARS-%d): %s, see file %s at line %d\nLast token was <%s>, space is missing before <;>\n",
                      msgNum, s, lefData->lefrFileName, lefData->lef_nlines - 1, lefData->pv_token);
          } else if ((lefData->current_token[0] == '"') && (lefData->spaceMissing)) {
              // most likely space is missing after the end " 
!             str = (char*) lefMalloc(strlen(lefData->pv_token) + strlen(s) + strlen(lefData->lefrFileName)
!                                     + 350);
!             sprintf(str, "ERROR (LEFPARS-%d): %s, see file %s at line %d\nLast token was <%s\">, space is missing between the closing \" of the string and ;.\n",
                      1011, s, lefData->lefrFileName, lefData->lef_nlines, lefData->current_token);
              lefData->spaceMissing = 0;
          } else {
!             str = (char*) lefMalloc(strlen(lefData->current_token) + strlen(lefData->lefrFileName) + 350);
!             sprintf(str, "ERROR (LEFPARS-%d): Lef parser has encountered an error in file %s at line %d, on token %s.\nProblem can be syntax error on the lef file or an invalid parameter name.\nDouble check the syntax on the lef file with the LEFDEF Reference Manual.\n",
                      msgNum, lefData->lefrFileName, lefData->lef_nlines, lefData->current_token);
          }
      } else {
!         str = (char*) lefMalloc(strlen(lefData->current_token) + strlen(s) +
!                                 strlen(lefData->lefrFileName) + 350);
!         sprintf(str, "ERROR (LEFPARS-%d): %s Error in file %s at line %d, on token %s.\n",
                  msgNum, s, lefData->lefrFileName, lefData->lef_nlines, lefData->current_token);
      }
      fflush(stdout);
--- 1043,1099 ----
      // PCR 690679, probably missing space before a ';' 
      if (strcmp(s, "parse error") == 0) {
          if ((len > 1) && (lefData->current_token[len] == ';')) {
!             int xlen = strlen(lefData->current_token) + strlen(s) + strlen(lefData->lefrFileName) + 350;
!             str = (char*) lefMalloc(xlen);
!             snprintf(str, xlen, "ERROR (LEFPARS-%d): %s, see file %s at line %d\nLast token was <%s>, space is missing before <;>\n",
                      msgNum, s, lefData->lefrFileName, lefData->lef_nlines, lefData->current_token);
          } else if ((pvLen > 1) && (lefData->pv_token[pvLen] == ';')) {
!             int xlen = strlen(lefData->pv_token) + strlen(s) + strlen(lefData->lefrFileName) + 350;
!             str = (char*) lefMalloc(xlen);
!             snprintf(str, xlen, "ERROR (LEFPARS-%d): %s, see file %s at line %d\nLast token was <%s>, space is missing before <;>\n",
                      msgNum, s, lefData->lefrFileName, lefData->lef_nlines - 1, lefData->pv_token);
          } else if ((lefData->current_token[0] == '"') && (lefData->spaceMissing)) {
              // most likely space is missing after the end " 
!             int xlen = strlen(lefData->pv_token) + strlen(s) + strlen(lefData->lefrFileName) + 350;
!             str = (char*) lefMalloc(xlen);
!             snprintf(str, xlen, "ERROR (LEFPARS-%d): %s, see file %s at line %d\nLast token was <%s\">, space is missing between the closing \" of the string and ;.\n",
                      1010, s, lefData->lefrFileName, lefData->lef_nlines, lefData->current_token);
              lefData->spaceMissing = 0;
          } else {
!             int xlen = strlen(lefData->current_token) + strlen(lefData->lefrFileName) + 350;
!             str = (char*) lefMalloc(xlen);
!             snprintf(str, xlen, "ERROR (LEFPARS-%d): Lef parser has encountered an error in file %s at line %d, on token %s.\nProblem can be syntax error on the lef file or an invalid parameter name.\nDouble check the syntax on the lef file with the LEFDEF Reference Manual.\n",
                      msgNum, lefData->lefrFileName, lefData->lef_nlines, lefData->current_token);
          }
      } else if (strcmp(s, "syntax error") == 0) {  // linux machines 
          if ((len > 1) && (lefData->current_token[len] == ';')) {
!             int xlen = strlen(lefData->current_token) + strlen(s) + strlen(lefData->lefrFileName) + 350;
!             str = (char*) lefMalloc(xlen);
!             snprintf(str, xlen, "ERROR (LEFPARS-%d): %s, see file %s at line %d\nLast token was <%s>, space is missing before <;>\n",
                      msgNum, s, lefData->lefrFileName, lefData->lef_nlines, lefData->current_token);
          } else if ((pvLen > 1) && (lefData->pv_token[pvLen] == ';')) {
!             int xlen = strlen(lefData->pv_token) + strlen(s) + strlen(lefData->lefrFileName) + 350;
!             str = (char*) lefMalloc(xlen);
!             snprintf(str, xlen, "ERROR (LEFPARS-%d): %s, see file %s at line %d\nLast token was <%s>, space is missing before <;>\n",
                      msgNum, s, lefData->lefrFileName, lefData->lef_nlines - 1, lefData->pv_token);
          } else if ((lefData->current_token[0] == '"') && (lefData->spaceMissing)) {
              // most likely space is missing after the end " 
!             int xlen = strlen(lefData->pv_token) + strlen(s) + strlen(lefData->lefrFileName) + 350;
!             str = (char*) lefMalloc(xlen);
!             snprintf(str, xlen, "ERROR (LEFPARS-%d): %s, see file %s at line %d\nLast token was <%s\">, space is missing between the closing \" of the string and ;.\n",
                      1011, s, lefData->lefrFileName, lefData->lef_nlines, lefData->current_token);
              lefData->spaceMissing = 0;
          } else {
!             int xlen = strlen(lefData->current_token) + strlen(lefData->lefrFileName) + 350;
!             str = (char*) lefMalloc(xlen);
!             snprintf(str, xlen, "ERROR (LEFPARS-%d): Lef parser has encountered an error in file %s at line %d, on token %s.\nProblem can be syntax error on the lef file or an invalid parameter name.\nDouble check the syntax on the lef file with the LEFDEF Reference Manual.\n",
                      msgNum, lefData->lefrFileName, lefData->lef_nlines, lefData->current_token);
          }
      } else {
!         int xlen = strlen(lefData->current_token) + strlen(s) +
!                                 strlen(lefData->lefrFileName) + 350;
!         str = (char*) lefMalloc(xlen);
!         snprintf(str, xlen, "ERROR (LEFPARS-%d): %s Error in file %s at line %d, on token %s.\n",
                  msgNum, s, lefData->lefrFileName, lefData->lef_nlines, lefData->current_token);
      }
      fflush(stdout);
***************
*** 1120,1126 ****
  
      if (disableStatus == 1) {
          char msgStr[60];
!         sprintf(msgStr, "Message (LEFPARS-%d) has been suppressed from output.", msgNum);
          lefWarning(2502, msgStr);
          return;
      } else if (disableStatus == 2) {
--- 1124,1130 ----
  
      if (disableStatus == 1) {
          char msgStr[60];
!         snprintf(msgStr, 60, "Message (LEFPARS-%d) has been suppressed from output.", msgNum);
          lefWarning(2502, msgStr);
          return;
      } else if (disableStatus == 2) {
***************
*** 1135,1141 ****
              if (lefData->msgLimit[1][msgNum]) // already printed out warning 
                  return;
              lefData->msgLimit[1][msgNum] = 1;
!             sprintf(msgStr,
                      "Message (LEFPARS-%d) has exceeded the message display limit of %d",
                      msgNum, lefSettings->MsgLimit[msgNum]);
              lefWarning(2503, msgStr);
--- 1139,1145 ----
              if (lefData->msgLimit[1][msgNum]) // already printed out warning 
                  return;
              lefData->msgLimit[1][msgNum] = 1;
!             snprintf(msgStr, 100,
                      "Message (LEFPARS-%d) has exceeded the message display limit of %d",
                      msgNum, lefSettings->MsgLimit[msgNum]);
              lefWarning(2503, msgStr);
***************
*** 1146,1154 ****
      lefData->lefInfoMsgPrinted++;
  
      if (lefSettings->WarningLogFunction) {
!         char *str = (char*) lefMalloc(strlen(lefData->current_token) + strlen(s) + strlen(lefData->lefrFileName)
!                                       + 350);
!         sprintf(str, "INFO (LEFPARS-%d): %s See file %s at line %d.\n",
                  msgNum, s, lefData->lefrFileName, lefData->lef_nlines);
          (*lefSettings->WarningLogFunction)(str);
          free(str);
--- 1150,1158 ----
      lefData->lefInfoMsgPrinted++;
  
      if (lefSettings->WarningLogFunction) {
!         int xlen = strlen(lefData->current_token) + strlen(s) + strlen(lefData->lefrFileName) + 350;
!         char *str = (char*) lefMalloc(xlen);
!         snprintf(str, xlen, "INFO (LEFPARS-%d): %s See file %s at line %d.\n",
                  msgNum, s, lefData->lefrFileName, lefData->lef_nlines);
          (*lefSettings->WarningLogFunction)(str);
          free(str);
***************
*** 1195,1201 ****
  
          if (disableStatus == 1) {
              char msgStr[60];
!             sprintf(msgStr, "Message (LEFPARS-%d) has been suppressed from output.", msgNum);
              lefWarning(2502, msgStr);
              return;
          } else if (disableStatus == 2) {
--- 1199,1205 ----
  
          if (disableStatus == 1) {
              char msgStr[60];
!             snprintf(msgStr, 60, "Message (LEFPARS-%d) has been suppressed from output.", msgNum);
              lefWarning(2502, msgStr);
              return;
          } else if (disableStatus == 2) {
***************
*** 1211,1217 ****
              if (lefData->msgLimit[1][msgNum]) // already printed out warning 
                  return;
              lefData->msgLimit[1][msgNum] = 1;
!             sprintf(msgStr,
                      "Message (LEFPARS-%d) has exceeded the message display limit of %d",
                      msgNum, lefSettings->MsgLimit[msgNum]);
              lefWarning(2503, msgStr);
--- 1215,1221 ----
              if (lefData->msgLimit[1][msgNum]) // already printed out warning 
                  return;
              lefData->msgLimit[1][msgNum] = 1;
!             snprintf(msgStr, 100,
                      "Message (LEFPARS-%d) has exceeded the message display limit of %d",
                      msgNum, lefSettings->MsgLimit[msgNum]);
              lefWarning(2503, msgStr);
***************
*** 1222,1230 ****
      lefData->lefWarnMsgPrinted++;
  
      if (lefSettings->WarningLogFunction) {
!         char *str = (char*) lefMalloc(strlen(lefData->current_token) + strlen(s) + strlen(lefData->lefrFileName)
!                                       + 350);
!         sprintf(str, "WARNING (LEFPARS-%d): %s See file %s at line %d.\n",
                  msgNum, s, lefData->lefrFileName, lefData->lef_nlines);
          (*lefSettings->WarningLogFunction)(str);
          free(str);
--- 1226,1234 ----
      lefData->lefWarnMsgPrinted++;
  
      if (lefSettings->WarningLogFunction) {
!         int xlen = strlen(lefData->current_token) + strlen(s) + strlen(lefData->lefrFileName) + 350;
!         char *str = (char*) lefMalloc(xlen);
!         snprintf(str, xlen, "WARNING (LEFPARS-%d): %s See file %s at line %d.\n",
                  msgNum, s, lefData->lefrFileName, lefData->lef_nlines);
          (*lefSettings->WarningLogFunction)(str);
          free(str);
diff -r -c source.lefdef/lef.orig/lef/lefiDebug.cpp lef/lef/lefiDebug.cpp
*** source.lefdef/lef.orig/lef/lefiDebug.cpp	Fri Feb  5 14:39:14 2016
--- lef/lef/lefiDebug.cpp	Tue Jan  4 13:39:19 2022
***************
*** 94,100 ****
      if (lefSettings->ErrorLogFunction)
          (*lefSettings->ErrorLogFunction)(str);
      else
!         fprintf(stderr, str);
  }
  
  static char lefiShift [] = {
--- 94,100 ----
      if (lefSettings->ErrorLogFunction)
          (*lefSettings->ErrorLogFunction)(str);
      else
!         fprintf(stderr, "%s", str);
  }
  
  static char lefiShift [] = {
diff -r -c source.lefdef/lef.orig/lef/lefiLayer.cpp lef/lef/lefiLayer.cpp
*** source.lefdef/lef.orig/lef/lefiLayer.cpp	Fri Feb  5 14:39:14 2016
--- lef/lef/lefiLayer.cpp	Sun Jan 14 12:25:24 2024
***************
*** 4305,4311 ****
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1300): The index number %d given for the layer property is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1300, msg);
          return 0;
      }
--- 4305,4311 ----
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1300): The index number %d given for the layer property is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1300, msg);
          return 0;
      }
***************
*** 4317,4323 ****
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1300): The index number %d given for the layer property is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1300, msg);
          return 0;
      }
--- 4317,4323 ----
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1300): The index number %d given for the layer property is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1300, msg);
          return 0;
      }
***************
*** 4329,4347 ****
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1300): The index number %d given for the layer property is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1300, msg);
          return 0;
      }
      return dvalues_[i];
  }
  
! const char
  lefiLayer::propType(int i) const
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1300): The index number %d given for the layer property is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1300, msg);
          return 0;
      }
--- 4329,4347 ----
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1300): The index number %d given for the layer property is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1300, msg);
          return 0;
      }
      return dvalues_[i];
  }
  
! char
  lefiLayer::propType(int i) const
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1300): The index number %d given for the layer property is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1300, msg);
          return 0;
      }
***************
*** 4353,4359 ****
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1300): The index number %d given for the layer property is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1300, msg);
          return 0;
      }
--- 4353,4359 ----
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1300): The index number %d given for the layer property is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1300, msg);
          return 0;
      }
***************
*** 4365,4371 ****
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1300): The index number %d given for the layer property is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1300, msg);
          return 0;
      }
--- 4365,4371 ----
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1300): The index number %d given for the layer property is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1300, msg);
          return 0;
      }
***************
*** 5429,5435 ****
  {
      char msg[160];
      if (index < 0 || index > numMinSize_) {
!         sprintf(msg, "ERROR (LEFPARS-1301): The index number %d given for the layer MINSIZE is invalid.\nValid index is from 0 to %d\n", index, numMinSize_);
          lefiError(0, 1301, msg);
          return 0;
      }
--- 5429,5435 ----
  {
      char msg[160];
      if (index < 0 || index > numMinSize_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1301): The index number %d given for the layer MINSIZE is invalid.\nValid index is from 0 to %d\n", index, numMinSize_);
          lefiError(0, 1301, msg);
          return 0;
      }
***************
*** 5441,5447 ****
  {
      char msg[160];
      if (index < 0 || index > numMinSize_) {
!         sprintf(msg, "ERROR (LEFPARS-1301): The index number %d given for the layer MINSIZE is invalid.\nValid index is from 0 to %d\n", index, numMinSize_);
          lefiError(0, 1301, msg);
          return 0;
      }
--- 5441,5447 ----
  {
      char msg[160];
      if (index < 0 || index > numMinSize_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1301): The index number %d given for the layer MINSIZE is invalid.\nValid index is from 0 to %d\n", index, numMinSize_);
          lefiError(0, 1301, msg);
          return 0;
      }
***************
*** 5460,5466 ****
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         sprintf(msg, "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
--- 5460,5466 ----
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
***************
*** 5472,5478 ****
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         sprintf(msg, "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
--- 5472,5478 ----
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
***************
*** 5484,5490 ****
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         sprintf(msg, "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
--- 5484,5490 ----
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
***************
*** 5496,5502 ****
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         sprintf(msg, "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
--- 5496,5502 ----
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
***************
*** 5508,5514 ****
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         sprintf(msg, "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
--- 5508,5514 ----
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
***************
*** 5521,5527 ****
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         sprintf(msg, "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
--- 5521,5527 ----
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
***************
*** 5534,5540 ****
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         sprintf(msg, "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
--- 5534,5540 ----
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
***************
*** 5547,5553 ****
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         sprintf(msg, "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
--- 5547,5553 ----
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
***************
*** 5560,5566 ****
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         sprintf(msg, "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
--- 5560,5566 ----
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
***************
*** 5573,5579 ****
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         sprintf(msg, "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
--- 5573,5579 ----
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
***************
*** 5586,5592 ****
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         sprintf(msg, "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
--- 5586,5592 ----
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
***************
*** 5599,5605 ****
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         sprintf(msg, "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
--- 5599,5605 ----
  {
      char msg[160];
      if (index < 0 || index > numMinstep_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1302): The index number %d given for the layer MINSTEP is invalid.\nValid index is from 0 to %d", index, numMinstep_);
          lefiError(0, 1302, msg);
          return 0;
      }
***************
*** 5647,5653 ****
  {
      char msg[160];
      if (index < 0 || index > numArrayCuts_) {
!         sprintf(msg, "ERROR (LEFPARS-1303): The index number %d given for the layer ARRAYCUTS is invalid.\nValid index is from 0 to %d", index, numArrayCuts_);
          lefiError(0, 1303, msg);
          return 0;
      }
--- 5647,5653 ----
  {
      char msg[160];
      if (index < 0 || index > numArrayCuts_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1303): The index number %d given for the layer ARRAYCUTS is invalid.\nValid index is from 0 to %d", index, numArrayCuts_);
          lefiError(0, 1303, msg);
          return 0;
      }
***************
*** 5660,5666 ****
  {
      char msg[160];
      if (index < 0 || index > numArrayCuts_) {
!         sprintf(msg, "ERROR (LEFPARS-1304): The index number %d given for the layer SPACING is invalid.\nValid index is from 0 to %d", index, numArrayCuts_);
          lefiError(0, 1304, msg);
          return 0;
      }
--- 5660,5666 ----
  {
      char msg[160];
      if (index < 0 || index > numArrayCuts_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1304): The index number %d given for the layer SPACING is invalid.\nValid index is from 0 to %d", index, numArrayCuts_);
          lefiError(0, 1304, msg);
          return 0;
      }
***************
*** 5715,5725 ****
  
              if (strcmp(type(), "CUT") != 0) {
                  /*
!                             sprintf(msg, "ERROR (LEFPARS-1321): The property LEF57_SPACING with value %s is for TYPE CUT only.\nThe current layer has the TYPE %s.\nUpdate the property of your lef file with the correct syntax or remove this property from your lef file.\n",
                              values_[index], type());
                              lefiError(msg);
                  */
!                 sprintf(msg, "The property LEF57_SPACING with value %s is for TYPE CUT only.\nThe current layer has the TYPE %s.\nUpdate the property of your lef file with the correct syntax or remove this property from your lef file.\n",
                          values_[index], type());
                  lefError(1321, msg);
                  free(wrkingStr);
--- 5715,5725 ----
  
              if (strcmp(type(), "CUT") != 0) {
                  /*
!                             snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1321): The property LEF57_SPACING with value %s is for TYPE CUT only.\nThe current layer has the TYPE %s.\nUpdate the property of your lef file with the correct syntax or remove this property from your lef file.\n",
                              values_[index], type());
                              lefiError(msg);
                  */
!                 snprintf(msg, sizeof(msg), "The property LEF57_SPACING with value %s is for TYPE CUT only.\nThe current layer has the TYPE %s.\nUpdate the property of your lef file with the correct syntax or remove this property from your lef file.\n",
                          values_[index], type());
                  lefError(1321, msg);
                  free(wrkingStr);
***************
*** 5754,5764 ****
                          value = strtok(NULL, " ");
                          if (*value != ';') {
                              /*
!                                                  sprintf(msg, "ERROR (LEFPARS-1320): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                                   values_[index]);
                                                   lefiError(msg);
                              */
!                             sprintf(msg, "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                      values_[index]);
                              lefError(1320, msg);
                              free(wrkingStr);
--- 5754,5764 ----
                          value = strtok(NULL, " ");
                          if (*value != ';') {
                              /*
!                                                  snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1320): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                                   values_[index]);
                                                   lefiError(msg);
                              */
!                             snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                      values_[index]);
                              lefError(1320, msg);
                              free(wrkingStr);
***************
*** 5766,5776 ****
                          }
                      } else if (*value != ';') {
                          /*
!                                           sprintf(msg, "ERROR (LEFPARS-1320): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                            values_[index]);
                                            lefiError(msg);
                          */
!                         sprintf(msg, "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                  values_[index]);
                          lefError(1320, msg);
                          free(wrkingStr);
--- 5766,5776 ----
                          }
                      } else if (*value != ';') {
                          /*
!                                           snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1320): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                            values_[index]);
                                            lefiError(msg);
                          */
!                         snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                  values_[index]);
                          lefError(1320, msg);
                          free(wrkingStr);
***************
*** 5785,5795 ****
                  numCuts = atoi(value);
                  if ((numCuts < 2) || (numCuts > 4)) {
                      /*
!                                    sprintf(msg, "ERROR (LEFPARS-1320): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                     values_[index]);
                                     lefiError(msg);
                      */
!                     sprintf(msg, "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                              values_[index]);
                      lefError(1320, msg);
                      free(wrkingStr);
--- 5785,5795 ----
                  numCuts = atoi(value);
                  if ((numCuts < 2) || (numCuts > 4)) {
                      /*
!                                    snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1320): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                     values_[index]);
                                     lefiError(msg);
                      */
!                     snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                              values_[index]);
                      lefError(1320, msg);
                      free(wrkingStr);
***************
*** 5806,5816 ****
                          value = strtok(NULL, " ");
                          if (*value != ';') {
                              /*
!                                                  sprintf(msg, "ERROR (LEFPARS-1320): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                                   values_[index]);
                                                   lefiError(msg);
                              */
!                             sprintf(msg, "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                      values_[index]);
                              lefError(1320, msg);
                              free(wrkingStr);
--- 5806,5816 ----
                          value = strtok(NULL, " ");
                          if (*value != ';') {
                              /*
!                                                  snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1320): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                                   values_[index]);
                                                   lefiError(msg);
                              */
!                             snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                      values_[index]);
                              lefError(1320, msg);
                              free(wrkingStr);
***************
*** 5818,5828 ****
                          }
                      } else if (*value != ';') {
                          /*
!                                           sprintf(msg, "ERROR (LEFPARS-1320): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                            values_[index]);
                                            lefiError(msg);
                          */
!                         sprintf(msg, "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                  values_[index]);
                          lefError(1320, msg);
                          free(wrkingStr);
--- 5818,5828 ----
                          }
                      } else if (*value != ';') {
                          /*
!                                           snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1320): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                            values_[index]);
                                            lefiError(msg);
                          */
!                         snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                  values_[index]);
                          lefError(1320, msg);
                          free(wrkingStr);
***************
*** 5832,5842 ****
                      }
                  } else {
                      /*
!                                    sprintf(msg, "ERROR (LEFPARS-1320): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                     values_[index]);
                                     lefiError(msg);
                      */
!                     sprintf(msg, "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                              values_[index]);
                      lefError(1320, msg);
                      free(wrkingStr);
--- 5832,5842 ----
                      }
                  } else {
                      /*
!                                    snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1320): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                     values_[index]);
                                     lefiError(msg);
                      */
!                     snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                              values_[index]);
                      lefError(1320, msg);
                      free(wrkingStr);
***************
*** 5848,5858 ****
                  value = strtok(NULL, " ");
                  if (*value != ';') {
                      /*
!                                    sprintf(msg, "ERROR (LEFPARS-1320): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                     values_[index]);
                                     lefiError(msg);
                      */
!                     sprintf(msg, "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                              values_[index]);
                      lefError(1320, msg);
                      free(wrkingStr);
--- 5848,5858 ----
                  value = strtok(NULL, " ");
                  if (*value != ';') {
                      /*
!                                    snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1320): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                     values_[index]);
                                     lefiError(msg);
                      */
!                     snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                              values_[index]);
                      lefError(1320, msg);
                      free(wrkingStr);
***************
*** 5867,5877 ****
                  value = strtok(NULL, " ");
                  if (*value != ';') {
                      /*
!                                    sprintf(msg, "ERROR (LEFPARS-1320): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                     values_[index]);
                                     lefiError(msg);
                      */
!                     sprintf(msg, "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                              values_[index]);
                      lefError(1320, msg);
                      free(wrkingStr);
--- 5867,5877 ----
                  value = strtok(NULL, " ");
                  if (*value != ';') {
                      /*
!                                    snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1320): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                                     values_[index]);
                                     lefiError(msg);
                      */
!                     snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING cutSpacing [CENTERTOCENTER][SAMENET]\n\t[LAYER secondLayerName[STACK]\n\t| ADJACENTCUTS {2 | 3 | 4} WITHIN cutWithin [EXCEPTSAMEPGNET]\n\t| PARALLELOVERLAP\n\t| AREA cutArea ;\"",
                              values_[index]);
                      lefError(1320, msg);
                      free(wrkingStr);
***************
*** 5895,5905 ****
  
              if (strcmp(type(), "ROUTING") != 0) {
                  /*
!                             sprintf(msg, "ERROR (LEFPARS-1322): The property LEF57_SPACING with value %s is for TYPE ROUTING only.\nThe current layer has the TYPE %s.\nUpdate the property of your lef file with the correct syntax or remove this property from your lef file.\n",
                              values_[index], type());
                              lefiError(msg);
                  */
!                 sprintf(msg, "The property LEF57_SPACING with value %s is for TYPE ROUTING only.\nThe current layer has the TYPE %s.\nUpdate the property of your lef file with the correct syntax or remove this property from your lef file.\n",
                          values_[index], type());
                  lefError(1322, msg);
                  free(wrkingStr);
--- 5895,5905 ----
  
              if (strcmp(type(), "ROUTING") != 0) {
                  /*
!                             snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1322): The property LEF57_SPACING with value %s is for TYPE ROUTING only.\nThe current layer has the TYPE %s.\nUpdate the property of your lef file with the correct syntax or remove this property from your lef file.\n",
                              values_[index], type());
                              lefiError(msg);
                  */
!                 snprintf(msg, sizeof(msg), "The property LEF57_SPACING with value %s is for TYPE ROUTING only.\nThe current layer has the TYPE %s.\nUpdate the property of your lef file with the correct syntax or remove this property from your lef file.\n",
                          values_[index], type());
                  lefError(1322, msg);
                  free(wrkingStr);
***************
*** 5971,5990 ****
                                  }
                              } else {
                                  /*
!                                                         sprintf(msg, "ERROR (LEFPARS-1305): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING minSpacing [CENTERTOCENTER]\"\n\"[LAYER secondLayerName | ADJACENTCUTS {2|3|4} WITHIN cutWithin | PARALLELOVERLAP | AREA cutArea]\" or\n\"SPACING eolSpace ENDOFLINE eolWidth WITHIN eolWITHIN [PARALLELEDGE parSpace WITHIN parWithin [TOWEDGES]]\"\n", values_[index]);
                                                          lefiError(msg);
                                  */
!                                 sprintf(msg, "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING minSpacing [CENTERTOCENTER]\"\n\"[LAYER secondLayerName | ADJACENTCUTS {2|3|4} WITHIN cutWithin | PARALLELOVERLAP | AREA cutArea]\" or\n\"SPACING eolSpace ENDOFLINE eolWidth WITHIN eolWITHIN [PARALLELEDGE parSpace WITHIN parWithin [TOWEDGES]]\"\n", values_[index]);
                                  lefError(1305, msg);
                                  free(wrkingStr);
                                  return;
                              }
                          } else {
                              /*
!                                                  sprintf(msg, "ERROR (LEFPARS-1305): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING minSpacing [CENTERTOCENTER]\"\n\"[LAYER secondLayerName | ADJACENTCUTS {2|3|4} WITHIN cutWithin | PARALLELOVERLAP | AREA cutArea]\" or\n\"SPACING eolSpace ENDOFLINE eolWidth WITHIN eolWITHIN [PARALLELEDGE parSpace WITHIN parWithin [TOWEDGES]]\"\n", values_[index]);
                                                   lefiError(msg);
                              */
!                             sprintf(msg, "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING minSpacing [CENTERTOCENTER]\"\n\"[LAYER secondLayerName | ADJACENTCUTS {2|3|4} WITHIN cutWithin | PARALLELOVERLAP | AREA cutArea]\" or\n\"SPACING eolSpace ENDOFLINE eolWidth WITHIN eolWITHIN [PARALLELEDGE parSpace WITHIN parWithin [TOWEDGES]]\"\n", values_[index]);
                              lefError(1305, msg);
                              free(wrkingStr);
                              return;
--- 5971,5990 ----
                                  }
                              } else {
                                  /*
!                                                         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1305): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING minSpacing [CENTERTOCENTER]\"\n\"[LAYER secondLayerName | ADJACENTCUTS {2|3|4} WITHIN cutWithin | PARALLELOVERLAP | AREA cutArea]\" or\n\"SPACING eolSpace ENDOFLINE eolWidth WITHIN eolWITHIN [PARALLELEDGE parSpace WITHIN parWithin [TOWEDGES]]\"\n", values_[index]);
                                                          lefiError(msg);
                                  */
!                                 snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING minSpacing [CENTERTOCENTER]\"\n\"[LAYER secondLayerName | ADJACENTCUTS {2|3|4} WITHIN cutWithin | PARALLELOVERLAP | AREA cutArea]\" or\n\"SPACING eolSpace ENDOFLINE eolWidth WITHIN eolWITHIN [PARALLELEDGE parSpace WITHIN parWithin [TOWEDGES]]\"\n", values_[index]);
                                  lefError(1305, msg);
                                  free(wrkingStr);
                                  return;
                              }
                          } else {
                              /*
!                                                  snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1305): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING minSpacing [CENTERTOCENTER]\"\n\"[LAYER secondLayerName | ADJACENTCUTS {2|3|4} WITHIN cutWithin | PARALLELOVERLAP | AREA cutArea]\" or\n\"SPACING eolSpace ENDOFLINE eolWidth WITHIN eolWITHIN [PARALLELEDGE parSpace WITHIN parWithin [TOWEDGES]]\"\n", values_[index]);
                                                   lefiError(msg);
                              */
!                             snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is \"SPACING minSpacing [CENTERTOCENTER]\"\n\"[LAYER secondLayerName | ADJACENTCUTS {2|3|4} WITHIN cutWithin | PARALLELOVERLAP | AREA cutArea]\" or\n\"SPACING eolSpace ENDOFLINE eolWidth WITHIN eolWITHIN [PARALLELEDGE parSpace WITHIN parWithin [TOWEDGES]]\"\n", values_[index]);
                              lefError(1305, msg);
                              free(wrkingStr);
                              return;
***************
*** 6006,6025 ****
                  }
              } else {
                  /*
!                             sprintf(msg, "ERROR (LEFPARS-1305): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is either \"SPACING minSpacing [CENTERTOCENTER]\"\n\"[LAYER secondLayerName | ADJACENTCUTS {2|3|4} WITHIN cutWithin | PARALLELOVERLAP | AREA cutArea]\" or\n\"SPACING eolSpace ENDOFLINE eolWidth WITHIN eolWITHIN [PARALLELEDGE parSpace WITHIN parWithin [TOWEDGES]]\"\n", values_[index]);
                              lefiError(msg);
                  */
!                 sprintf(msg, "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is either \"SPACING minSpacing [CENTERTOCENTER]\"\n\"[LAYER secondLayerName | ADJACENTCUTS {2|3|4} WITHIN cutWithin | PARALLELOVERLAP | AREA cutArea]\" or\n\"SPACING eolSpace ENDOFLINE eolWidth WITHIN eolWITHIN [PARALLELEDGE parSpace WITHIN parWithin [TOWEDGES]]\"\n", values_[index]);
                  lefError(1305, msg);
                  free(wrkingStr);
                  return;
              }
          } else {
              /*
!                      sprintf(msg, "ERROR (LEFPARS-1305): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is either \"SPACING minSpacing [CENTERTOCENTER]\"\n\"[LAYER secondLayerName | ADJACENTCUTS {2|3|4} WITHIN cutWithin | PARALLELOVERLAP | AREA cutArea]\" or\n\"SPACING eolSpace ENDOFLINE eolWidth WITHIN eolWITHIN [PARALLELEDGE parSpace WITHIN parWithin [TOWEDGES]]\"\n", values_[index]);
                       lefiError(msg);
              */
!             sprintf(msg, "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is either \"SPACING minSpacing [CENTERTOCENTER]\"\n\"[LAYER secondLayerName | ADJACENTCUTS {2|3|4} WITHIN cutWithin | PARALLELOVERLAP | AREA cutArea]\" or\n\"SPACING eolSpace ENDOFLINE eolWidth WITHIN eolWITHIN [PARALLELEDGE parSpace WITHIN parWithin [TOWEDGES]]\"\n", values_[index]);
              lefError(1305, msg);
              free(wrkingStr);
              return;
--- 6006,6025 ----
                  }
              } else {
                  /*
!                             snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1305): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is either \"SPACING minSpacing [CENTERTOCENTER]\"\n\"[LAYER secondLayerName | ADJACENTCUTS {2|3|4} WITHIN cutWithin | PARALLELOVERLAP | AREA cutArea]\" or\n\"SPACING eolSpace ENDOFLINE eolWidth WITHIN eolWITHIN [PARALLELEDGE parSpace WITHIN parWithin [TOWEDGES]]\"\n", values_[index]);
                              lefiError(msg);
                  */
!                 snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is either \"SPACING minSpacing [CENTERTOCENTER]\"\n\"[LAYER secondLayerName | ADJACENTCUTS {2|3|4} WITHIN cutWithin | PARALLELOVERLAP | AREA cutArea]\" or\n\"SPACING eolSpace ENDOFLINE eolWidth WITHIN eolWITHIN [PARALLELEDGE parSpace WITHIN parWithin [TOWEDGES]]\"\n", values_[index]);
                  lefError(1305, msg);
                  free(wrkingStr);
                  return;
              }
          } else {
              /*
!                      snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1305): Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is either \"SPACING minSpacing [CENTERTOCENTER]\"\n\"[LAYER secondLayerName | ADJACENTCUTS {2|3|4} WITHIN cutWithin | PARALLELOVERLAP | AREA cutArea]\" or\n\"SPACING eolSpace ENDOFLINE eolWidth WITHIN eolWITHIN [PARALLELEDGE parSpace WITHIN parWithin [TOWEDGES]]\"\n", values_[index]);
                       lefiError(msg);
              */
!             snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_SPACING: %s.\nCorrect syntax is either \"SPACING minSpacing [CENTERTOCENTER]\"\n\"[LAYER secondLayerName | ADJACENTCUTS {2|3|4} WITHIN cutWithin | PARALLELOVERLAP | AREA cutArea]\" or\n\"SPACING eolSpace ENDOFLINE eolWidth WITHIN eolWITHIN [PARALLELEDGE parSpace WITHIN parWithin [TOWEDGES]]\"\n", values_[index]);
              lefError(1305, msg);
              free(wrkingStr);
              return;
***************
*** 6041,6047 ****
  
     value = strtok(wrkingStr, " ");
     if (strcmp(value, "MAXFLOATINGAREA") != 0) {
!       sprintf(msg, "ERROR (LEFPARS-1306): Incorrect syntax defined for property LEF57_MAXFLOATINGAREA: %s.\nCorrect syntax is \"MAXFLOATINGAREA maxArea\"\n", values_[index]);
        lefiError(0, 1306, msg);
        free(wrkingStr);
        return;
--- 6041,6047 ----
  
     value = strtok(wrkingStr, " ");
     if (strcmp(value, "MAXFLOATINGAREA") != 0) {
!       snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1306): Incorrect syntax defined for property LEF57_MAXFLOATINGAREA: %s.\nCorrect syntax is \"MAXFLOATINGAREA maxArea\"\n", values_[index]);
        lefiError(0, 1306, msg);
        free(wrkingStr);
        return;
***************
*** 6070,6079 ****
      value = strtok(wrkingStr, " ");
      if (strcmp(value, "ARRAYSPACING") != 0) {
          /*
!               sprintf(msg, "ERROR (LEFPARS-1307): Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                lefiError(msg);
          */
!         sprintf(msg, "Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
          lefError(1307, msg);
          free(wrkingStr);
          return;
--- 6070,6079 ----
      value = strtok(wrkingStr, " ");
      if (strcmp(value, "ARRAYSPACING") != 0) {
          /*
!               snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1307): Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                lefiError(msg);
          */
!         snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
          lefError(1307, msg);
          free(wrkingStr);
          return;
***************
*** 6084,6093 ****
          if (strcmp(value, "LONGARRAY") == 0) {
              if (cutSpacing != 0) { // make sure syntax has correct order 
                  /*
!                 sprintf(msg, "ERROR (LEFPARS-1308): Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nLONGARRAY is defined after CUTSPACING.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                  lefiError(msg);
                  */
!                 sprintf(msg, "Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nLONGARRAY is defined after CUTSPACING.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                  lefError(1308, msg);
                  free(wrkingStr);
                  return;
--- 6084,6093 ----
          if (strcmp(value, "LONGARRAY") == 0) {
              if (cutSpacing != 0) { // make sure syntax has correct order 
                  /*
!                 snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1308): Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nLONGARRAY is defined after CUTSPACING.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                  lefiError(msg);
                  */
!                 snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nLONGARRAY is defined after CUTSPACING.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                  lefError(1308, msg);
                  free(wrkingStr);
                  return;
***************
*** 6097,6106 ****
          } else if (strcmp(value, "WIDTH") == 0) {
              if (cutSpacing != 0) { // make sure syntax has correct order 
                  /*
!                 sprintf(msg, "ERROR (LEFPARS-1309): Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nWIDTH is defined after CUTSPACING.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                  lefiError(msg);
                  */
!                 sprintf(msg, "Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nWIDTH is defined after CUTSPACING.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                  lefError(1309, msg);
                  free(wrkingStr);
                  return;
--- 6097,6106 ----
          } else if (strcmp(value, "WIDTH") == 0) {
              if (cutSpacing != 0) { // make sure syntax has correct order 
                  /*
!                 snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1309): Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nWIDTH is defined after CUTSPACING.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                  lefiError(msg);
                  */
!                 snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nWIDTH is defined after CUTSPACING.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                  lefError(1309, msg);
                  free(wrkingStr);
                  return;
***************
*** 6111,6120 ****
          } else if (strcmp(value, "CUTSPACING") == 0) {
              if (cutSpacing != 0) { // make sure syntax has correct order 
                  /*
!                 sprintf(msg, "ERROR (LEFPARS-1310): Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nCUTSPACING has defined more than once.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                  lefiError(msg);
                  */
!                 sprintf(msg, "Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nCUTSPACING has defined more than once.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                  lefError(1310, msg);
                  free(wrkingStr);
                  return;
--- 6111,6120 ----
          } else if (strcmp(value, "CUTSPACING") == 0) {
              if (cutSpacing != 0) { // make sure syntax has correct order 
                  /*
!                 snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1310): Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nCUTSPACING has defined more than once.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                  lefiError(msg);
                  */
!                 snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nCUTSPACING has defined more than once.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                  lefError(1310, msg);
                  free(wrkingStr);
                  return;
***************
*** 6132,6141 ****
          } else if (strcmp(value, "ARRAYCUTS") == 0) {
              if (cutSpacing == 0) { // make sure cutSpacing is already set 
                  /*
!                 sprintf(msg, "ERROR (LEFPARS-1311): Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nCUTSPACING which is required is either has not been defined or defined in a wrong location.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                  lefiError(msg);
                  */
!                 sprintf(msg, "Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nCUTSPACING which is required is either has not been defined or defined in a wrong location.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                  lefError(1311, msg);
                  free(wrkingStr);
                  return;
--- 6132,6141 ----
          } else if (strcmp(value, "ARRAYCUTS") == 0) {
              if (cutSpacing == 0) { // make sure cutSpacing is already set 
                  /*
!                 snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1311): Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nCUTSPACING which is required is either has not been defined or defined in a wrong location.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                  lefiError(msg);
                  */
!                 snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nCUTSPACING which is required is either has not been defined or defined in a wrong location.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                  lefError(1311, msg);
                  free(wrkingStr);
                  return;
***************
*** 6145,6154 ****
              value = strtok(NULL, " ");
              if (strcmp(value, "SPACING") != 0) {
                  /*
!                             sprintf(msg, "ERROR (LEFPARS-1312): Incorrect syntax defined for  property LEF57_ARRAYSPACING: %s.\nSPACING should be defined with ARRAYCUTS.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                              lefiError(msg);
                  */
!                 sprintf(msg, "Incorrect syntax defined for  property LEF57_ARRAYSPACING: %s.\nSPACING should be defined with ARRAYCUTS.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                  lefError(1312, msg);
                  free(wrkingStr);
                  return;
--- 6145,6154 ----
              value = strtok(NULL, " ");
              if (strcmp(value, "SPACING") != 0) {
                  /*
!                             snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1312): Incorrect syntax defined for  property LEF57_ARRAYSPACING: %s.\nSPACING should be defined with ARRAYCUTS.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                              lefiError(msg);
                  */
!                 snprintf(msg, sizeof(msg), "Incorrect syntax defined for  property LEF57_ARRAYSPACING: %s.\nSPACING should be defined with ARRAYCUTS.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
                  lefError(1312, msg);
                  free(wrkingStr);
                  return;
***************
*** 6163,6172 ****
              hasArrayCut = 1;
          } else {  // Doesn't match any of the format
              /*
!             sprintf(msg, "ERROR (LEFPARS-1313): Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
              lefiError(msg);
              */
!             sprintf(msg, "Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
              lefError(1313, msg);
              free(wrkingStr);
              return;
--- 6163,6172 ----
              hasArrayCut = 1;
          } else {  // Doesn't match any of the format
              /*
!             snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1313): Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
              lefiError(msg);
              */
!             snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_ARRAYSPACING: %s.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
              lefError(1313, msg);
              free(wrkingStr);
              return;
***************
*** 6176,6184 ****
  
      if (hasArrayCut == 0) {  // ARRAYCUTS is required
          /*
!         sprintf(msg, "ERROR (LEFPARS-1314): Incorrect syntax defined for property LEF57_ARRAYSPACING: %s\nARRAYCUTS is required but has not been defined.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
          */
!         sprintf(msg, "Incorrect syntax defined for property LEF57_ARRAYSPACING: %s\nARRAYCUTS is required but has not been defined.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
          lefError(1314, msg);
      }
  
--- 6176,6184 ----
  
      if (hasArrayCut == 0) {  // ARRAYCUTS is required
          /*
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1314): Incorrect syntax defined for property LEF57_ARRAYSPACING: %s\nARRAYCUTS is required but has not been defined.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
          */
!         snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_ARRAYSPACING: %s\nARRAYCUTS is required but has not been defined.\nCorrect syntax is ARRAYSPACING [LONGARRAY] [WIDTH viaWidth] CUTSPACING cutSpacing\n\tARRAYCUTS arrayCuts SPACING arraySpacing ...\n", values_[index]);
          lefError(1314, msg);
      }
  
***************
*** 6201,6211 ****
  
      if (strcmp(type(), "ROUTING") != 0) {
          /*
!               sprintf(msg, "ERROR (LEFPARS-1323): The property LEF57_MINSTEP with value %s is for TYPE ROUTING only.\nThe current layer has the TYPE %s.\nUpdate the property of your lef file with the correct syntax or remove this property from your lef file.\n",
                values_[index], type());
                lefiError(msg);
          */
!         sprintf(msg, "The property LEF57_MINSTEP with value %s is for TYPE ROUTING only.\nThe current layer has the TYPE %s.\nUpdate the property of your lef file with the correct syntax or remove this property from your lef file.\n",
                  values_[index], type());
          lefError(1323, msg);
          free(wrkingStr);
--- 6201,6211 ----
  
      if (strcmp(type(), "ROUTING") != 0) {
          /*
!               snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1323): The property LEF57_MINSTEP with value %s is for TYPE ROUTING only.\nThe current layer has the TYPE %s.\nUpdate the property of your lef file with the correct syntax or remove this property from your lef file.\n",
                values_[index], type());
                lefiError(msg);
          */
!         snprintf(msg, sizeof(msg), "The property LEF57_MINSTEP with value %s is for TYPE ROUTING only.\nThe current layer has the TYPE %s.\nUpdate the property of your lef file with the correct syntax or remove this property from your lef file.\n",
                  values_[index], type());
          lefError(1323, msg);
          free(wrkingStr);
***************
*** 6215,6224 ****
      value = strtok(wrkingStr, " ");
      if (strcmp(value, "MINSTEP") != 0) {
          /*
!               sprintf(msg, "ERROR (LEFPARS-1315): Incorrect syntax defined for property LEF57_MINSTEP: %s.\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                lefiError(msg);
          */
!         sprintf(msg, "Incorrect syntax defined for property LEF57_MINSTEP: %s.\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
          lefError(1315, msg);
          free(wrkingStr);
          return;
--- 6215,6224 ----
      value = strtok(wrkingStr, " ");
      if (strcmp(value, "MINSTEP") != 0) {
          /*
!               snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1315): Incorrect syntax defined for property LEF57_MINSTEP: %s.\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                lefiError(msg);
          */
!         snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_MINSTEP: %s.\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
          lefError(1315, msg);
          free(wrkingStr);
          return;
***************
*** 6234,6243 ****
                  // MAXEDGES maxEdges
                  if (maxEdges) { // MAXEDGES has already defined
                      /*
!                     sprintf(msg, "ERROR (LEFPARS-1315): Incorrect syntax defined for property LEF57_MINSTEP: %s\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                      lefiError(msg);
                      */
!                     sprintf(msg, "Incorrect syntax defined for property LEF57_MINSTEP: %s\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                      lefError(1315, msg);
                      free(wrkingStr);   // done parsing
                      return;
--- 6234,6243 ----
                  // MAXEDGES maxEdges
                  if (maxEdges) { // MAXEDGES has already defined
                      /*
!                     snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1315): Incorrect syntax defined for property LEF57_MINSTEP: %s\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                      lefiError(msg);
                      */
!                     snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_MINSTEP: %s\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                      lefError(1315, msg);
                      free(wrkingStr);   // done parsing
                      return;
***************
*** 6251,6260 ****
                      // MINBETWEENLENGTH has defined, it is either MINADJACENTLENGTH
                      // or MINBETWEENLENGTH but not both
                      /*
!                     sprintf(msg, "ERROR (LEFPARS-1315): Incorrect syntax defined for property LEF57_MINSTEP: %s\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                      lefiError(msg);
                      */
!                     sprintf(msg, "Incorrect syntax defined for property LEF57_MINSTEP: %s\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                      lefError(1315, msg);
                      free(wrkingStr);   // done parsing
                      return;
--- 6251,6260 ----
                      // MINBETWEENLENGTH has defined, it is either MINADJACENTLENGTH
                      // or MINBETWEENLENGTH but not both
                      /*
!                     snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1315): Incorrect syntax defined for property LEF57_MINSTEP: %s\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                      lefiError(msg);
                      */
!                     snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_MINSTEP: %s\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                      lefError(1315, msg);
                      free(wrkingStr);   // done parsing
                      return;
***************
*** 6268,6277 ****
                      // minadjACENTLENGTH has defined, it is either MINBETWEENLENGTH
                      // or minADJACENTLENGTH but not both
                      /*
!                     sprintf(msg, "ERROR (LEFPARS-1315): Incorrect syntax defined for property LEF57_MINSTEP: %s\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                      lefierror(msg);
                      */
!                     sprintf(msg, "Incorrect syntax defined for property LEF57_MINSTEP: %s\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                      lefError(1315, msg);
                      free(wrkingStr);   // done parsing
                      return;
--- 6268,6277 ----
                      // minadjACENTLENGTH has defined, it is either MINBETWEENLENGTH
                      // or minADJACENTLENGTH but not both
                      /*
!                     snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1315): Incorrect syntax defined for property LEF57_MINSTEP: %s\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                      lefierror(msg);
                      */
!                     snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_MINSTEP: %s\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                      lefError(1315, msg);
                      free(wrkingStr);   // done parsing
                      return;
***************
*** 6287,6296 ****
                      value = strtok(NULL, " ");
                  } else {
                      /*
!                                    sprintf(msg, "ERROR (LEFPARS-1315): Incorrect syntax defined for property LEF57_MINSTEP: %s\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                                     lefierror(msg);
                      */
!                     sprintf(msg, "Incorrect syntax defined for property LEF57_MINSTEP: %s\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                      lefError(1315, msg);
                      free(wrkingStr);   // done parsing
                      return;
--- 6287,6296 ----
                      value = strtok(NULL, " ");
                  } else {
                      /*
!                                    snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1315): Incorrect syntax defined for property LEF57_MINSTEP: %s\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                                     lefierror(msg);
                      */
!                     snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_MINSTEP: %s\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                      lefError(1315, msg);
                      free(wrkingStr);   // done parsing
                      return;
***************
*** 6298,6307 ****
              } else if (strcmp(value, ";") != 0) {
                  // an invalid value
                  /*
!                 sprintf(msg, "ERROR (LEFPARS-1315): Incorrect syntax defined for property LEF57_MINSTEP: %s.\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                  lefierror(msg);
                  */
!                 sprintf(msg, "Incorrect syntax defined for property LEF57_MINSTEP: %s.\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                  lefError(1315, msg);
                  free(wrkingStr);   // done parsing
                  return;
--- 6298,6307 ----
              } else if (strcmp(value, ";") != 0) {
                  // an invalid value
                  /*
!                 snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1315): Incorrect syntax defined for property LEF57_MINSTEP: %s.\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                  lefierror(msg);
                  */
!                 snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_MINSTEP: %s.\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
                  lefError(1315, msg);
                  free(wrkingStr);   // done parsing
                  return;
***************
*** 6310,6319 ****
          } else {
              // done parsing without ;
              /*
!             sprintf(msg, "eRROR (LEFPARS-1315): Incorrect syntax defined for property LEF57_MINSTEP: %s\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
              lefierror(msg);
              */
!             sprintf(msg, "incorrect syntax defined for property LEF57_MINSTEP: %s\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
              lefError(1315, msg);
              free(wrkingStr);   // done parsing
              return;
--- 6310,6319 ----
          } else {
              // done parsing without ;
              /*
!             snprintf(msg, sizeof(msg), "eRROR (LEFPARS-1315): Incorrect syntax defined for property LEF57_MINSTEP: %s\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
              lefierror(msg);
              */
!             snprintf(msg, sizeof(msg), "incorrect syntax defined for property LEF57_MINSTEP: %s\nCorrect syntax is \"MINSTEP minStepLength [MAXEDGES maxEdges] [MINADJACENTLENGTH minAdjLength | MINBETWEENLENGTH minBetweenLength [EXCEPTSAMECORNERS]] ;\"\n", values_[index]);
              lefError(1315, msg);
              free(wrkingStr);   // done parsing
              return;
***************
*** 6345,6354 ****
      value = strtok(wrkingStr, " ");
      if (strcmp(value, "ANTENNACUMROUTINGPLUSCUT") != 0) {
          /*
!               sprintf(msg, "ERROR (LEFPARS-1316): Incorrect syntax defined for property LEF57_ANTENNACUMROUTINGPLUSCUT: %s.\nCorrect syntax is \"ANTANNACUMROUTINGPLUSCUT\"\n", values_[index]);
                lefiError(msg);
          */
!         sprintf(msg, "Incorrect syntax defined for property LEF57_ANTENNACUMROUTINGPLUSCUT: %s.\nCorrect syntax is \"ANTANNACUMROUTINGPLUSCUT\"\n", values_[index]);
          lefError(1316, msg);
          free(wrkingStr);
          return;
--- 6345,6354 ----
      value = strtok(wrkingStr, " ");
      if (strcmp(value, "ANTENNACUMROUTINGPLUSCUT") != 0) {
          /*
!               snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1316): Incorrect syntax defined for property LEF57_ANTENNACUMROUTINGPLUSCUT: %s.\nCorrect syntax is \"ANTANNACUMROUTINGPLUSCUT\"\n", values_[index]);
                lefiError(msg);
          */
!         snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_ANTENNACUMROUTINGPLUSCUT: %s.\nCorrect syntax is \"ANTANNACUMROUTINGPLUSCUT\"\n", values_[index]);
          lefError(1316, msg);
          free(wrkingStr);
          return;
***************
*** 6372,6381 ****
      value = strtok(wrkingStr, " ");
      if (strcmp(value, "ANTENNAGATEPLUSDIFF") != 0) {
          /*
!               sprintf(msg, "ERROR (LEFPARS-1317): Incorrect syntax defined for property LEF57_ANTENNAGATEPLUSDIFF: %s.\nCorrect syntax is \"ANTENNAGATEPLUSDIFF plusDiffFactor\"\n", values_[index]);
                lefiError(msg);
          */
!         sprintf(msg, "Incorrect syntax defined for property LEF57_ANTENNAGATEPLUSDIFF: %s.\nCorrect syntax is \"ANTENNAGATEPLUSDIFF plusDiffFactor\"\n", values_[index]);
          lefError(1317, msg);
          free(wrkingStr);
          return;
--- 6372,6381 ----
      value = strtok(wrkingStr, " ");
      if (strcmp(value, "ANTENNAGATEPLUSDIFF") != 0) {
          /*
!               snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1317): Incorrect syntax defined for property LEF57_ANTENNAGATEPLUSDIFF: %s.\nCorrect syntax is \"ANTENNAGATEPLUSDIFF plusDiffFactor\"\n", values_[index]);
                lefiError(msg);
          */
!         snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_ANTENNAGATEPLUSDIFF: %s.\nCorrect syntax is \"ANTENNAGATEPLUSDIFF plusDiffFactor\"\n", values_[index]);
          lefError(1317, msg);
          free(wrkingStr);
          return;
***************
*** 6401,6410 ****
      value = strtok(wrkingStr, " ");
      if (strcmp(value, "ANTENNAAREAMINUSDIFF") != 0) {
          /*
!               sprintf(msg, "ERROR (LEFPARS-1318): Incorrect syntax defined for property LEF57_ANTENNAAREAMINUSDIFF: %s.\nCorrect syntax is \"ANTENNAAREAMINUSDIFF minusDiffFactor\"\n", values_[index]);
                lefiError(msg);
          */
!         sprintf(msg, "Incorrect syntax defined for property LEF57_ANTENNAAREAMINUSDIFF: %s.\nCorrect syntax is \"ANTENNAAREAMINUSDIFF minusDiffFactor\"\n", values_[index]);
          lefError(1318, msg);
          free(wrkingStr);
          return;
--- 6401,6410 ----
      value = strtok(wrkingStr, " ");
      if (strcmp(value, "ANTENNAAREAMINUSDIFF") != 0) {
          /*
!               snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1318): Incorrect syntax defined for property LEF57_ANTENNAAREAMINUSDIFF: %s.\nCorrect syntax is \"ANTENNAAREAMINUSDIFF minusDiffFactor\"\n", values_[index]);
                lefiError(msg);
          */
!         snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_ANTENNAAREAMINUSDIFF: %s.\nCorrect syntax is \"ANTENNAAREAMINUSDIFF minusDiffFactor\"\n", values_[index]);
          lefError(1318, msg);
          free(wrkingStr);
          return;
***************
*** 6432,6441 ****
      value = strtok(wrkingStr, " ");
      if (strcmp(value, "ANTENNAAREADIFFREDUCEPWL") != 0) {
          /*
!               sprintf(msg, "ERROR (LEFPARS-1319): Incorrect syntax defined for property LEF57_ANTENNAAREADIFFREDUCEPWL: %s.\nCorrect syntax is \"ANTENNAAREADIFFREDUCEPWL (( diffArea1 metalDiffFactor1 ) ( diffArea2 metalDiffFactor2 )...)\"\n", values_[index]);
                lefiError(msg);
          */
!         sprintf(msg, "Incorrect syntax defined for property LEF57_ANTENNAAREADIFFREDUCEPWL: %s.\nCorrect syntax is \"ANTENNAAREADIFFREDUCEPWL (( diffArea1 metalDiffFactor1 ) ( diffArea2 metalDiffFactor2 )...)\"\n", values_[index]);
          lefError(1319, msg);
          free(wrkingStr);
          return;
--- 6432,6441 ----
      value = strtok(wrkingStr, " ");
      if (strcmp(value, "ANTENNAAREADIFFREDUCEPWL") != 0) {
          /*
!               snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1319): Incorrect syntax defined for property LEF57_ANTENNAAREADIFFREDUCEPWL: %s.\nCorrect syntax is \"ANTENNAAREADIFFREDUCEPWL (( diffArea1 metalDiffFactor1 ) ( diffArea2 metalDiffFactor2 )...)\"\n", values_[index]);
                lefiError(msg);
          */
!         snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_ANTENNAAREADIFFREDUCEPWL: %s.\nCorrect syntax is \"ANTENNAAREADIFFREDUCEPWL (( diffArea1 metalDiffFactor1 ) ( diffArea2 metalDiffFactor2 )...)\"\n", values_[index]);
          lefError(1319, msg);
          free(wrkingStr);
          return;
***************
*** 6486,6496 ****
  
      if (strcmp(type(), "CUT") != 0) {
          /*
!               sprintf(msg, "ERROR (LEFPARS-1331): The property LEF57_ENCLOSURE with value %s is for TYPE CUT only.\nThe current layer has the TYPE %s.\nUpdate the property of your lef file with the correct syntax or remove this property from your lef file.\n",
                values_[index], type());
                lefiError(msg);
          */
!         sprintf(msg, "The property LEF57_ENCLOSURE with value %s is for TYPE CUT only.\nThe current layer has the TYPE %s.\nUpdate the property of your lef file with the correct syntax or remove this property from your lef file.\n",
                  values_[index], type());
          lefError(1331, msg);
          free(wrkingStr);
--- 6486,6496 ----
  
      if (strcmp(type(), "CUT") != 0) {
          /*
!               snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1331): The property LEF57_ENCLOSURE with value %s is for TYPE CUT only.\nThe current layer has the TYPE %s.\nUpdate the property of your lef file with the correct syntax or remove this property from your lef file.\n",
                values_[index], type());
                lefiError(msg);
          */
!         snprintf(msg, sizeof(msg), "The property LEF57_ENCLOSURE with value %s is for TYPE CUT only.\nThe current layer has the TYPE %s.\nUpdate the property of your lef file with the correct syntax or remove this property from your lef file.\n",
                  values_[index], type());
          lefError(1331, msg);
          free(wrkingStr);
***************
*** 6500,6509 ****
      value = strtok(wrkingStr, " ");
      if (strcmp(value, "ENCLOSURE") != 0) {   // Unknown value
          /*
!         sprintf(msg, "ERROR (LEFPARS-1330): Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin]\n\t|LENGTH minLength] ;\"\n", values_[index]);
          lefiError(msg);
          */
!         sprintf(msg, "Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin]\n\t|LENGTH minLength] ;\"\n", values_[index]);
          lefError(1330, msg);
          free(wrkingStr);
          return;
--- 6500,6509 ----
      value = strtok(wrkingStr, " ");
      if (strcmp(value, "ENCLOSURE") != 0) {   // Unknown value
          /*
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1330): Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin]\n\t|LENGTH minLength] ;\"\n", values_[index]);
          lefiError(msg);
          */
!         snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin]\n\t|LENGTH minLength] ;\"\n", values_[index]);
          lefError(1330, msg);
          free(wrkingStr);
          return;
***************
*** 6523,6532 ****
              //   |LENGTH minLength]
              if (overh) {
                  /*
!                             sprintf(msg, "ERROR (LEFPARS-1330): Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin]\n\t|LENGTH minLength] ;\"\n", values_[index]);
                              lefiError(msg);
                  */
!                 sprintf(msg, "Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin]\n\t|LENGTH minLength] ;\"\n", values_[index]);
                  lefError(1330, msg);
                  free(wrkingStr);
                  if (enclRule)
--- 6523,6532 ----
              //   |LENGTH minLength]
              if (overh) {
                  /*
!                             snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1330): Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin]\n\t|LENGTH minLength] ;\"\n", values_[index]);
                              lefiError(msg);
                  */
!                 snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin]\n\t|LENGTH minLength] ;\"\n", values_[index]);
                  lefError(1330, msg);
                  free(wrkingStr);
                  if (enclRule)
***************
*** 6538,6547 ****
          } else if (strcmp(value, "WIDTH") == 0) {
              if ((!overh)) {
                  /*
!                             sprintf(msg, "ERROR (LEFPARS-1330): Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin]\n\t|LENGTH minLength] ;\"\n", values_[index]);
                              lefiError(msg);
                  */
!                 sprintf(msg, "Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin]\n\t|LENGTH minLength] ;\"\n", values_[index]);
                  lefError(1330, msg);
                  free(wrkingStr);
                  if (enclRule)
--- 6538,6547 ----
          } else if (strcmp(value, "WIDTH") == 0) {
              if ((!overh)) {
                  /*
!                             snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1330): Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin]\n\t|LENGTH minLength] ;\"\n", values_[index]);
                              lefiError(msg);
                  */
!                 snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin]\n\t|LENGTH minLength] ;\"\n", values_[index]);
                  lefError(1330, msg);
                  free(wrkingStr);
                  if (enclRule)
***************
*** 6567,6576 ****
          } else if (strcmp(value, "LENGTH") == 0) {
              if (width || (!overh)) {
                  /*
!                             sprintf(msg, "ERROR (LEFPARS-1330): Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin\n\t|LENGTH minLength] ;\"\n", values_[index]);
                              lefiError(msg);
                  */
!                 sprintf(msg, "Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin\n\t|LENGTH minLength] ;\"\n", values_[index]);
                  lefError(1330, msg);
                  free(wrkingStr);
                  if (enclRule)
--- 6567,6576 ----
          } else if (strcmp(value, "LENGTH") == 0) {
              if (width || (!overh)) {
                  /*
!                             snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1330): Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin\n\t|LENGTH minLength] ;\"\n", values_[index]);
                              lefiError(msg);
                  */
!                 snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin\n\t|LENGTH minLength] ;\"\n", values_[index]);
                  lefError(1330, msg);
                  free(wrkingStr);
                  if (enclRule)
***************
*** 6583,6592 ****
          } else {
              if (overh == 1) { // Already has overhang value
                  /*
!                 sprintf(msg, "ERROR (LEFPARS-1330): Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin]\n\t|LENGTH minLength] ;\"\n", values_[index]);
                  lefiError(msg);
                  */
!                 sprintf(msg, "Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin]\n\t|LENGTH minLength] ;\"\n", values_[index]);
                  lefError(1330, msg);
                  free(wrkingStr);
                  if (enclRule)
--- 6583,6592 ----
          } else {
              if (overh == 1) { // Already has overhang value
                  /*
!                 snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1330): Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin]\n\t|LENGTH minLength] ;\"\n", values_[index]);
                  lefiError(msg);
                  */
!                 snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin]\n\t|LENGTH minLength] ;\"\n", values_[index]);
                  lefError(1330, msg);
                  free(wrkingStr);
                  if (enclRule)
***************
*** 6601,6609 ****
      }
      if (!overh) {
          /*
!               sprintf(msg, "ERROR (LEFPARS-1330): Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin]\n\t|LENGTH minLength] ;\"\n", values_[index]);
          */
!         sprintf(msg, "Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin]\n\t|LENGTH minLength] ;\"\n", values_[index]);
          lefError(1330, msg);
      } else {
          addEnclosure(enclRule, overhang1, overhang2);
--- 6601,6609 ----
      }
      if (!overh) {
          /*
!               snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1330): Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin]\n\t|LENGTH minLength] ;\"\n", values_[index]);
          */
!         snprintf(msg, sizeof(msg), "Incorrect syntax defined for property LEF57_ENCLOSURE: %s\nCorrect syntax is \"ENCLOSURE [ABOVE|BELOW] overhang1 overhang2\n\t[WIDTH minWidth [EXCEPTEXTRACUT cutWithin]\n\t|LENGTH minLength] ;\"\n", values_[index]);
          lefError(1330, msg);
      } else {
          addEnclosure(enclRule, overhang1, overhang2);
***************
*** 6676,6682 ****
  
      value = strtok(wrkingStr, " ");
      if (strcmp(value, "TYPE") != 0) {   // Unknown value
!         sprintf(msg, "Incorrect syntax \"%s\" defined for property LEF58_TYPE on LAYER.\nCorrect syntax is \"TYPE {POLYROUTING | MIMCAP | TSV | PASSIVATION | NWELL | PWELL} ;\"\n", values_[index]);
          lefError(1329, msg);
          free(wrkingStr);
          return;
--- 6676,6682 ----
  
      value = strtok(wrkingStr, " ");
      if (strcmp(value, "TYPE") != 0) {   // Unknown value
!         snprintf(msg, sizeof(msg), "Incorrect syntax \"%s\" defined for property LEF58_TYPE on LAYER.\nCorrect syntax is \"TYPE {POLYROUTING | MIMCAP | TSV | PASSIVATION | NWELL | PWELL} ;\"\n", values_[index]);
          lefError(1329, msg);
          free(wrkingStr);
          return;
***************
*** 6689,6695 ****
        if ((strcmp(this->type_, "ROUTING") == 0) || (strcmp(this->type_, "CUT") == 0))
           this->lefiLayer::setLayerType(value);
        else {
!          sprintf(msg, "Property LEF58_TYPE was added in incorrect layer type.\nIt has the value MIMCAP which is for layer type ROUTING or CUT.\nThe layer type is %s.\n",
           this->type_);
           lefError(1325, msg);
        }
--- 6689,6695 ----
        if ((strcmp(this->type_, "ROUTING") == 0) || (strcmp(this->type_, "CUT") == 0))
           this->lefiLayer::setLayerType(value);
        else {
!          snprintf(msg, sizeof(msg), "Property LEF58_TYPE was added in incorrect layer type.\nIt has the value MIMCAP which is for layer type ROUTING or CUT.\nThe layer type is %s.\n",
           this->type_);
           lefError(1325, msg);
        }
***************
*** 6698,6704 ****
        if (strcmp(this->type_, "ROUTING") == 0)
           this->lefiLayer::setLayerType(value);
        else {
!          sprintf(msg, "Property LEF58_TYPE was added in incorrect layer type.\nIt has the value POLYROUTING which is for layer type ROUTING\nThe layer type is %s.\n",
           this->type_);
           lefError(1325, msg);
        }
--- 6698,6704 ----
        if (strcmp(this->type_, "ROUTING") == 0)
           this->lefiLayer::setLayerType(value);
        else {
!          snprintf(msg, sizeof(msg), "Property LEF58_TYPE was added in incorrect layer type.\nIt has the value POLYROUTING which is for layer type ROUTING\nThe layer type is %s.\n",
           this->type_);
           lefError(1325, msg);
        }
***************
*** 6708,6714 ****
        if (strcmp(this->type_, "CUT") == 0)
           this->lefiLayer::setLayerType(value);
        else {
!          sprintf(msg, "Property LEF58_TYPE was added in incorrect layer type.\nIt has the value %s which is for layer type CUT.\nThe layer type is %s.\n",
           value, this->type_);
           lefError(1326, msg);
        }
--- 6708,6714 ----
        if (strcmp(this->type_, "CUT") == 0)
           this->lefiLayer::setLayerType(value);
        else {
!          snprintf(msg, sizeof(msg), "Property LEF58_TYPE was added in incorrect layer type.\nIt has the value %s which is for layer type CUT.\nThe layer type is %s.\n",
           value, this->type_);
           lefError(1326, msg);
        }
***************
*** 6719,6735 ****
        if (strcmp(this->type_, "MASTERSLICE") == 0)
           this->lefiLayer::setLayerType(value);
        else {
!          sprintf(msg, "Property LEF58_TYPE was added in incorrect layer type.\nIt has the value %s which is for layer type MASTERSLICE.\nThe layer type is %s.\n",
           value, this->type_);
           lefError(1327, msg);
        }
     } else {
        // incorrect layer type value
  /*
!       sprintf(msg, "ERROR (LEFPARS-1328): Property LEF58_TYPE has incorrect layer type %s.\nValue layer type are: POLYROUTING, MIMCAP, TSV, PASSIVATION, NWELL or PWELL\n",
        value);
  */
!       sprintf(msg, "Property LEF58_TYPE has incorrect layer type %s.\nValue layer type are: POLYROUTING, MIMCAP, TSV, PASSIVATION, NWELL or PWELL\n",
        value);
        lefError(1328, msg);
     }
--- 6719,6735 ----
        if (strcmp(this->type_, "MASTERSLICE") == 0)
           this->lefiLayer::setLayerType(value);
        else {
!          snprintf(msg, sizeof(msg), "Property LEF58_TYPE was added in incorrect layer type.\nIt has the value %s which is for layer type MASTERSLICE.\nThe layer type is %s.\n",
           value, this->type_);
           lefError(1327, msg);
        }
     } else {
        // incorrect layer type value
  /*
!       snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1328): Property LEF58_TYPE has incorrect layer type %s.\nValue layer type are: POLYROUTING, MIMCAP, TSV, PASSIVATION, NWELL or PWELL\n",
        value);
  */
!       snprintf(msg, sizeof(msg), "Property LEF58_TYPE has incorrect layer type %s.\nValue layer type are: POLYROUTING, MIMCAP, TSV, PASSIVATION, NWELL or PWELL\n",
        value);
        lefError(1328, msg);
     }
diff -r -c source.lefdef/lef.orig/lef/lefiLayer.hpp lef/lef/lefiLayer.hpp
*** source.lefdef/lef.orig/lef/lefiLayer.hpp	Fri Feb  5 14:39:14 2016
--- lef/lef/lefiLayer.hpp	Thu Dec 31 09:41:38 2020
***************
*** 550,556 ****
    const char*  propName(int index) const;
    const char*  propValue(int index) const;
    double propNumber(int index) const;
!   const char   propType(int index) const;
    int    propIsNumber(int index) const;
    int    propIsString(int index) const;
  
--- 550,556 ----
    const char*  propName(int index) const;
    const char*  propValue(int index) const;
    double propNumber(int index) const;
!   char   propType(int index) const;
    int    propIsNumber(int index) const;
    int    propIsString(int index) const;
  
diff -r -c source.lefdef/lef.orig/lef/lefiMacro.cpp lef/lef/lefiMacro.cpp
*** source.lefdef/lef.orig/lef/lefiMacro.cpp	Fri Feb  5 14:39:14 2016
--- lef/lef/lefiMacro.cpp	Sun Jan 14 10:48:19 2024
***************
*** 1837,1843 ****
  {
      char msg[160];
      if (index < 0 || index > numPorts_) {
!         sprintf(msg, "ERROR (LEFPARS-1350): The index number %d given for the macro PIN is invalid.\nValid index is from 0 to %d", index, numPorts_);
          lefiError(0, 1350, msg);
          return 0;
      }
--- 1837,1843 ----
  {
      char msg[160];
      if (index < 0 || index > numPorts_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1350): The index number %d given for the macro PIN is invalid.\nValid index is from 0 to %d", index, numPorts_);
          lefiError(0, 1350, msg);
          return 0;
      }
***************
*** 2606,2612 ****
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         sprintf(msg, "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
--- 2606,2612 ----
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
***************
*** 2618,2624 ****
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         sprintf(msg, "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
--- 2618,2624 ----
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
***************
*** 2630,2648 ****
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         sprintf(msg, "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
      return propNums_[index];
  }
  
! const char
  lefiPin::propType(int index) const
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         sprintf(msg, "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
--- 2630,2648 ----
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
      return propNums_[index];
  }
  
! char
  lefiPin::propType(int index) const
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
***************
*** 2654,2660 ****
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         sprintf(msg, "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
--- 2654,2660 ----
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
***************
*** 2666,2672 ****
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         sprintf(msg, "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
--- 2666,2672 ----
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
***************
*** 3341,3347 ****
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         sprintf(msg, "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
--- 3341,3347 ----
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
***************
*** 3353,3359 ****
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         sprintf(msg, "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
--- 3353,3359 ----
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
***************
*** 3365,3383 ****
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         sprintf(msg, "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
      return propNums_[index];
  }
  
! const char
  lefiMacro::propType(int index) const
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         sprintf(msg, "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
--- 3365,3383 ----
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
      return propNums_[index];
  }
  
! char
  lefiMacro::propType(int index) const
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
***************
*** 3389,3395 ****
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         sprintf(msg, "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
--- 3389,3395 ----
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
***************
*** 3401,3407 ****
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         sprintf(msg, "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
--- 3401,3407 ----
  {
      char msg[160];
      if (index < 0 || index >= numProperties_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1352): The index number %d given for the macro property is invalid.\nValid index is from 0 to %d", index, numProperties_);
          lefiError(0, 1352, msg);
          return 0;
      }
diff -r -c source.lefdef/lef.orig/lef/lefiMacro.hpp lef/lef/lefiMacro.hpp
*** source.lefdef/lef.orig/lef/lefiMacro.hpp	Fri Feb  5 14:39:14 2016
--- lef/lef/lefiMacro.hpp	Thu Dec 31 09:41:38 2020
***************
*** 315,321 ****
    const  char* propName(int index) const;
    const  char* propValue(int index) const;
    double propNum(int index) const;
!   const  char  propType(int index) const;
    int    propIsNumber(int index) const;
    int    propIsString(int index) const;
  
--- 315,321 ----
    const  char* propName(int index) const;
    const  char* propValue(int index) const;
    double propNum(int index) const;
!   char   propType(int index) const;
    int    propIsNumber(int index) const;
    int    propIsString(int index) const;
  
***************
*** 559,565 ****
    const char* propName(int index) const;
    const char* propValue(int index) const;
    double propNum(int index) const;
!   const char propType(int index) const;
    int  propIsNumber(int index) const;
    int  propIsString(int index) const;
  
--- 559,565 ----
    const char* propName(int index) const;
    const char* propValue(int index) const;
    double propNum(int index) const;
!   char propType(int index) const;
    int  propIsNumber(int index) const;
    int  propIsString(int index) const;
  
diff -r -c source.lefdef/lef.orig/lef/lefiMisc.cpp lef/lef/lefiMisc.cpp
*** source.lefdef/lef.orig/lef/lefiMisc.cpp	Fri Feb  5 14:39:14 2016
--- lef/lef/lefiMisc.cpp	Sun Jan 14 10:51:27 2024
***************
*** 470,476 ****
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         sprintf(msg, "ERROR (LEFPARS-1360): The index number %d given for the geometry item is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1360, msg);
          return lefiGeomUnknown;
      }
--- 470,476 ----
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1360): The index number %d given for the geometry item is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1360, msg);
          return lefiGeomUnknown;
      }
***************
*** 482,488 ****
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         sprintf(msg, "ERROR (LEFPARS-1361): The index number %d given for the geometry RECTANGLE is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1361, msg);
          return 0;
      }
--- 482,488 ----
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1361): The index number %d given for the geometry RECTANGLE is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1361, msg);
          return 0;
      }
***************
*** 494,500 ****
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         sprintf(msg, "ERROR (LEFPARS-1362): The index number %d given for the geometry RECTANGLE ITERATE is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1362, msg);
          return 0;
      }
--- 494,500 ----
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1362): The index number %d given for the geometry RECTANGLE ITERATE is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1362, msg);
          return 0;
      }
***************
*** 506,512 ****
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         sprintf(msg, "ERROR (LEFPARS-1363): The index number %d given for the geometry PATH is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1363, msg);
          return 0;
      }
--- 506,512 ----
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1363): The index number %d given for the geometry PATH is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1363, msg);
          return 0;
      }
***************
*** 518,524 ****
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         sprintf(msg, "ERROR (LEFPARS-1364): The index number %d given for the geometry PATH ITERATE is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1364, msg);
          return 0;
      }
--- 518,524 ----
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1364): The index number %d given for the geometry PATH ITERATE is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1364, msg);
          return 0;
      }
***************
*** 530,536 ****
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         sprintf(msg, "ERROR (LEFPARS-1365): The index number %d given for the geometry LAYER is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1365, msg);
          return 0;
      }
--- 530,536 ----
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1365): The index number %d given for the geometry LAYER is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1365, msg);
          return 0;
      }
***************
*** 543,549 ****
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         sprintf(msg, "ERROR (LEFPARS-1366): The index number %d given for the geometry LAYER EXCEPT PG NET is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1366, msg);
          return 0;
      }
--- 543,549 ----
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1366): The index number %d given for the geometry LAYER EXCEPT PG NET is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1366, msg);
          return 0;
      }
***************
*** 555,561 ****
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         sprintf(msg, "ERROR (LEFPARS-1367): The index number %d given for the geometry LAYER MINSPACING is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1367, msg);
          return 0;
      }
--- 555,561 ----
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1367): The index number %d given for the geometry LAYER MINSPACING is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1367, msg);
          return 0;
      }
***************
*** 567,573 ****
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         sprintf(msg, "ERROR (LEFPARS-1368): The index number %d given for the geometry LAYER RULE WIDTH is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1368, msg);
          return 0;
      }
--- 567,573 ----
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1368): The index number %d given for the geometry LAYER RULE WIDTH is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1368, msg);
          return 0;
      }
***************
*** 579,585 ****
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         sprintf(msg, "ERROR (LEFPARS-1369): The index number %d given for the geometry WIDTH is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1369, msg);
          return 0;
      }
--- 579,585 ----
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1369): The index number %d given for the geometry WIDTH is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1369, msg);
          return 0;
      }
***************
*** 591,597 ****
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         sprintf(msg, "ERROR (LEFPARS-1370): The index number %d given for the geometry POLYGON is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1370, msg);
          return 0;
      }
--- 591,597 ----
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1370): The index number %d given for the geometry POLYGON is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1370, msg);
          return 0;
      }
***************
*** 603,609 ****
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         sprintf(msg, "ERROR (LEFPARS-1371): The index number %d given for the geometry POLYGON ITERATE is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1371, msg);
          return 0;
      }
--- 603,609 ----
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1371): The index number %d given for the geometry POLYGON ITERATE is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1371, msg);
          return 0;
      }
***************
*** 615,621 ****
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         sprintf(msg, "ERROR (LEFPARS-1372): The index number %d given for the geometry CLASS is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1372, msg);
          return 0;
      }
--- 615,621 ----
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1372): The index number %d given for the geometry CLASS is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1372, msg);
          return 0;
      }
***************
*** 627,633 ****
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         sprintf(msg, "ERROR (LEFPARS-1373): The index number %d given for the geometry VIA is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1373, msg);
          return 0;
      }
--- 627,633 ----
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1373): The index number %d given for the geometry VIA is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1373, msg);
          return 0;
      }
***************
*** 639,645 ****
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         sprintf(msg, "ERROR (LEFPARS-1374): The index number %d given for the geometry VIA ITERATE is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1374, msg);
          return 0;
      }
--- 639,645 ----
  {
      char msg[160];
      if (index < 0 || index >= numItems_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1374): The index number %d given for the geometry VIA ITERATE is invalid.\nValid index is from 0 to %d", index, numItems_);
          lefiError(0, 1374, msg);
          return 0;
      }
***************
*** 1017,1023 ****
  {
      char msg[160];
      if (index < 0 || index >= numValues_) {
!         sprintf(msg, "ERROR (LEFPARS-1376): The index number %d given for the IRDROP is invalid.\nValid index is from 0 to %d", index, numValues_);
          lefiError(0, 1376, msg);
          return 0;
      }
--- 1017,1023 ----
  {
      char msg[160];
      if (index < 0 || index >= numValues_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1376): The index number %d given for the IRDROP is invalid.\nValid index is from 0 to %d", index, numValues_);
          lefiError(0, 1376, msg);
          return 0;
      }
***************
*** 1029,1035 ****
  {
      char msg[160];
      if (index < 0 || index >= numValues_) {
!         sprintf(msg, "ERROR (LEFPARS-1376): The index number %d given for the IRDROP is invalid.\nValid index is from 0 to %d", index, numValues_);
          lefiError(0, 1376, msg);
          return 0;
      }
--- 1029,1035 ----
  {
      char msg[160];
      if (index < 0 || index >= numValues_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1376): The index number %d given for the IRDROP is invalid.\nValid index is from 0 to %d", index, numValues_);
          lefiError(0, 1376, msg);
          return 0;
      }
***************
*** 1594,1600 ****
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1377): The index number %d given for the TRACK PATTERN  is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1377, msg);
          return 0;
      }
--- 1594,1600 ----
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1377): The index number %d given for the TRACK PATTERN  is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1377, msg);
          return 0;
      }
diff -r -c source.lefdef/lef.orig/lef/lefiNonDefault.cpp lef/lef/lefiNonDefault.cpp
*** source.lefdef/lef.orig/lef/lefiNonDefault.cpp	Fri Feb  5 14:39:14 2016
--- lef/lef/lefiNonDefault.cpp	Sun Jan 14 10:53:44 2024
***************
*** 606,612 ****
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0;
      }
--- 606,612 ----
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0;
      }
***************
*** 618,624 ****
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0;
      }
--- 618,624 ----
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0;
      }
***************
*** 630,636 ****
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0.0;
      }
--- 630,636 ----
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0.0;
      }
***************
*** 642,648 ****
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0;
      }
--- 642,648 ----
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0;
      }
***************
*** 654,660 ****
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0.0;
      }
--- 654,660 ----
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0.0;
      }
***************
*** 666,672 ****
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0;
      }
--- 666,672 ----
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0;
      }
***************
*** 678,684 ****
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0;
      }
--- 678,684 ----
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0;
      }
***************
*** 690,696 ****
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0.0;
      }
--- 690,696 ----
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0.0;
      }
***************
*** 702,708 ****
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0.0;
      }
--- 702,708 ----
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0.0;
      }
***************
*** 714,720 ****
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0;
      }
--- 714,720 ----
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0;
      }
***************
*** 726,732 ****
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0.0;
      }
--- 726,732 ----
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0.0;
      }
***************
*** 738,744 ****
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0;
      }
--- 738,744 ----
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0;
      }
***************
*** 750,756 ****
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0.0;
      }
--- 750,756 ----
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0.0;
      }
***************
*** 762,768 ****
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0;
      }
--- 762,768 ----
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0;
      }
***************
*** 774,780 ****
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0.0;
      }
--- 774,780 ----
  {
      char msg[160];
      if (index < 0 || index >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1402): The index number %d given for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d", index, numLayers_);
          lefiError(0, 1402, msg);
          return 0.0;
      }
***************
*** 792,798 ****
  {
      char msg[160];
      if (index < 0 || index >= numVias_) {
!         sprintf(msg, "ERROR (LEFPARS-1403): The index number %d given for the NONDEFAULT VIA is invalid.\nValid index is from 0 to %d", index, numVias_);
          lefiError(0, 1403, msg);
          return 0;
      }
--- 792,798 ----
  {
      char msg[160];
      if (index < 0 || index >= numVias_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1403): The index number %d given for the NONDEFAULT VIA is invalid.\nValid index is from 0 to %d", index, numVias_);
          lefiError(0, 1403, msg);
          return 0;
      }
***************
*** 810,816 ****
  {
      char msg[160];
      if (index < 0 || index >= numSpacing_) {
!         sprintf(msg, "ERROR (LEFPARS-1404): The index number %d given for the NONDEFAULT SPACING is invalid.\nValid index is from 0 to %d", index, numSpacing_);
          lefiError(0, 1404, msg);
          return 0;
      }
--- 810,816 ----
  {
      char msg[160];
      if (index < 0 || index >= numSpacing_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1404): The index number %d given for the NONDEFAULT SPACING is invalid.\nValid index is from 0 to %d", index, numSpacing_);
          lefiError(0, 1404, msg);
          return 0;
      }
***************
*** 840,846 ****
  {
      char msg[160];
      if (index < 0 || index >= numUseVias_) {
!         sprintf(msg, "ERROR (LEFPARS-1405): The index number %d given for the NONDEFAULT USE VIA is invalid.\nValid index is from 0 to %d", index, numUseVias_);
          lefiError(0, 1405, msg);
          return 0;
      }
--- 840,846 ----
  {
      char msg[160];
      if (index < 0 || index >= numUseVias_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1405): The index number %d given for the NONDEFAULT USE VIA is invalid.\nValid index is from 0 to %d", index, numUseVias_);
          lefiError(0, 1405, msg);
          return 0;
      }
***************
*** 858,864 ****
  {
      char msg[160];
      if (index < 0 || index >= numUseViaRules_) {
!         sprintf(msg, "ERROR (LEFPARS-1406): The index number %d given for the NONDEFAULT USE VIARULE is invalid.\nValid index is from 0 to %d", index, numUseViaRules_);
          lefiError(0, 1406, msg);
          return 0;
      }
--- 858,864 ----
  {
      char msg[160];
      if (index < 0 || index >= numUseViaRules_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1406): The index number %d given for the NONDEFAULT USE VIARULE is invalid.\nValid index is from 0 to %d", index, numUseViaRules_);
          lefiError(0, 1406, msg);
          return 0;
      }
***************
*** 876,882 ****
  {
      char msg[160];
      if (index < 0 || index >= numMinCuts_) {
!         sprintf(msg, "ERROR (LEFPARS-1407): The index number %d given for the NONDEFAULT CUT is invalid.\nValid index is from 0 to %d", index, numMinCuts_);
          lefiError(0, 1407, msg);
          return 0;
      }
--- 876,882 ----
  {
      char msg[160];
      if (index < 0 || index >= numMinCuts_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1407): The index number %d given for the NONDEFAULT CUT is invalid.\nValid index is from 0 to %d", index, numMinCuts_);
          lefiError(0, 1407, msg);
          return 0;
      }
***************
*** 888,894 ****
  {
      char msg[160];
      if (index < 0 || index >= numMinCuts_) {
!         sprintf(msg, "ERROR (LEFPARS-1407): The index number %d given for the NONDEFAULT CUT is invalid.\nValid index is from 0 to %d", index, numMinCuts_);
          lefiError(0, 1407, msg);
          return 0;
      }
--- 888,894 ----
  {
      char msg[160];
      if (index < 0 || index >= numMinCuts_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1407): The index number %d given for the NONDEFAULT CUT is invalid.\nValid index is from 0 to %d", index, numMinCuts_);
          lefiError(0, 1407, msg);
          return 0;
      }
***************
*** 1050,1056 ****
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1408): The index number %d given for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
          lefiError(0, 1408, msg);
          return 0;
      }
--- 1050,1056 ----
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1408): The index number %d given for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
          lefiError(0, 1408, msg);
          return 0;
      }
***************
*** 1062,1068 ****
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1408): The index number %d given for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
          lefiError(0, 1408, msg);
          return 0;
      }
--- 1062,1068 ----
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1408): The index number %d given for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
          lefiError(0, 1408, msg);
          return 0;
      }
***************
*** 1074,1092 ****
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1408): The index number %d given for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
          lefiError(0, 1408, msg);
          return 0;
      }
      return dvalues_[index];
  }
  
! const char
  lefiNonDefault::propType(int index) const
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1408): The index number %d given for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
          lefiError(0, 1408, msg);
          return 0;
      }
--- 1074,1092 ----
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1408): The index number %d given for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
          lefiError(0, 1408, msg);
          return 0;
      }
      return dvalues_[index];
  }
  
! char
  lefiNonDefault::propType(int index) const
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1408): The index number %d given for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
          lefiError(0, 1408, msg);
          return 0;
      }
***************
*** 1098,1104 ****
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1408): The index number %d given for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
          lefiError(0, 1408, msg);
          return 0;
      }
--- 1098,1104 ----
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1408): The index number %d given for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
          lefiError(0, 1408, msg);
          return 0;
      }
***************
*** 1110,1116 ****
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1408): The index number %d given for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
          lefiError(0, 1408, msg);
          return 0;
      }
--- 1110,1116 ----
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1408): The index number %d given for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
          lefiError(0, 1408, msg);
          return 0;
      }
diff -r -c source.lefdef/lef.orig/lef/lefiNonDefault.hpp lef/lef/lefiNonDefault.hpp
*** source.lefdef/lef.orig/lef/lefiNonDefault.hpp	Fri Feb  5 14:39:14 2016
--- lef/lef/lefiNonDefault.hpp	Thu Dec 31 09:41:38 2020
***************
*** 73,79 ****
    const char*  propName(int index) const;
    const char*  propValue(int index) const;
    double propNumber(int index) const;
!   const char   propType(int index) const;
    int    propIsNumber(int index) const;
    int    propIsString(int index) const;
    
--- 73,79 ----
    const char*  propName(int index) const;
    const char*  propValue(int index) const;
    double propNumber(int index) const;
!   char   propType(int index) const;
    int    propIsNumber(int index) const;
    int    propIsString(int index) const;
    
diff -r -c source.lefdef/lef.orig/lef/lefiPropType.cpp lef/lef/lefiPropType.cpp
*** source.lefdef/lef.orig/lef/lefiPropType.cpp	Fri Feb  5 14:39:14 2016
--- lef/lef/lefiPropType.cpp	Thu Dec 31 09:41:38 2020
***************
*** 123,129 ****
      propTypes_ = newt;
  }
  
! const char
  lefiPropType::propType(char *name) const
  {
      int i;
--- 123,129 ----
      propTypes_ = newt;
  }
  
! char
  lefiPropType::propType(char *name) const
  {
      int i;
diff -r -c source.lefdef/lef.orig/lef/lefiPropType.hpp lef/lef/lefiPropType.hpp
*** source.lefdef/lef.orig/lef/lefiPropType.hpp	Fri Feb  5 14:39:14 2016
--- lef/lef/lefiPropType.hpp	Thu Dec 31 09:41:38 2020
***************
*** 48,54 ****
    void setPropType(const char* name, const char type);
    void Clear();
  
!   const char propType(char* name) const;
    void bumpProps();
  
  protected:
--- 48,54 ----
    void setPropType(const char* name, const char type);
    void Clear();
  
!   char propType(char* name) const;
    void bumpProps();
  
  protected:
diff -r -c source.lefdef/lef.orig/lef/lefiVia.cpp lef/lef/lefiVia.cpp
*** source.lefdef/lef.orig/lef/lefiVia.cpp	Fri Feb  5 14:39:14 2016
--- lef/lef/lefiVia.cpp	Sun Jan 14 10:56:38 2024
***************
*** 295,301 ****
      char msg[160];
  
      if (index < 0 || index >= numRects_) {
!         sprintf(msg, "ERROR (LEFPARS-1420): The index number %d given for the VIA LAYER RECTANGLE is invalid.\nValid index is from 0 to %d", index, numRects_);
          lefiError(0, 1420, msg);
          return 0;
      }
--- 295,301 ----
      char msg[160];
  
      if (index < 0 || index >= numRects_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1420): The index number %d given for the VIA LAYER RECTANGLE is invalid.\nValid index is from 0 to %d", index, numRects_);
          lefiError(0, 1420, msg);
          return 0;
      }
***************
*** 309,315 ****
      char msg[160];
  
      if (index < 0 || index >= numPolys_) {
!         sprintf(msg, "ERROR (LEFPARS-1420): The index number %d given for the VIA LAYER POLYGON is invalid.\nValid index is from 0 to %d", index, numPolys_);
          lefiError(0, 1420, msg);
          return 0;
      }
--- 309,315 ----
      char msg[160];
  
      if (index < 0 || index >= numPolys_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1420): The index number %d given for the VIA LAYER POLYGON is invalid.\nValid index is from 0 to %d", index, numPolys_);
          lefiError(0, 1420, msg);
          return 0;
      }
***************
*** 322,328 ****
  {
      char msg[160];
      if (index < 0 || index >= numRects_) {
!         sprintf(msg, "ERROR (LEFPARS-1420): The index number %d given for the VIA LAYER RECTANGLE is invalid.\nValid index is from 0 to %d", index, numRects_);
          lefiError(0, 1420, msg);
          return 0;
      }
--- 322,328 ----
  {
      char msg[160];
      if (index < 0 || index >= numRects_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1420): The index number %d given for the VIA LAYER RECTANGLE is invalid.\nValid index is from 0 to %d", index, numRects_);
          lefiError(0, 1420, msg);
          return 0;
      }
***************
*** 334,340 ****
  {
      char msg[160];
      if (index < 0 || index >= numRects_) {
!         sprintf(msg, "ERROR (LEFPARS-1420): The index number %d given for the VIA LAYER RECTANGLE is invalid.\nValid index is from 0 to %d", index, numRects_);
          lefiError(0, 1420, msg);
          return 0;
      }
--- 334,340 ----
  {
      char msg[160];
      if (index < 0 || index >= numRects_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1420): The index number %d given for the VIA LAYER RECTANGLE is invalid.\nValid index is from 0 to %d", index, numRects_);
          lefiError(0, 1420, msg);
          return 0;
      }
***************
*** 346,352 ****
  {
      char msg[160];
      if (index < 0 || index >= numRects_) {
!         sprintf(msg, "ERROR (LEFPARS-1420): The index number %d given for the VIA LAYER RECTANGLE is invalid.\nValid index is from 0 to %d", index, numRects_);
          lefiError(0, 1420, msg);
          return 0;
      }
--- 346,352 ----
  {
      char msg[160];
      if (index < 0 || index >= numRects_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1420): The index number %d given for the VIA LAYER RECTANGLE is invalid.\nValid index is from 0 to %d", index, numRects_);
          lefiError(0, 1420, msg);
          return 0;
      }
***************
*** 358,364 ****
  {
      char msg[160];
      if (index < 0 || index >= numRects_) {
!         sprintf(msg, "ERROR (LEFPARS-1420): The index number %d given for the VIA LAYER RECTANGLE is invalid.\nValid index is from 0 to %d", index, numRects_);
          lefiError(0, 1420, msg);
          return 0;
      }
--- 358,364 ----
  {
      char msg[160];
      if (index < 0 || index >= numRects_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1420): The index number %d given for the VIA LAYER RECTANGLE is invalid.\nValid index is from 0 to %d", index, numRects_);
          lefiError(0, 1420, msg);
          return 0;
      }
***************
*** 998,1004 ****
      lefiViaLayer    *vl;
      char            msg[160];
      if (layerNum < 0 || layerNum >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1421): The layer number %d given for the VIA LAYER is invalid.\nValid number is from 0 to %d", layerNum, numLayers_);
          lefiError(0, 1421, msg);
          return 0;
      }
--- 998,1004 ----
      lefiViaLayer    *vl;
      char            msg[160];
      if (layerNum < 0 || layerNum >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1421): The layer number %d given for the VIA LAYER is invalid.\nValid number is from 0 to %d", layerNum, numLayers_);
          lefiError(0, 1421, msg);
          return 0;
      }
***************
*** 1012,1018 ****
      lefiViaLayer    *vl;
      char            msg[160];
      if (layerNum < 0 || layerNum >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1421): The layer number %d given for the VIA LAYER is invalid.\nValid number is from 0 to %d", layerNum, numLayers_);
          lefiError(0, 1421, msg);
          return 0;
      }
--- 1012,1018 ----
      lefiViaLayer    *vl;
      char            msg[160];
      if (layerNum < 0 || layerNum >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1421): The layer number %d given for the VIA LAYER is invalid.\nValid number is from 0 to %d", layerNum, numLayers_);
          lefiError(0, 1421, msg);
          return 0;
      }
***************
*** 1027,1033 ****
      lefiViaLayer    *vl;
      char            msg[160];
      if (layerNum < 0 || layerNum >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1421): The layer number %d given for the VIA LAYER is invalid.\nValid number is from 0 to %d", layerNum, numLayers_);
          lefiError(0, 1421, msg);
          return 0;
      }
--- 1027,1033 ----
      lefiViaLayer    *vl;
      char            msg[160];
      if (layerNum < 0 || layerNum >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1421): The layer number %d given for the VIA LAYER is invalid.\nValid number is from 0 to %d", layerNum, numLayers_);
          lefiError(0, 1421, msg);
          return 0;
      }
***************
*** 1042,1048 ****
      lefiViaLayer    *vl;
      char            msg[160];
      if (layerNum < 0 || layerNum >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1421): The layer number %d given for the VIA LAYER is invalid.\nValid number is from 0 to %d", layerNum, numLayers_);
          lefiError(0, 1421, msg);
          return 0;
      }
--- 1042,1048 ----
      lefiViaLayer    *vl;
      char            msg[160];
      if (layerNum < 0 || layerNum >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1421): The layer number %d given for the VIA LAYER is invalid.\nValid number is from 0 to %d", layerNum, numLayers_);
          lefiError(0, 1421, msg);
          return 0;
      }
***************
*** 1057,1063 ****
      lefiViaLayer    *vl;
      char            msg[160];
      if (layerNum < 0 || layerNum >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1421): The layer number %d given for the VIA LAYER is invalid.\nValid number is from 0 to %d", layerNum, numLayers_);
          lefiError(0, 1421, msg);
          return 0;
      }
--- 1057,1063 ----
      lefiViaLayer    *vl;
      char            msg[160];
      if (layerNum < 0 || layerNum >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1421): The layer number %d given for the VIA LAYER is invalid.\nValid number is from 0 to %d", layerNum, numLayers_);
          lefiError(0, 1421, msg);
          return 0;
      }
***************
*** 1072,1078 ****
      lefiViaLayer    *vl;
      char            msg[160];
      if (layerNum < 0 || layerNum >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1421): The layer number %d given for the VIA LAYER is invalid.\nValid number is from 0 to %d", layerNum, numLayers_);
          lefiError(0, 1421, msg);
          return 0;
      }
--- 1072,1078 ----
      lefiViaLayer    *vl;
      char            msg[160];
      if (layerNum < 0 || layerNum >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1421): The layer number %d given for the VIA LAYER is invalid.\nValid number is from 0 to %d", layerNum, numLayers_);
          lefiError(0, 1421, msg);
          return 0;
      }
***************
*** 1088,1094 ****
      char            msg[160];
  
      if (layerNum < 0 || layerNum >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1421): The layer number %d given for the VIA LAYER is invalid.\nValid number is from 0 to %d", layerNum, numLayers_);
          lefiError(0, 1421, msg);
          return 0;
      }
--- 1088,1094 ----
      char            msg[160];
  
      if (layerNum < 0 || layerNum >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1421): The layer number %d given for the VIA LAYER is invalid.\nValid number is from 0 to %d", layerNum, numLayers_);
          lefiError(0, 1421, msg);
          return 0;
      }
***************
*** 1106,1112 ****
      char            msg[160];
  
      if (layerNum < 0 || layerNum >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1421): The layer number %d given for the VIA LAYER is invalid.\nValid number is from 0 to %d", layerNum, numLayers_);
          lefiError(0, 1421, msg);
          return 0;
      }
--- 1106,1112 ----
      char            msg[160];
  
      if (layerNum < 0 || layerNum >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1421): The layer number %d given for the VIA LAYER is invalid.\nValid number is from 0 to %d", layerNum, numLayers_);
          lefiError(0, 1421, msg);
          return 0;
      }
***************
*** 1122,1128 ****
      lefiViaLayer    *vl;
      char            msg[160];
      if (layerNum < 0 || layerNum >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1421): The layer number %d given for the VIA LAYER is invalid.\nValid number is from 0 to %d", layerNum, numLayers_);
          lefiError(0, 1421, msg);
          return 0;
      }
--- 1122,1128 ----
      lefiViaLayer    *vl;
      char            msg[160];
      if (layerNum < 0 || layerNum >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1421): The layer number %d given for the VIA LAYER is invalid.\nValid number is from 0 to %d", layerNum, numLayers_);
          lefiError(0, 1421, msg);
          return 0;
      }
***************
*** 1144,1150 ****
      tempPoly.colorMask = 0;
  
      if (layerNum < 0 || layerNum >= numLayers_) {
!         sprintf(msg, "ERROR (LEFPARS-1421): The layer number %d given for the VIA LAYER is invalid.\nValid number is from 0 to %d", layerNum, numLayers_);
          lefiError(0, 1421, msg);
          return tempPoly;
      }
--- 1144,1150 ----
      tempPoly.colorMask = 0;
  
      if (layerNum < 0 || layerNum >= numLayers_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1421): The layer number %d given for the VIA LAYER is invalid.\nValid number is from 0 to %d", layerNum, numLayers_);
          lefiError(0, 1421, msg);
          return tempPoly;
      }
***************
*** 1179,1185 ****
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1422): The layer number %d given for the VIA PROPERTY is invalid.\nValid number is from 0 to %d", index, numLayers_);
          lefiError(0, 1422, msg);
          return 0;
      }
--- 1179,1185 ----
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1422): The layer number %d given for the VIA PROPERTY is invalid.\nValid number is from 0 to %d", index, numLayers_);
          lefiError(0, 1422, msg);
          return 0;
      }
***************
*** 1191,1197 ****
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1422): The layer number %d given for the VIA PROPERTY is invalid.\nValid number is from 0 to %d", index, numLayers_);
          lefiError(0, 1422, msg);
          return 0;
      }
--- 1191,1197 ----
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1422): The layer number %d given for the VIA PROPERTY is invalid.\nValid number is from 0 to %d", index, numLayers_);
          lefiError(0, 1422, msg);
          return 0;
      }
***************
*** 1203,1209 ****
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1422): The layer number %d given for the VIA PROPERTY is invalid.\nValid number is from 0 to %d", index, numLayers_);
          lefiError(0, 1422, msg);
          return 0;
      }
--- 1203,1209 ----
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1422): The layer number %d given for the VIA PROPERTY is invalid.\nValid number is from 0 to %d", index, numLayers_);
          lefiError(0, 1422, msg);
          return 0;
      }
***************
*** 1215,1221 ****
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1422): The layer number %d given for the VIA PROPERTY is invalid.\nValid number is from 0 to %d", index, numLayers_);
          lefiError(0, 1422, msg);
          return 0;
      }
--- 1215,1221 ----
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1422): The layer number %d given for the VIA PROPERTY is invalid.\nValid number is from 0 to %d", index, numLayers_);
          lefiError(0, 1422, msg);
          return 0;
      }
***************
*** 1227,1233 ****
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1422): The layer number %d given for the VIA PROPERTY is invalid.\nValid number is from 0 to %d", index, numLayers_);
          lefiError(0, 1422, msg);
          return 0;
      }
--- 1227,1233 ----
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1422): The layer number %d given for the VIA PROPERTY is invalid.\nValid number is from 0 to %d", index, numLayers_);
          lefiError(0, 1422, msg);
          return 0;
      }
***************
*** 1239,1245 ****
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1422): The layer number %d given for the VIA PROPERTY is invalid.\nValid number is from 0 to %d", index, numLayers_);
          lefiError(0, 1422, msg);
          return 0;
      }
--- 1239,1245 ----
  {
      char msg[160];
      if (index < 0 || index >= numProps_) {
!         snprintf(msg, sizeof(msg),"ERROR (LEFPARS-1422): The layer number %d given for the VIA PROPERTY is invalid.\nValid number is from 0 to %d", index, numLayers_);
          lefiError(0, 1422, msg);
          return 0;
      }
diff -r -c source.lefdef/lef.orig/lef/lefiViaRule.cpp lef/lef/lefiViaRule.cpp
*** source.lefdef/lef.orig/lef/lefiViaRule.cpp	Fri Feb  5 14:39:14 2016
--- lef/lef/lefiViaRule.cpp	Sun Jan 14 10:57:43 2024
***************
*** 59,66 ****
    spacingStepX_(0.0),
    spacingStepY_(0.0),
    xl_(0.0),
-   xh_(0.0),
    yl_(0.0),
    yh_(0.0)
  {
      Init();
--- 59,66 ----
    spacingStepX_(0.0),
    spacingStepY_(0.0),
    xl_(0.0),
    yl_(0.0),
+   xh_(0.0),
    yh_(0.0)
  {
      Init();
***************
*** 776,782 ****
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1431): The index number %d given for the VIARULE PROPERTY is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1431, msg);
          return 0;
      }
--- 776,782 ----
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1431): The index number %d given for the VIARULE PROPERTY is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1431, msg);
          return 0;
      }
***************
*** 788,794 ****
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1431): The index number %d given for the VIARULE PROPERTY is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1431, msg);
          return 0;
      }
--- 788,794 ----
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1431): The index number %d given for the VIARULE PROPERTY is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1431, msg);
          return 0;
      }
***************
*** 800,818 ****
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1431): The index number %d given for the VIARULE PROPERTY is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1431, msg);
          return 0;
      }
      return dvalues_[i];
  }
  
! const char
  lefiViaRule::propType(int i) const
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1431): The index number %d given for the VIARULE PROPERTY is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1431, msg);
          return 0;
      }
--- 800,818 ----
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1431): The index number %d given for the VIARULE PROPERTY is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1431, msg);
          return 0;
      }
      return dvalues_[i];
  }
  
! char
  lefiViaRule::propType(int i) const
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1431): The index number %d given for the VIARULE PROPERTY is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1431, msg);
          return 0;
      }
***************
*** 824,830 ****
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1431): The index number %d given for the VIARULE PROPERTY is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1431, msg);
          return 0;
      }
--- 824,830 ----
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1431): The index number %d given for the VIARULE PROPERTY is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1431, msg);
          return 0;
      }
***************
*** 836,842 ****
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         sprintf(msg, "ERROR (LEFPARS-1431): The index number %d given for the VIARULE PROPERTY is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1431, msg);
          return 0;
      }
--- 836,842 ----
  {
      char msg[160];
      if (i < 0 || i >= numProps_) {
!         snprintf(msg, sizeof(msg), "ERROR (LEFPARS-1431): The index number %d given for the VIARULE PROPERTY is invalid.\nValid index is from 0 to %d", i, numProps_);
          lefiError(0, 1431, msg);
          return 0;
      }
diff -r -c source.lefdef/lef.orig/lef/lefiViaRule.hpp lef/lef/lefiViaRule.hpp
*** source.lefdef/lef.orig/lef/lefiViaRule.hpp	Fri Feb  5 14:39:14 2016
--- lef/lef/lefiViaRule.hpp	Thu Dec 31 09:41:38 2020
***************
*** 161,167 ****
    const char*  propName(int index) const;
    const char*  propValue(int index) const;
    double propNumber(int index) const;
!   const char   propType(int index) const;
    int    propIsNumber(int index) const;
    int    propIsString(int index) const;
  
--- 161,167 ----
    const char*  propName(int index) const;
    const char*  propValue(int index) const;
    double propNumber(int index) const;
!   char   propType(int index) const;
    int    propIsNumber(int index) const;
    int    propIsString(int index) const;
  
diff -r -c source.lefdef/lef.orig/lef/lefrData.cpp lef/lef/lefrData.cpp
*** source.lefdef/lef.orig/lef/lefrData.cpp	Fri Feb  5 14:39:14 2016
--- lef/lef/lefrData.cpp	Thu Dec 31 09:41:38 2020
***************
*** 43,55 ****
  lefrData  *lefData = NULL;
  
  lefrData::lefrData()
! : antennaInoutWarnings(0),
    antennaInputWarnings(0),
    antennaOutputWarnings(0),
-   antennaType(lefiAntennaAR),
    arrayCutsVal(0),
    arrayCutsWar(0),
-   arrayName(NULL),
    arrayWarnings(0),
    caseSensitiveWarnings(0),
    correctionTableWarnings(0),
--- 43,81 ----
  lefrData  *lefData = NULL;
  
  lefrData::lefrData()
! : lefrFile(0),
!   lefrLog(0),
! 
!   lefPropDefType('\0'),
! 
!   arrayName(NULL),
!   last(NULL),
!   layerName(NULL),
!   lefch(NULL),
!   lefrFileName(0),
!   macroName(NULL),
!   ndName(0),
!   next(NULL),
!   nonDefaultRuleName(NULL),
!   outMsg(NULL),
!   pinName(NULL),
!   shiftBuf(0),
!   siteName(NULL),
!   viaName(NULL),
!   viaRuleName(NULL),
! 
!   layerCutSpacing(0),
!   lef_save_x(0.0),
!   lef_save_y(0.0),
!   leflVal(0.0),
!   lefrVal(0.0),
!   versionNum(CURRENT_VERSION),
! 
!   antennaInoutWarnings(0),
    antennaInputWarnings(0),
    antennaOutputWarnings(0),
    arrayCutsVal(0),
    arrayCutsWar(0),
    arrayWarnings(0),
    caseSensitiveWarnings(0),
    correctionTableWarnings(0),
***************
*** 98,109 ****
    inputAntennaWarnings(0),
    input_level(-1),
    isGenerate(0),
-   last(NULL),
    layerCut(0),
-   layerCutSpacing(0),
    layerDir(0),
    layerMastOver(0),
-   layerName(NULL),
    layerRout(0),
    layerWarnings(0),
    lefDefIf(FALSE),
--- 124,132 ----
***************
*** 114,125 ****
    lefInPropDef(0),
    lefInfoMsgPrinted(0),
    lefInvalidChar(0),
-   namesCaseSensitive(TRUE),
    lefNdRule(0),
    lefNewIsKeyword(0),
    lefNlToken(FALSE),
    lefNoNum(0),
-   lefPropDefType('\0'),
    lefRealNum(0),
    lefRetVal(0),
    lefWRetVal(0),
--- 137,146 ----
***************
*** 127,210 ****
    lef_errors(0),
    lef_nlines(1),
    lef_ntokens(0),
-   lef_save_x(0.0),
-   lef_save_y(0.0),
    lef_warnings(0),
-   lefch(NULL),
-   leflVal(0.0),
-   lefrAntennaPWLPtr(0),
-   lefrArray(),
-   lefrCorrectionTable(),
-   lefrDensity(),
    lefrDoGcell(0),
    lefrDoGeometries(0),
    lefrDoSite(0),
    lefrDoTrack(0),
-   lefrFile(0),
-   lefrFileName(0),
-   lefrGcellPatternPtr(0),
-   lefrGeometriesPtr(0),
    lefrHasLayer(0),
    lefrHasMaxVS(0),
    lefrHasSpacing(0),
    lefrHasSpacingTbl(0),
!   lefrIRDrop(),
!   lefrLayer(),
!   lefrLog(0),
!   lefrMacro(),
!   lefrMaxStackVia(),
!   lefrMinFeature(),
!   lefrNoiseMargin(),
!   lefrNoiseTable(),
!   lefrNonDefault(),
!   lefrObstruction(),
!   lefrPin(),
!   lefrProp(),
!   lefrSite(),
!   lefrSitePatternPtr(0),
!   lefrSpacing(),
!   lefrTiming(),
!   lefrTrackPatternPtr(0),
!   lefrUnits(),
!   lefrUseMinSpacing(),
!   lefrVal(0.0),
!   lefrVia(),
!   lefrViaRule(),
!   macroName(NULL),
!   macroNum(),
    macroWarnings(0),
    maxStackViaWarnings(0),
- 
    minFeatureWarnings(0),
    msgCnt(1),
!   nd(0),
    ndLayer(0),
    ndLayerSpace(0),
    ndLayerWidth(0),
-   ndName(0),
    ndRule(0),
    needGeometry(0),
-   next(NULL),
    noWireExtensionWarnings(0),
    noiseMarginWarnings(0),
    noiseTableWarnings(0),
-   nonDefaultRuleName(NULL),
    nonDefaultWarnings(0),
    numVia(0),
    obsDef(0),
    origDef(0),
-   outMsg(NULL),
    outputAntennaWarnings(0),
    pinDef(0),
-   pinName(NULL),
    pinWarnings(0),
    prtNewLine(0),
    prtSemiColon(0),
    ringPlace(0),
-   shiftBuf(0),
    shiftBufLength(0),
    siteDef(0),
-   siteName(NULL),
    siteWarnings(0),
    sizeDef(0),
    spParallelLength(0),
--- 148,188 ----
    lef_errors(0),
    lef_nlines(1),
    lef_ntokens(0),
    lef_warnings(0),
    lefrDoGcell(0),
    lefrDoGeometries(0),
    lefrDoSite(0),
    lefrDoTrack(0),
    lefrHasLayer(0),
    lefrHasMaxVS(0),
    lefrHasSpacing(0),
    lefrHasSpacingTbl(0),
! 
    macroWarnings(0),
    maxStackViaWarnings(0),
    minFeatureWarnings(0),
    msgCnt(1),
!   namesCaseSensitive(TRUE),
    ndLayer(0),
    ndLayerSpace(0),
    ndLayerWidth(0),
    ndRule(0),
    needGeometry(0),
    noWireExtensionWarnings(0),
    noiseMarginWarnings(0),
    noiseTableWarnings(0),
    nonDefaultWarnings(0),
    numVia(0),
    obsDef(0),
    origDef(0),
    outputAntennaWarnings(0),
    pinDef(0),
    pinWarnings(0),
    prtNewLine(0),
    prtSemiColon(0),
    ringPlace(0),
    shiftBufLength(0),
    siteDef(0),
    siteWarnings(0),
    sizeDef(0),
    spParallelLength(0),
***************
*** 217,231 ****
    use5_4(0),
    useLenThr(0),
    useMinSpacingWarnings(0),
-   versionNum(CURRENT_VERSION),
    viaLayer(0),
-   viaName(NULL),
    viaRuleHasDir(0),
    viaRuleHasEnc(0),
    viaRuleLayer(0),
-   viaRuleName(NULL),
    viaRuleWarnings(0),
    viaWarnings(0),
    current_token((char*) malloc(TOKEN_SIZE)),
    pv_token((char*) malloc(TOKEN_SIZE)),
    uc_token((char*) malloc(TOKEN_SIZE)), 
--- 195,237 ----
    use5_4(0),
    useLenThr(0),
    useMinSpacingWarnings(0),
    viaLayer(0),
    viaRuleHasDir(0),
    viaRuleHasEnc(0),
    viaRuleLayer(0),
    viaRuleWarnings(0),
    viaWarnings(0),
+ 
+   antennaType(lefiAntennaAR),
+   lefrAntennaPWLPtr(0),
+   lefrArray(),
+   lefrCorrectionTable(),
+   lefrDensity(),
+   lefrGcellPatternPtr(0),
+   lefrGeometriesPtr(0),
+   lefrIRDrop(),
+   lefrLayer(),
+   lefrMacro(),
+   lefrMaxStackVia(),
+   lefrMinFeature(),
+   lefrNoiseMargin(),
+   lefrNoiseTable(),
+   lefrNonDefault(),
+   nd(0),
+   macroNum(),
+   lefrObstruction(),
+   lefrPin(),
+   lefrProp(),
+   lefrSite(),
+   lefrSitePatternPtr(0),
+   lefrSpacing(),
+   lefrTiming(),
+   lefrTrackPatternPtr(0),
+   lefrUnits(),
+   lefrUseMinSpacing(),
+   lefrVia(),
+   lefrViaRule(),
+ 
    current_token((char*) malloc(TOKEN_SIZE)),
    pv_token((char*) malloc(TOKEN_SIZE)),
    uc_token((char*) malloc(TOKEN_SIZE)), 
diff -r -c source.lefdef/lef.orig/lef/lefrData.hpp lef/lef/lefrData.hpp
*** source.lefdef/lef.orig/lef/lefrData.hpp	Fri Feb  5 14:39:14 2016
--- lef/lef/lefrData.hpp	Thu Dec 31 09:41:38 2020
***************
*** 270,291 ****
      lefiUseMinSpacing  lefrUseMinSpacing; 
      lefiVia  lefrVia; 
      lefiViaRule  lefrViaRule; 
!     
      lefStringMap        alias_set; 
      lefDoubleMap        define_set; 
      lefIntMap           defineb_set; 
      lefStringMap        defines_set; 
-     int                 tokenSize;
  
      //ARRAYS
      // Ring buffer storage 
      char       *ring[RING_SIZE];
      int         ringSizes[RING_SIZE];
      char        lefDebug[100];
- 
-     char       *current_token; 
-     char       *pv_token; 
-     char       *uc_token; 
  
      char       current_buffer[IN_BUF_SIZE];
      const char *current_stack[20];  // the stack itself 
--- 270,291 ----
      lefiUseMinSpacing  lefrUseMinSpacing; 
      lefiVia  lefrVia; 
      lefiViaRule  lefrViaRule; 
! 
!     char                *current_token; 
!     char                *pv_token; 
!     char                *uc_token; 
!     int                 tokenSize;
! 
      lefStringMap        alias_set; 
      lefDoubleMap        define_set; 
      lefIntMap           defineb_set; 
      lefStringMap        defines_set; 
  
      //ARRAYS
      // Ring buffer storage 
      char       *ring[RING_SIZE];
      int         ringSizes[RING_SIZE];
      char        lefDebug[100];
  
      char       current_buffer[IN_BUF_SIZE];
      const char *current_stack[20];  // the stack itself 
diff -r -c source.lefdef/lef.orig/lef/lefrReader.cpp lef/lef/lefrReader.cpp
*** source.lefdef/lef.orig/lef/lefrReader.cpp	Fri Feb  5 14:39:14 2016
--- lef/lef/lefrReader.cpp	Sun Jan 14 11:45:50 2024
***************
*** 66,72 ****
  void
  lefiNerr(int i)
  {
!     sprintf(lefData->lefrErrMsg, "ERROR number %d\n", i);
      lefiError(1, 0, lefData->lefrErrMsg);
      exit(2);
  }
--- 66,72 ----
  void
  lefiNerr(int i)
  {
!     snprintf(lefData->lefrErrMsg, 32, "ERROR number %d\n", i);
      lefiError(1, 0, lefData->lefrErrMsg);
      exit(2);
  }
***************
*** 74,80 ****
  void
  lefiNwarn(int i)
  {
!     sprintf(lefData->lefrErrMsg, "WARNING number %d\n", i);
      lefiError(1, 0, lefData->lefrErrMsg);
      exit(2);
  }
--- 74,80 ----
  void
  lefiNwarn(int i)
  {
!     snprintf(lefData->lefrErrMsg, 32, "WARNING number %d\n", i);
      lefiError(1, 0, lefData->lefrErrMsg);
      exit(2);
  }
***************
*** 113,119 ****
  
      lefFree(versionNm);
  
!     sprintf(finalVersion, "%.4f", version);
  
      versionNumber = atof(finalVersion);
  
--- 113,119 ----
  
      lefFree(versionNm);
  
!     snprintf(finalVersion, 12, "%.4f", version);
  
      versionNumber = atof(finalVersion);
  
***************
*** 202,208 ****
      LEF_INIT;
      char msgStr[10];
      if ((msgId <= 0) || (msgId >= NOLEFMSG)) {
!         sprintf(msgStr, "%d", msgId);
          lefError(204, msgStr);
          return;
      }
--- 202,208 ----
      LEF_INIT;
      char msgStr[10];
      if ((msgId <= 0) || (msgId >= NOLEFMSG)) {
!         snprintf(msgStr, 10, "%d", msgId);
          lefError(204, msgStr);
          return;
      }
***************
*** 307,314 ****
      lefrData::reset();
  
      lefData->versionNum = (lefSettings->VersionNum == 0.0) ?
!         CURRENT_VERSION :
!         lefData->versionNum = lefSettings->VersionNum;
  
      if (lefSettings->CaseSensitiveSet) {
          lefData->namesCaseSensitive = lefSettings->CaseSensitive;
--- 307,313 ----
      lefrData::reset();
  
      lefData->versionNum = (lefSettings->VersionNum == 0.0) ?
!         CURRENT_VERSION : lefSettings->VersionNum;
  
      if (lefSettings->CaseSensitiveSet) {
          lefData->namesCaseSensitive = lefSettings->CaseSensitive;
***************
*** 343,361 ****
      if (lefCallbacks->BusBitCharsCbk == 0)
          lefCallbacks->BusBitCharsCbk = (lefrStringCbkFnType) func;
      if (lefCallbacks->CaseSensitiveCbk == 0)
!         lefCallbacks->CaseSensitiveCbk = (lefrIntegerCbkFnType) func;
      if (lefCallbacks->NoWireExtensionCbk == 0)
          lefCallbacks->NoWireExtensionCbk = (lefrStringCbkFnType) func;
      if (lefCallbacks->CorrectionTableCbk == 0)
          lefCallbacks->CorrectionTableCbk = (lefrCorrectionTableCbkFnType) func;
      if (lefCallbacks->DielectricCbk == 0)
!         lefCallbacks->DielectricCbk = (lefrDoubleCbkFnType) func;
      if (lefCallbacks->EdgeRateScaleFactorCbk == 0)
!         lefCallbacks->EdgeRateScaleFactorCbk = (lefrDoubleCbkFnType) func;
      if (lefCallbacks->EdgeRateThreshold1Cbk == 0)
!         lefCallbacks->EdgeRateThreshold1Cbk = (lefrDoubleCbkFnType) func;
      if (lefCallbacks->EdgeRateThreshold2Cbk == 0)
!         lefCallbacks->EdgeRateThreshold2Cbk = (lefrDoubleCbkFnType) func;
      if (lefCallbacks->IRDropBeginCbk == 0)
          lefCallbacks->IRDropBeginCbk = (lefrVoidCbkFnType) func;
      if (lefCallbacks->IRDropCbk == 0)
--- 342,360 ----
      if (lefCallbacks->BusBitCharsCbk == 0)
          lefCallbacks->BusBitCharsCbk = (lefrStringCbkFnType) func;
      if (lefCallbacks->CaseSensitiveCbk == 0)
!         lefCallbacks->CaseSensitiveCbk = (lefrIntegerCbkFnType) (void*)func;
      if (lefCallbacks->NoWireExtensionCbk == 0)
          lefCallbacks->NoWireExtensionCbk = (lefrStringCbkFnType) func;
      if (lefCallbacks->CorrectionTableCbk == 0)
          lefCallbacks->CorrectionTableCbk = (lefrCorrectionTableCbkFnType) func;
      if (lefCallbacks->DielectricCbk == 0)
!         lefCallbacks->DielectricCbk = (lefrDoubleCbkFnType) (void*)func;
      if (lefCallbacks->EdgeRateScaleFactorCbk == 0)
!         lefCallbacks->EdgeRateScaleFactorCbk = (lefrDoubleCbkFnType) (void*)func;
      if (lefCallbacks->EdgeRateThreshold1Cbk == 0)
!         lefCallbacks->EdgeRateThreshold1Cbk = (lefrDoubleCbkFnType) (void*)func;
      if (lefCallbacks->EdgeRateThreshold2Cbk == 0)
!         lefCallbacks->EdgeRateThreshold2Cbk = (lefrDoubleCbkFnType) (void*)func;
      if (lefCallbacks->IRDropBeginCbk == 0)
          lefCallbacks->IRDropBeginCbk = (lefrVoidCbkFnType) func;
      if (lefCallbacks->IRDropCbk == 0)
***************
*** 373,383 ****
      if (lefCallbacks->MacroClassTypeCbk == 0)
          lefCallbacks->MacroClassTypeCbk = (lefrStringCbkFnType) func;
      if (lefCallbacks->MacroOriginCbk == 0)
!         lefCallbacks->MacroOriginCbk = (lefrMacroNumCbkFnType) func;
      if (lefCallbacks->MacroSizeCbk == 0)
!         lefCallbacks->MacroSizeCbk = (lefrMacroNumCbkFnType) func;
      if (lefCallbacks->MacroFixedMaskCbk == 0)
!         lefCallbacks->MacroFixedMaskCbk = (lefrIntegerCbkFnType) func;
      if (lefCallbacks->TimingCbk == 0)
          lefCallbacks->TimingCbk = (lefrTimingCbkFnType) func;
      if (lefCallbacks->MinFeatureCbk == 0)
--- 372,382 ----
      if (lefCallbacks->MacroClassTypeCbk == 0)
          lefCallbacks->MacroClassTypeCbk = (lefrStringCbkFnType) func;
      if (lefCallbacks->MacroOriginCbk == 0)
!         lefCallbacks->MacroOriginCbk = (lefrMacroNumCbkFnType) (void*)func;
      if (lefCallbacks->MacroSizeCbk == 0)
!         lefCallbacks->MacroSizeCbk = (lefrMacroNumCbkFnType) (void*)func;
      if (lefCallbacks->MacroFixedMaskCbk == 0)
!         lefCallbacks->MacroFixedMaskCbk = (lefrIntegerCbkFnType) (void*)func;
      if (lefCallbacks->TimingCbk == 0)
          lefCallbacks->TimingCbk = (lefrTimingCbkFnType) func;
      if (lefCallbacks->MinFeatureCbk == 0)
***************
*** 410,416 ****
          lefCallbacks->UnitsCbk = (lefrUnitsCbkFnType) func;
      if ((lefCallbacks->VersionCbk == 0) && (lefCallbacks->VersionStrCbk == 0)) {
          // both version callbacks weren't set, if either one is set, it is ok
!         lefCallbacks->VersionCbk = (lefrDoubleCbkFnType) func;
          lefCallbacks->VersionStrCbk = (lefrStringCbkFnType) func;
      }
      if (lefCallbacks->ViaCbk == 0)
--- 409,415 ----
          lefCallbacks->UnitsCbk = (lefrUnitsCbkFnType) func;
      if ((lefCallbacks->VersionCbk == 0) && (lefCallbacks->VersionStrCbk == 0)) {
          // both version callbacks weren't set, if either one is set, it is ok
!         lefCallbacks->VersionCbk = (lefrDoubleCbkFnType) (void*)func;
          lefCallbacks->VersionStrCbk = (lefrStringCbkFnType) func;
      }
      if (lefCallbacks->ViaCbk == 0)
***************
*** 418,438 ****
      if (lefCallbacks->ViaRuleCbk == 0)
          lefCallbacks->ViaRuleCbk = (lefrViaRuleCbkFnType) func;
      if (lefCallbacks->InputAntennaCbk == 0)
!         lefCallbacks->InputAntennaCbk = (lefrDoubleCbkFnType) func;
      if (lefCallbacks->OutputAntennaCbk == 0)
!         lefCallbacks->OutputAntennaCbk = (lefrDoubleCbkFnType) func;
      if (lefCallbacks->InoutAntennaCbk == 0)
!         lefCallbacks->InoutAntennaCbk = (lefrDoubleCbkFnType) func;
  
      // NEW CALLBACK - Add a line here for each new callback routine 
      if (lefCallbacks->AntennaInputCbk == 0)
!         lefCallbacks->AntennaInputCbk = (lefrDoubleCbkFnType) func;
      if (lefCallbacks->AntennaInoutCbk == 0)
!         lefCallbacks->AntennaInoutCbk = (lefrDoubleCbkFnType) func;
      if (lefCallbacks->AntennaOutputCbk == 0)
!         lefCallbacks->AntennaOutputCbk = (lefrDoubleCbkFnType) func;
      if (lefCallbacks->ManufacturingCbk == 0)
!         lefCallbacks->ManufacturingCbk = (lefrDoubleCbkFnType) func;
      if (lefCallbacks->UseMinSpacingCbk == 0)
          lefCallbacks->UseMinSpacingCbk = (lefrUseMinSpacingCbkFnType) func;
      if (lefCallbacks->ClearanceMeasureCbk == 0)
--- 417,437 ----
      if (lefCallbacks->ViaRuleCbk == 0)
          lefCallbacks->ViaRuleCbk = (lefrViaRuleCbkFnType) func;
      if (lefCallbacks->InputAntennaCbk == 0)
!         lefCallbacks->InputAntennaCbk = (lefrDoubleCbkFnType) (void*)func;
      if (lefCallbacks->OutputAntennaCbk == 0)
!         lefCallbacks->OutputAntennaCbk = (lefrDoubleCbkFnType) (void*)func;
      if (lefCallbacks->InoutAntennaCbk == 0)
!         lefCallbacks->InoutAntennaCbk = (lefrDoubleCbkFnType) (void*)func;
  
      // NEW CALLBACK - Add a line here for each new callback routine 
      if (lefCallbacks->AntennaInputCbk == 0)
!         lefCallbacks->AntennaInputCbk = (lefrDoubleCbkFnType) (void*)func;
      if (lefCallbacks->AntennaInoutCbk == 0)
!         lefCallbacks->AntennaInoutCbk = (lefrDoubleCbkFnType) (void*)func;
      if (lefCallbacks->AntennaOutputCbk == 0)
!         lefCallbacks->AntennaOutputCbk = (lefrDoubleCbkFnType) (void*)func;
      if (lefCallbacks->ManufacturingCbk == 0)
!         lefCallbacks->ManufacturingCbk = (lefrDoubleCbkFnType) (void*)func;
      if (lefCallbacks->UseMinSpacingCbk == 0)
          lefCallbacks->UseMinSpacingCbk = (lefrUseMinSpacingCbkFnType) func;
      if (lefCallbacks->ClearanceMeasureCbk == 0)
***************
*** 440,450 ****
      if (lefCallbacks->MacroClassTypeCbk == 0)
          lefCallbacks->MacroClassTypeCbk = (lefrStringCbkFnType) func;
      if (lefCallbacks->MacroOriginCbk == 0)
!         lefCallbacks->MacroOriginCbk = (lefrMacroNumCbkFnType) func;
      if (lefCallbacks->MacroSizeCbk == 0)
!         lefCallbacks->MacroSizeCbk = (lefrMacroNumCbkFnType) func;
      if (lefCallbacks->MacroFixedMaskCbk == 0)
!         lefCallbacks->MacroFixedMaskCbk = (lefrIntegerCbkFnType) func;
      if (lefCallbacks->MacroEndCbk == 0)
          lefCallbacks->MacroEndCbk = (lefrStringCbkFnType) func;
      if (lefCallbacks->MaxStackViaCbk == 0)
--- 439,449 ----
      if (lefCallbacks->MacroClassTypeCbk == 0)
          lefCallbacks->MacroClassTypeCbk = (lefrStringCbkFnType) func;
      if (lefCallbacks->MacroOriginCbk == 0)
!         lefCallbacks->MacroOriginCbk = (lefrMacroNumCbkFnType) (void*)func;
      if (lefCallbacks->MacroSizeCbk == 0)
!         lefCallbacks->MacroSizeCbk = (lefrMacroNumCbkFnType) (void*)func;
      if (lefCallbacks->MacroFixedMaskCbk == 0)
!         lefCallbacks->MacroFixedMaskCbk = (lefrIntegerCbkFnType) (void*)func;
      if (lefCallbacks->MacroEndCbk == 0)
          lefCallbacks->MacroEndCbk = (lefrStringCbkFnType) func;
      if (lefCallbacks->MaxStackViaCbk == 0)
***************
*** 454,460 ****
      if (lefCallbacks->DensityCbk == 0)
          lefCallbacks->DensityCbk = (lefrDensityCbkFnType) func;
      if (lefCallbacks->FixedMaskCbk == 0)
!         lefCallbacks->FixedMaskCbk = (lefrIntegerCbkFnType) func;
  }
  
  // These count up the number of times an unset callback is called... 
--- 453,459 ----
      if (lefCallbacks->DensityCbk == 0)
          lefCallbacks->DensityCbk = (lefrDensityCbkFnType) func;
      if (lefCallbacks->FixedMaskCbk == 0)
!         lefCallbacks->FixedMaskCbk = (lefrIntegerCbkFnType) (void*)func;
  }
  
  // These count up the number of times an unset callback is called... 
diff -r -c source.lefdef/lef.orig/lef/lefrSettings.cpp lef/lef/lefrSettings.cpp
*** source.lefdef/lef.orig/lef/lefrSettings.cpp	Fri Feb  5 14:39:14 2016
--- lef/lef/lefrSettings.cpp	Thu Dec 31 09:41:38 2020
***************
*** 38,47 ****
  lefrSettings *lefSettings = NULL;
  
  lefrSettings::lefrSettings()
! : DisPropStrProcess(0),
    CaseSensitive(FALSE),
    CaseSensitiveSet(FALSE),
-   CommentChar('#'),
    DeltaNumberLines(10000),
    AntennaInoutWarnings(999),
    AntennaInputWarnings(999),
--- 38,48 ----
  lefrSettings *lefSettings = NULL;
  
  lefrSettings::lefrSettings()
! : CommentChar('#'),
!   VersionNum(0.0),
!   DisPropStrProcess(0),
    CaseSensitive(FALSE),
    CaseSensitiveSet(FALSE),
    DeltaNumberLines(10000),
    AntennaInoutWarnings(999),
    AntennaInputWarnings(999),
***************
*** 53,67 ****
    EdgeRateScaleFactorWarnings(999),
    EdgeRateThreshold1Warnings(999),
    EdgeRateThreshold2Warnings(999),
-   ErrorLogFunction(0),
-   FreeFunction(0),
    IRDropWarnings(999),
    InoutAntennaWarnings(999),
    InputAntennaWarnings(999),
-   LayerWarnings(999),
    LineNumberFunction(0),
    MacroWarnings(999),
-   MallocFunction(0),
    MaxStackViaWarnings(999),
    MinFeatureWarnings(999),
    NoWireExtensionWarnings(999),
--- 54,65 ----
    EdgeRateScaleFactorWarnings(999),
    EdgeRateThreshold1Warnings(999),
    EdgeRateThreshold2Warnings(999),
    IRDropWarnings(999),
    InoutAntennaWarnings(999),
    InputAntennaWarnings(999),
    LineNumberFunction(0),
+   LayerWarnings(999),
    MacroWarnings(999),
    MaxStackViaWarnings(999),
    MinFeatureWarnings(999),
    NoWireExtensionWarnings(999),
***************
*** 72,78 ****
    PinWarnings(999),
    ReadFunction(0),
    ReadEncrypted(0),
-   ReallocFunction(0),
    RegisterUnused(0),
    RelaxMode(FALSE),
    ShiftCase(0),
--- 70,75 ----
***************
*** 81,93 ****
    TimingWarnings(999),
    UnitsWarnings(999),
    UseMinSpacingWarnings(999),
-   UserData(NULL),
-   VersionNum(0.0),
    ViaRuleWarnings(999),
    ViaWarnings(999),
    LogFileAppend(0),
-   SetLogFunction(0),
    TotalMsgLimit(0),
    WarningLogFunction(0),
    dAllMsgs(0)
  {
--- 78,94 ----
    TimingWarnings(999),
    UnitsWarnings(999),
    UseMinSpacingWarnings(999),
    ViaRuleWarnings(999),
    ViaWarnings(999),
    LogFileAppend(0),
    TotalMsgLimit(0),
+   UserData(NULL),
+ 
+   MallocFunction(0),
+   ReallocFunction(0),
+   FreeFunction(0),
+   ErrorLogFunction(0),
+   SetLogFunction(0),
    WarningLogFunction(0),
    dAllMsgs(0)
  {
diff -r -c source.lefdef/lef.orig/lef/lefrSettings.hpp lef/lef/lefrSettings.hpp
*** source.lefdef/lef.orig/lef/lefrSettings.hpp	Fri Feb  5 14:39:14 2016
--- lef/lef/lefrSettings.hpp	Thu Dec 31 09:41:38 2020
***************
*** 127,136 ****
      LEFI_LOG_FUNCTION SetLogFunction;
      LEFI_WARNING_LOG_FUNCTION WarningLogFunction;
  
      int MsgLimit[MAX_LEF_MSGS];
  
      MsgsDisableMap msgsDisableMap;
-     int  dAllMsgs; 
  
      lefrProps lefProps;
  };
--- 127,136 ----
      LEFI_LOG_FUNCTION SetLogFunction;
      LEFI_WARNING_LOG_FUNCTION WarningLogFunction;
  
+     int  dAllMsgs; 
      int MsgLimit[MAX_LEF_MSGS];
  
      MsgsDisableMap msgsDisableMap;
  
      lefrProps lefProps;
  };
diff -r -c source.lefdef/lef.orig/lef/lefwWriter.cpp lef/lef/lefwWriter.cpp
*** source.lefdef/lef.orig/lef/lefwWriter.cpp	Fri Feb  5 14:39:14 2016
--- lef/lef/lefwWriter.cpp	Tue Jan  4 13:05:38 2022
***************
*** 1122,1128 ****
          return LEFW_BAD_ORDER; // has to be after 
      // lefwLayerCutSpacing is called
      if (lefwWriteEncrypt) {
!         if (viaCuts < 2 && viaCuts > 4)
              return LEFW_BAD_DATA;
          encPrint(lefwFile, (char*) "\n     ADJACENTCUTS %d WITHIN %.11g",
                   viaCuts, distance);
--- 1122,1128 ----
          return LEFW_BAD_ORDER; // has to be after 
      // lefwLayerCutSpacing is called
      if (lefwWriteEncrypt) {
!         if (viaCuts < 2 || viaCuts > 4)
              return LEFW_BAD_DATA;
          encPrint(lefwFile, (char*) "\n     ADJACENTCUTS %d WITHIN %.11g",
                   viaCuts, distance);
***************
*** 1130,1136 ****
              encPrint(lefwFile, (char*) " EXCEPTSAMEPGNET");
  
      } else {
!         if (viaCuts < 2 && viaCuts > 4)
              return LEFW_BAD_DATA;
          fprintf(lefwFile, "\n     ADJACENTCUTS %d WITHIN %.11g", viaCuts,
                  distance);
--- 1130,1136 ----
              encPrint(lefwFile, (char*) " EXCEPTSAMEPGNET");
  
      } else {
!         if (viaCuts < 2 || viaCuts > 4)
              return LEFW_BAD_DATA;
          fprintf(lefwFile, "\n     ADJACENTCUTS %d WITHIN %.11g", viaCuts,
                  distance);
***************
*** 4517,4523 ****
                      int     mask)
  {
      int i;
!     int polyCount;
  
      if (!lefwFile)
          return LEFW_UNINITIALIZED;
--- 4517,4523 ----
                      int     mask)
  {
      int i;
! //    int polyCount;
  
      if (!lefwFile)
          return LEFW_UNINITIALIZED;
***************
*** 4542,4548 ****
          } else {
              encPrint(lefwFile, (char*) "      POLYGON ");
          }
!         polyCount = 0;
          for (i = 0; i < num_polys; i++) {
              if (i == 0)
                  encPrint(lefwFile, (char*) "%.11g %.11g ", *xl++, *yl++);
--- 4542,4548 ----
          } else {
              encPrint(lefwFile, (char*) "      POLYGON ");
          }
! //        polyCount = 0;
          for (i = 0; i < num_polys; i++) {
              if (i == 0)
                  encPrint(lefwFile, (char*) "%.11g %.11g ", *xl++, *yl++);
***************
*** 4562,4568 ****
          } else {
              fprintf(lefwFile, "      POLYGON ");
          }
!         polyCount = 0;
          for (i = 0; i < num_polys; i++) {
              if (i == 0)
                  fprintf(lefwFile, "%.11g %.11g", *xl++, *yl++);
--- 4562,4568 ----
          } else {
              fprintf(lefwFile, "      POLYGON ");
          }
! //        polyCount = 0;
          for (i = 0; i < num_polys; i++) {
              if (i == 0)
                  fprintf(lefwFile, "%.11g %.11g", *xl++, *yl++);
diff -r -c source.lefdef/lef.orig/lefdiff/diffLefRW.cpp lef/lefdiff/diffLefRW.cpp
*** source.lefdef/lef.orig/lefdiff/diffLefRW.cpp	Fri Feb  5 14:39:14 2016
--- lef/lefdiff/diffLefRW.cpp	Sun Jan 14 11:33:02 2024
***************
*** 470,476 ****
          for (j = 0; j < a->numSites(i); j++) {
             pattern = a->site(i, j);
             fprintf(fout,
!                "ARRAY %s FLOORPLAN %s %s %s %g %g %s DO %d BY %d STEP %g %g\n",
                 a->name(), a->floorPlanName(i), a->siteType(i, j),
                 pattern->name(), chkNum(pattern->x()), chkNum(pattern->y()),
                 lefiOrientStr(pattern->orient()), pattern->xStart(),
--- 470,476 ----
          for (j = 0; j < a->numSites(i); j++) {
             pattern = a->site(i, j);
             fprintf(fout,
!                "ARRAY %s FLOORPLAN %s %s %s %g %g %s DO %g BY %g STEP %g %g\n",
                 a->name(), a->floorPlanName(i), a->siteType(i, j),
                 pattern->name(), chkNum(pattern->x()), chkNum(pattern->y()),
                 lefiOrientStr(pattern->orient()), pattern->xStart(),
***************
*** 554,560 ****
             // victims
             for (k = 0; k < resist->numVictims(); k++) {
                victim = resist->victim(k);
!               if (victim->length() > 0)
                   fprintf(fout,
                      "CROSSTALK CORRECTIONTABLE %d RESISTANCE %g VICTIMLEN %g\n",
                           table->num(), chkNum(resist->num(j)),
--- 554,560 ----
             // victims
             for (k = 0; k < resist->numVictims(); k++) {
                victim = resist->victim(k);
!               if (victim->length() > 0) {
                   fprintf(fout,
                      "CROSSTALK CORRECTIONTABLE %d RESISTANCE %g VICTIMLEN %g\n",
                           table->num(), chkNum(resist->num(j)),
***************
*** 564,569 ****
--- 564,570 ----
                      "CROSSTALK CORRECTIONTABLE %d RESISTANCE %g VICTIM GTH %g CORRECTIONFACTOR %g\n",
                         table->num(), chkNum(resist->num(j)),
                         chkNum(victim->length()), chkNum(victim->correction(l)));
+               }
             }
          }
       }
***************
*** 1396,1402 ****
                // victims
                for (k = 0; k < resist->numVictims(); k++) {
                   victim = resist->victim(k);
!                  if (victim->length() > 0)
                      fprintf(fout, "CROSSTALK NOISETABLE %d RESISTANCE %g VICTIMLENGTH % g\n",
                              table->num(), chkNum(resist->num(j)),
                              chkNum(victim->length()));
--- 1397,1403 ----
                // victims
                for (k = 0; k < resist->numVictims(); k++) {
                   victim = resist->victim(k);
!                  if (victim->length() > 0) {
                      fprintf(fout, "CROSSTALK NOISETABLE %d RESISTANCE %g VICTIMLENGTH % g\n",
                              table->num(), chkNum(resist->num(j)),
                              chkNum(victim->length()));
***************
*** 1404,1409 ****
--- 1405,1411 ----
                         fprintf(fout, "CROSSTALK NOISETABLE %d RESISTANCE %g VICTIMLENGT %g NOISEFACTOR %g\n",
                            table->num(), chkNum(resist->num(j)),
                            chkNum(victim->length()), chkNum(victim->noise(l)));
+                  }
                }
             }
          }
***************
*** 1444,1457 ****
       fprintf(fout, "\n");
    }
  
!   sprintf(defName, "NONDEFAULTRULE %s VIA", def->name());
    // handle via in nondefaultrule
    for (i = 0; i < def->numVias(); i++) {
       via = def->viaRule(i);
       lefVia(via, defName);
    }
  
!   sprintf(defName, "NONDEFAULTRULE %s SPACING", def->name());
    // handle spacing in nondefaultrule
    for (i = 0; i < def->numSpacingRules(); i++) {
       spacing = def->spacingRule(i);
--- 1446,1459 ----
       fprintf(fout, "\n");
    }
  
!   snprintf(defName, sizeof(defName), "NONDEFAULTRULE %s VIA", def->name());
    // handle via in nondefaultrule
    for (i = 0; i < def->numVias(); i++) {
       via = def->viaRule(i);
       lefVia(via, defName);
    }
  
!   snprintf(defName, sizeof(defName), "NONDEFAULTRULE %s SPACING", def->name());
    // handle spacing in nondefaultrule
    for (i = 0; i < def->numSpacingRules(); i++) {
       spacing = def->spacingRule(i);
***************
*** 1745,1751 ****
    char pinName[1024];
  
    for (i = 0; i < numPorts; i++) {
!      sprintf(pinName, "PIN %s PORT", pin->name());
       geometry = pin->port(i);
       prtGeometry(geometry, pinName);
    }
--- 1747,1753 ----
    char pinName[1024];
  
    for (i = 0; i < numPorts; i++) {
!      snprintf(pinName, sizeof(pinName), "PIN %s PORT", pin->name());
       geometry = pin->port(i);
       prtGeometry(geometry, pinName);
    }
***************
*** 1860,1868 ****
       fprintf(fout, "TIMING FROMPIN %s\n", timing->fromPin(i));
    for (i = 0; i < timing->numToPins(); i++)
       fprintf(fout, "TIMING TOPIN %s\n", timing->toPin(i));
!      fprintf(fout, "TIMING RISE SLEW1 %g %g %g %g\n",
!              chkNum(timing->riseSlewOne()), chkNum(timing->riseSlewTwo()),
!              chkNum(timing->riseSlewThree()), chkNum(timing->riseSlewFour()));
    if (timing->hasRiseSlew2())
       fprintf(fout, "TIMING RISE SLEW2 %g %g %g\n",
               chkNum(timing->riseSlewFive()), chkNum(timing->riseSlewSix()),
--- 1862,1870 ----
       fprintf(fout, "TIMING FROMPIN %s\n", timing->fromPin(i));
    for (i = 0; i < timing->numToPins(); i++)
       fprintf(fout, "TIMING TOPIN %s\n", timing->toPin(i));
!   fprintf(fout, "TIMING RISE SLEW1 %g %g %g %g\n",
!      chkNum(timing->riseSlewOne()), chkNum(timing->riseSlewTwo()),
!      chkNum(timing->riseSlewThree()), chkNum(timing->riseSlewFour()));
    if (timing->hasRiseSlew2())
       fprintf(fout, "TIMING RISE SLEW2 %g %g %g\n",
               chkNum(timing->riseSlewFive()), chkNum(timing->riseSlewSix()),
***************
*** 1894,1900 ****
    if (timing->hasRiseRS())
       fprintf(fout, "TIMING RISERS %g %g\n",
               chkNum(timing->riseRSOne()), chkNum(timing->riseRSTwo()));
!      if (timing->hasRiseCS())
       fprintf(fout, "TIMING RISECS %g %g\n",
               chkNum(timing->riseCSOne()), chkNum(timing->riseCSTwo()));
    if (timing->hasFallRS())
--- 1896,1902 ----
    if (timing->hasRiseRS())
       fprintf(fout, "TIMING RISERS %g %g\n",
               chkNum(timing->riseRSOne()), chkNum(timing->riseRSTwo()));
!   if (timing->hasRiseCS())
       fprintf(fout, "TIMING RISECS %g %g\n",
               chkNum(timing->riseCSOne()), chkNum(timing->riseCSTwo()));
    if (timing->hasFallRS())
***************
*** 2032,2038 ****
   
  int diffLefReadFile(char* inFile, char* outFile) {
    FILE* f;
!   int   res;
   
    userData = (void*)0x01020304;
    lefrInit();
--- 2034,2040 ----
   
  int diffLefReadFile(char* inFile, char* outFile) {
    FILE* f;
!   int   res = 0;
   
    userData = (void*)0x01020304;
    lefrInit();
***************
*** 2097,2101 ****
    fclose(f);
    fclose(fout);
  
!   return 0;
  }
--- 2099,2103 ----
    fclose(f);
    fclose(fout);
  
!   return res;
  }
diff -r -c source.lefdef/lef.orig/lefdiff/differLef.cpp lef/lefdiff/differLef.cpp
*** source.lefdef/lef.orig/lefdiff/differLef.cpp	Fri Feb  5 14:39:14 2016
--- lef/lefdiff/differLef.cpp	Thu Dec 31 09:41:38 2020
***************
*** 47,55 ****
  #endif
  #ifndef WIN32
  #   include <unistd.h>
- extern char VersionIdent[];
- #else
- char* VersionIdent = "N/A";
  #endif /* not WIN32 */
  #include "lefrReader.hpp"
  #include "diffLefRW.hpp"
--- 47,52 ----
diff -r -c source.lefdef/lef.orig/lefrw/lefrw.cpp lef/lefrw/lefrw.cpp
*** source.lefdef/lef.orig/lefrw/lefrw.cpp	Fri Feb  5 14:39:14 2016
--- lef/lefrw/lefrw.cpp	Thu Dec 31 09:41:38 2020
***************
*** 27,36 ****
  // *****************************************************************************
  // *****************************************************************************
  
- #ifdef WIN32
- #pragma warning (disable : 4786)
- #endif
- 
  #include <stdio.h>
  #include <string.h>
  #include <iostream>
--- 27,32 ----
***************
*** 400,406 ****
      }
  }
  
! int antennaCB(lefrCallbackType_e c, double value, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
--- 396,402 ----
      }
  }
  
! int antennaCB(lefrCallbackType_e c, double value, lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
***************
*** 430,436 ****
    return 0;
  }
  
! int arrayBeginCB(lefrCallbackType_e c, const char* name, lefiUserData ud) {
    int  status;
  
    checkType(c);
--- 426,432 ----
    return 0;
  }
  
! int arrayBeginCB(lefrCallbackType_e c, const char* name, lefiUserData ) {
    int  status;
  
    checkType(c);
***************
*** 442,448 ****
    return 0;
  }
  
! int arrayCB(lefrCallbackType_e c, lefiArray* a, lefiUserData ud) {
    int              status, i, j, defCaps;
    lefiSitePattern* pattern;
    lefiTrackPattern* track;
--- 438,444 ----
    return 0;
  }
  
! int arrayCB(lefrCallbackType_e c, lefiArray* a, lefiUserData ) {
    int              status, i, j, defCaps;
    lefiSitePattern* pattern;
    lefiTrackPattern* track;
***************
*** 568,574 ****
    return 0;
  }
  
! int arrayEndCB(lefrCallbackType_e c, const char* name, lefiUserData ud) {
    int  status;
  
    checkType(c);
--- 564,570 ----
    return 0;
  }
  
! int arrayEndCB(lefrCallbackType_e c, const char* name, lefiUserData ) {
    int  status;
  
    checkType(c);
***************
*** 580,586 ****
    return 0;
  }
  
! int busBitCharsCB(lefrCallbackType_e c, const char* busBit, lefiUserData ud)
  {
    int status;
  
--- 576,582 ----
    return 0;
  }
  
! int busBitCharsCB(lefrCallbackType_e c, const char* busBit, lefiUserData )
  {
    int status;
  
***************
*** 593,599 ****
    return 0;
  }
  
! int caseSensCB(lefrCallbackType_e c, int caseSense, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
--- 589,595 ----
    return 0;
  }
  
! int caseSensCB(lefrCallbackType_e c, int caseSense, lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
***************
*** 604,610 ****
    return 0;
  }
  
! int fixedMaskCB(lefrCallbackType_e c, int fixedMask, lefiUserData ud) {
      checkType(c);
  
      if (fixedMask == 1) 
--- 600,606 ----
    return 0;
  }
  
! int fixedMaskCB(lefrCallbackType_e c, int fixedMask, lefiUserData ) {
      checkType(c);
  
      if (fixedMask == 1) 
***************
*** 612,618 ****
      return 0;
  }
  
! int clearanceCB(lefrCallbackType_e c, const char* name, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
--- 608,614 ----
      return 0;
  }
  
! int clearanceCB(lefrCallbackType_e c, const char* name, lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
***************
*** 620,626 ****
    return 0;
  }
  
! int dividerCB(lefrCallbackType_e c, const char* name, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
--- 616,622 ----
    return 0;
  }
  
! int dividerCB(lefrCallbackType_e c, const char* name, lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
***************
*** 628,634 ****
    return 0;
  }
  
! int noWireExtCB(lefrCallbackType_e c, const char* name, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
--- 624,630 ----
    return 0;
  }
  
! int noWireExtCB(lefrCallbackType_e c, const char* name, lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
***************
*** 636,648 ****
    return 0;
  }
  
! int noiseMarCB(lefrCallbackType_e c, lefiNoiseMargin *noise, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    return 0;
  }
  
! int edge1CB(lefrCallbackType_e c, double name, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
--- 632,644 ----
    return 0;
  }
  
! int noiseMarCB(lefrCallbackType_e c, lefiNoiseMargin *, lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    return 0;
  }
  
! int edge1CB(lefrCallbackType_e c, double name, lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
***************
*** 650,656 ****
    return 0;
  }
  
! int edge2CB(lefrCallbackType_e c, double name, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
--- 646,652 ----
    return 0;
  }
  
! int edge2CB(lefrCallbackType_e c, double name, lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
***************
*** 658,664 ****
    return 0;
  }
  
! int edgeScaleCB(lefrCallbackType_e c, double name, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
--- 654,660 ----
    return 0;
  }
  
! int edgeScaleCB(lefrCallbackType_e c, double name, lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
***************
*** 666,686 ****
    return 0;
  }
  
! int noiseTableCB(lefrCallbackType_e c, lefiNoiseTable *noise, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
    return 0;
  }
  
! int correctionCB(lefrCallbackType_e c, lefiCorrectionTable *corr, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
    return 0;
  }
  
! int dielectricCB(lefrCallbackType_e c, double dielectric, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
--- 662,682 ----
    return 0;
  }
  
! int noiseTableCB(lefrCallbackType_e c, lefiNoiseTable *, lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
    return 0;
  }
  
! int correctionCB(lefrCallbackType_e c, lefiCorrectionTable *, lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
    return 0;
  }
  
! int dielectricCB(lefrCallbackType_e c, double dielectric, lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
  
***************
*** 688,701 ****
    return 0;
  }
  
! int irdropBeginCB(lefrCallbackType_e c, void* ptr, lefiUserData ud){
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "IRDROP\n");
    return 0;
  }
  
! int irdropCB(lefrCallbackType_e c, lefiIRDrop* irdrop, lefiUserData ud) {
    int i;
    checkType(c);
    // if ((long)ud != userData) dataError();
--- 684,697 ----
    return 0;
  }
  
! int irdropBeginCB(lefrCallbackType_e c, void* , lefiUserData ){
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "IRDROP\n");
    return 0;
  }
  
! int irdropCB(lefrCallbackType_e c, lefiIRDrop* irdrop, lefiUserData ) {
    int i;
    checkType(c);
    // if ((long)ud != userData) dataError();
***************
*** 707,720 ****
    return 0;
  }
  
! int irdropEndCB(lefrCallbackType_e c, void* ptr, lefiUserData ud){
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "END IRDROP\n");
    return 0;
  }
  
! int layerCB(lefrCallbackType_e c, lefiLayer* layer, lefiUserData ud) {
    int i, j, k;
    int numPoints, propNum;
    double *widths, *current;
--- 703,716 ----
    return 0;
  }
  
! int irdropEndCB(lefrCallbackType_e c, void* , lefiUserData ){
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "END IRDROP\n");
    return 0;
  }
  
! int layerCB(lefrCallbackType_e c, lefiLayer* layer, lefiUserData ) {
    int i, j, k;
    int numPoints, propNum;
    double *widths, *current;
***************
*** 1289,1333 ****
    return 0;
  }
  
! int macroBeginCB(lefrCallbackType_e c, const char* macroName, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "MACRO %s\n",  macroName);
    return 0;
  }
  
! int macroFixedMaskCB(lefrCallbackType_e c, int fixedMask, 
!                      lefiUserData ud) {
    checkType(c);
  
    return 0;
  }
  
  int macroClassTypeCB(lefrCallbackType_e c, const char* macroClassType,
!                      lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "MACRO CLASS %s\n",  macroClassType);
    return 0;
  }
  
! int macroOriginCB(lefrCallbackType_e c, lefiNum macroNum,
!                      lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    // fprintf(fout, "  ORIGIN ( %g %g ) ;\n", macroNum.x, macroNum.y);
    return 0;
  }
  
! int macroSizeCB(lefrCallbackType_e c, lefiNum macroNum,
!                      lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    // fprintf(fout, "  SIZE %g BY %g ;\n", macroNum.x, macroNum.y);
    return 0;
  }
  
! int macroCB(lefrCallbackType_e c, lefiMacro* macro, lefiUserData ud) {
    lefiSitePattern* pattern;
    int              propNum, i, hasPrtSym = 0;
  
--- 1285,1326 ----
    return 0;
  }
  
! int macroBeginCB(lefrCallbackType_e c, const char* macroName, lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "MACRO %s\n",  macroName);
    return 0;
  }
  
! int macroFixedMaskCB(lefrCallbackType_e c, int , lefiUserData ) {
    checkType(c);
  
    return 0;
  }
  
  int macroClassTypeCB(lefrCallbackType_e c, const char* macroClassType,
!                      lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "MACRO CLASS %s\n",  macroClassType);
    return 0;
  }
  
! int macroOriginCB(lefrCallbackType_e c, lefiNum , lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    // fprintf(fout, "  ORIGIN ( %g %g ) ;\n", macroNum.x, macroNum.y);
    return 0;
  }
  
! int macroSizeCB(lefrCallbackType_e c, lefiNum , lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    // fprintf(fout, "  SIZE %g BY %g ;\n", macroNum.x, macroNum.y);
    return 0;
  }
  
! int macroCB(lefrCallbackType_e c, lefiMacro* macro, lefiUserData ) {
    lefiSitePattern* pattern;
    int              propNum, i, hasPrtSym = 0;
  
***************
*** 1442,1455 ****
    return 0;
  }
  
! int macroEndCB(lefrCallbackType_e c, const char* macroName, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "END %s\n", macroName);
    return 0;
  }
  
! int manufacturingCB(lefrCallbackType_e c, double num, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "MANUFACTURINGGRID %g ;\n", num);
--- 1435,1448 ----
    return 0;
  }
  
! int macroEndCB(lefrCallbackType_e c, const char* macroName, lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "END %s\n", macroName);
    return 0;
  }
  
! int manufacturingCB(lefrCallbackType_e c, double num, lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "MANUFACTURINGGRID %g ;\n", num);
***************
*** 1457,1463 ****
  }
  
  int maxStackViaCB(lefrCallbackType_e c, lefiMaxStackVia* maxStack,
!   lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "MAXVIASTACK %d ", maxStack->lefiMaxStackVia::maxStackVia());
--- 1450,1456 ----
  }
  
  int maxStackViaCB(lefrCallbackType_e c, lefiMaxStackVia* maxStack,
!   lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "MAXVIASTACK %d ", maxStack->lefiMaxStackVia::maxStackVia());
***************
*** 1469,1475 ****
    return 0;
  }
  
! int minFeatureCB(lefrCallbackType_e c, lefiMinFeature* min, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "MINFEATURE %g %g ;\n", min->lefiMinFeature::one(),
--- 1462,1468 ----
    return 0;
  }
  
! int minFeatureCB(lefrCallbackType_e c, lefiMinFeature* min, lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "MINFEATURE %g %g ;\n", min->lefiMinFeature::one(),
***************
*** 1477,1483 ****
    return 0;
  }
  
! int nonDefaultCB(lefrCallbackType_e c, lefiNonDefault* def, lefiUserData ud) {
    int          i;
    lefiVia*     via;
    lefiSpacing* spacing;
--- 1470,1476 ----
    return 0;
  }
  
! int nonDefaultCB(lefrCallbackType_e c, lefiNonDefault* def, lefiUserData ) {
    int          i;
    lefiVia*     via;
    lefiSpacing* spacing;
***************
*** 1569,1575 ****
  }
  
  int obstructionCB(lefrCallbackType_e c, lefiObstruction* obs,
!                   lefiUserData ud) {
    lefiGeometries* geometry;
  
    checkType(c);
--- 1562,1568 ----
  }
  
  int obstructionCB(lefrCallbackType_e c, lefiObstruction* obs,
!                   lefiUserData ) {
    lefiGeometries* geometry;
  
    checkType(c);
***************
*** 1581,1587 ****
    return 0;
  }
  
! int pinCB(lefrCallbackType_e c, lefiPin* pin, lefiUserData ud) {
    int                  numPorts, i, j;
    lefiGeometries*      geometry;
    lefiPinAntennaModel* aModel;
--- 1574,1580 ----
    return 0;
  }
  
! int pinCB(lefrCallbackType_e c, lefiPin* pin, lefiUserData ) {
    int                  numPorts, i, j;
    lefiGeometries*      geometry;
    lefiPinAntennaModel* aModel;
***************
*** 1839,1845 ****
  }
  
  int densityCB(lefrCallbackType_e c, lefiDensity* density,
!                   lefiUserData ud) {
  
    struct lefiGeomRect rect;
  
--- 1832,1838 ----
  }
  
  int densityCB(lefrCallbackType_e c, lefiDensity* density,
!                   lefiUserData ) {
  
    struct lefiGeomRect rect;
  
***************
*** 1859,1865 ****
    return 0;
  }
  
! int propDefBeginCB(lefrCallbackType_e c, void* ptr, lefiUserData ud) {
  
    checkType(c);
    // if ((long)ud != userData) dataError();
--- 1852,1858 ----
    return 0;
  }
  
! int propDefBeginCB(lefrCallbackType_e c, void* , lefiUserData ) {
  
    checkType(c);
    // if ((long)ud != userData) dataError();
***************
*** 1867,1873 ****
    return 0;
  }
  
! int propDefCB(lefrCallbackType_e c, lefiProp* prop, lefiUserData ud) {
  
    checkType(c);
    // if ((long)ud != userData) dataError();
--- 1860,1866 ----
    return 0;
  }
  
! int propDefCB(lefrCallbackType_e c, lefiProp* prop, lefiUserData ) {
  
    checkType(c);
    // if ((long)ud != userData) dataError();
***************
*** 1895,1901 ****
    return 0;
  }
  
! int propDefEndCB(lefrCallbackType_e c, void* ptr, lefiUserData ud) {
  
    checkType(c);
    // if ((long)ud != userData) dataError();
--- 1888,1894 ----
    return 0;
  }
  
! int propDefEndCB(lefrCallbackType_e c, void* , lefiUserData ) {
  
    checkType(c);
    // if ((long)ud != userData) dataError();
***************
*** 1903,1909 ****
    return 0;
  }
  
! int siteCB(lefrCallbackType_e c, lefiSite* site, lefiUserData ud) {
    int hasPrtSym = 0;
    int i;
  
--- 1896,1902 ----
    return 0;
  }
  
! int siteCB(lefrCallbackType_e c, lefiSite* site, lefiUserData ) {
    int hasPrtSym = 0;
    int i;
  
***************
*** 1950,1977 ****
    return 0;
  }
  
! int spacingBeginCB(lefrCallbackType_e c, void* ptr, lefiUserData ud){
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "SPACING\n");
    return 0;
  }
  
! int spacingCB(lefrCallbackType_e c, lefiSpacing* spacing, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    lefSpacing(spacing);
    return 0;
  }
  
! int spacingEndCB(lefrCallbackType_e c, void* ptr, lefiUserData ud){
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "END SPACING\n");
    return 0;
  }
  
! int timingCB(lefrCallbackType_e c, lefiTiming* timing, lefiUserData ud) {
    int i;
    checkType(c);
    // if ((long)ud != userData) dataError();
--- 1943,1970 ----
    return 0;
  }
  
! int spacingBeginCB(lefrCallbackType_e c, void* , lefiUserData ){
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "SPACING\n");
    return 0;
  }
  
! int spacingCB(lefrCallbackType_e c, lefiSpacing* spacing, lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    lefSpacing(spacing);
    return 0;
  }
  
! int spacingEndCB(lefrCallbackType_e c, void* , lefiUserData ){
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "END SPACING\n");
    return 0;
  }
  
! int timingCB(lefrCallbackType_e c, lefiTiming* timing, lefiUserData ) {
    int i;
    checkType(c);
    // if ((long)ud != userData) dataError();
***************
*** 1980,1988 ****
       fprintf(fout, " FROMPIN %s ;\n", timing->fromPin(i));
    for (i = 0; i < timing->numToPins(); i++)
       fprintf(fout, " TOPIN %s ;\n", timing->toPin(i));
!      fprintf(fout, " RISE SLEW1 %g %g %g %g ;\n", timing->riseSlewOne(),
!              timing->riseSlewTwo(), timing->riseSlewThree(),
!              timing->riseSlewFour());
    if (timing->hasRiseSlew2())
       fprintf(fout, " RISE SLEW2 %g %g %g ;\n", timing->riseSlewFive(),
               timing->riseSlewSix(), timing->riseSlewSeven());
--- 1973,1980 ----
       fprintf(fout, " FROMPIN %s ;\n", timing->fromPin(i));
    for (i = 0; i < timing->numToPins(); i++)
       fprintf(fout, " TOPIN %s ;\n", timing->toPin(i));
!   fprintf(fout, " RISE SLEW1 %g %g %g %g ;\n", timing->riseSlewOne(),
!      timing->riseSlewTwo(), timing->riseSlewThree(), timing->riseSlewFour());
    if (timing->hasRiseSlew2())
       fprintf(fout, " RISE SLEW2 %g %g %g ;\n", timing->riseSlewFive(),
               timing->riseSlewSix(), timing->riseSlewSeven());
***************
*** 2008,2014 ****
    if (timing->hasRiseRS())
       fprintf(fout, "TIMING RISERS %g %g ;\n",
               timing->riseRSOne(), timing->riseRSTwo());
!      if (timing->hasRiseCS())
       fprintf(fout, "TIMING RISECS %g %g ;\n",
               timing->riseCSOne(), timing->riseCSTwo());
    if (timing->hasFallRS())
--- 2000,2006 ----
    if (timing->hasRiseRS())
       fprintf(fout, "TIMING RISERS %g %g ;\n",
               timing->riseRSOne(), timing->riseRSTwo());
!   if (timing->hasRiseCS())
       fprintf(fout, "TIMING RISECS %g %g ;\n",
               timing->riseCSOne(), timing->riseCSTwo());
    if (timing->hasFallRS())
***************
*** 2044,2050 ****
    return 0;
  }
  
! int unitsCB(lefrCallbackType_e c, lefiUnits* unit, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "UNITS\n");
--- 2036,2042 ----
    return 0;
  }
  
! int unitsCB(lefrCallbackType_e c, lefiUnits* unit, lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "UNITS\n");
***************
*** 2070,2076 ****
  }
  
  int useMinSpacingCB(lefrCallbackType_e c, lefiUseMinSpacing* spacing,
!                     lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "USEMINSPACING %s ", spacing->lefiUseMinSpacing::name());
--- 2062,2068 ----
  }
  
  int useMinSpacingCB(lefrCallbackType_e c, lefiUseMinSpacing* spacing,
!                     lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "USEMINSPACING %s ", spacing->lefiUseMinSpacing::name());
***************
*** 2081,2108 ****
    return 0;
  }
  
! int versionCB(lefrCallbackType_e c, double num, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "VERSION %g ;\n", num);
    return 0;
  }
  
! int versionStrCB(lefrCallbackType_e c, const char* versionName, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "VERSION %s ;\n", versionName);
    return 0;
  }
  
! int viaCB(lefrCallbackType_e c, lefiVia* via, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    lefVia(via);
    return 0;
  }
  
! int viaRuleCB(lefrCallbackType_e c, lefiViaRule* viaRule, lefiUserData ud) {
    int               numLayers, numVias, i;
    lefiViaRuleLayer* vLayer;
  
--- 2073,2100 ----
    return 0;
  }
  
! int versionCB(lefrCallbackType_e c, double num, lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "VERSION %g ;\n", num);
    return 0;
  }
  
! int versionStrCB(lefrCallbackType_e c, const char* versionName, lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "VERSION %s ;\n", versionName);
    return 0;
  }
  
! int viaCB(lefrCallbackType_e c, lefiVia* via, lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    lefVia(via);
    return 0;
  }
  
! int viaRuleCB(lefrCallbackType_e c, lefiViaRule* viaRule, lefiUserData ) {
    int               numLayers, numVias, i;
    lefiViaRuleLayer* vLayer;
  
***************
*** 2158,2164 ****
    return 0;
  }
  
! int extensionCB(lefrCallbackType_e c, const char* extsn, lefiUserData ud) {
    checkType(c);
    // lefrSetCaseSensitivity(0);
    // if ((long)ud != userData) dataError();
--- 2150,2156 ----
    return 0;
  }
  
! int extensionCB(lefrCallbackType_e c, const char* extsn, lefiUserData ) {
    checkType(c);
    // lefrSetCaseSensitivity(0);
    // if ((long)ud != userData) dataError();
***************
*** 2167,2173 ****
    return 0;
  }
  
! int doneCB(lefrCallbackType_e c, void* ptr, lefiUserData ud) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "END LIBRARY\n");
--- 2159,2165 ----
    return 0;
  }
  
! int doneCB(lefrCallbackType_e c, void* , lefiUserData ) {
    checkType(c);
    // if ((long)ud != userData) dataError();
    fprintf(fout, "END LIBRARY\n");
***************
*** 2175,2185 ****
  }
   
  void errorCB(const char* msg) {
!   printf ("%s : %s\n", lefrGetUserData(), msg);
  }
  
  void warningCB(const char* msg) {
!   printf ("%s : %s\n", lefrGetUserData(), msg);
  }
  
  void* mallocCB(int size) {
--- 2167,2177 ----
  }
   
  void errorCB(const char* msg) {
!   printf ("%s : %s\n", (const char*)lefrGetUserData(), msg);
  }
  
  void warningCB(const char* msg) {
!   printf ("%s : %s\n", (const char*)lefrGetUserData(), msg);
  }
  
  void* mallocCB(int size) {
***************
*** 2228,2234 ****
    int test1 = 0;
    int test2 = 0;
    int ccr749853 = 0;
!   int verbose = 0;
  
  // start_mem = (long)sbrk(0);
  
--- 2220,2226 ----
    int test1 = 0;
    int test2 = 0;
    int ccr749853 = 0;
! //  int verbose = 0;
  
  // start_mem = (long)sbrk(0);
  
***************
*** 2462,2468 ****
        res = lefrRead(f, inFile[fileCt], (void*)userData);
  
        if (res)
!          fprintf(stderr, "Reader returns bad status.\n", inFile[fileCt]);
  
        (void)lefrPrintUnusedCallbacks(fout);
        (void)lefrReleaseNResetMemory();
--- 2454,2460 ----
        res = lefrRead(f, inFile[fileCt], (void*)userData);
  
        if (res)
!          fprintf(stderr, "Reader returns bad status.\n");
  
        (void)lefrPrintUnusedCallbacks(fout);
        (void)lefrReleaseNResetMemory();
***************
*** 2481,2487 ****
      // 2nd will enable 2007 by calling lefrEnableParserMsgs
      // 3rd enable all msgs by call lefrEnableAllMsgs
  
!     int nMsgs = 3;
      int dMsgs[3];
      if (numInFile != 1) {
          fprintf(stderr,"Test 2 mode needs only 1 file\n");
--- 2473,2479 ----
      // 2nd will enable 2007 by calling lefrEnableParserMsgs
      // 3rd enable all msgs by call lefrEnableAllMsgs
  
! //    int nMsgs = 3;
      int dMsgs[3];
      if (numInFile != 1) {
          fprintf(stderr,"Test 2 mode needs only 1 file\n");
***************
*** 2525,2531 ****
        res = lefrRead(f, inFile[fileCt], (void*)userData);
  
        if (res)
!          fprintf(stderr, "Reader returns bad status.\n", inFile[fileCt]);
  
        (void)lefrPrintUnusedCallbacks(fout);
        (void)lefrReleaseNResetMemory();
--- 2517,2523 ----
        res = lefrRead(f, inFile[fileCt], (void*)userData);
  
        if (res)
!          fprintf(stderr, "Reader returns bad status.\n");
  
        (void)lefrPrintUnusedCallbacks(fout);
        (void)lefrReleaseNResetMemory();
***************
*** 2554,2560 ****
        res = lefrRead(f, inFile[fileCt], (void*)userData);
  
        if (res)
!          fprintf(stderr, "Reader returns bad status.\n", inFile[fileCt]);
  
        (void)lefrPrintUnusedCallbacks(fout);
        (void)lefrReleaseNResetMemory();
--- 2546,2552 ----
        res = lefrRead(f, inFile[fileCt], (void*)userData);
  
        if (res)
!          fprintf(stderr, "Reader returns bad status.\n");
  
        (void)lefrPrintUnusedCallbacks(fout);
        (void)lefrReleaseNResetMemory();
diff -r -c source.lefdef/lef.orig/template.mk lef/template.mk
*** source.lefdef/lef.orig/template.mk	Fri Feb  5 14:39:13 2016
--- lef/template.mk	Thu Dec 31 09:41:38 2020
***************
*** 23,28 ****
--- 23,38 ----
      ARCH=lnx86 
      CXX=g++
      CC=gcc
+ # S. Whiteley, add some optimization and set PIC.
+     CXXFLAGS = -O -fPIC
+ endif
+ 
+ # S. Whiteley, add OS X (Darwin) support.
+ ifeq ($(OS_TYPE),Darwin)
+     ARCH=darwin 
+     CXX=g++
+     CC=gcc
+     CXXFLAGS = -O
  endif
  
  .SUFFIXES: $(SUFFIXES) .cpp
