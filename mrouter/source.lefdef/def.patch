diff -r -c source.lefdef/def.orig/cdef/defiGroup.h def/cdef/defiGroup.h
*** source.lefdef/def.orig/cdef/defiGroup.h	2016-02-05 14:39:14.000000000 -0800
--- def/cdef/defiGroup.h	2020-12-30 16:46:37.000000000 -0800
***************
*** 55,61 ****
  EXTERN const char* defiGroup_propName (const defiGroup* obj, int  index);
  EXTERN const char* defiGroup_propValue (const defiGroup* obj, int  index);
  EXTERN double defiGroup_propNumber (const defiGroup* obj, int  index);
! EXTERN const char defiGroup_propType (const defiGroup* obj, int  index);
  EXTERN int defiGroup_propIsNumber (const defiGroup* obj, int  index);
  EXTERN int defiGroup_propIsString (const defiGroup* obj, int  index);
  
--- 55,61 ----
  EXTERN const char* defiGroup_propName (const defiGroup* obj, int  index);
  EXTERN const char* defiGroup_propValue (const defiGroup* obj, int  index);
  EXTERN double defiGroup_propNumber (const defiGroup* obj, int  index);
! EXTERN char defiGroup_propType (const defiGroup* obj, int  index);
  EXTERN int defiGroup_propIsNumber (const defiGroup* obj, int  index);
  EXTERN int defiGroup_propIsString (const defiGroup* obj, int  index);
  
diff -r -c source.lefdef/def.orig/cdef/defiNet.h def/cdef/defiNet.h
*** source.lefdef/def.orig/cdef/defiNet.h	2016-02-05 14:39:14.000000000 -0800
--- def/cdef/defiNet.h	2020-12-30 16:46:37.000000000 -0800
***************
*** 124,130 ****
  EXTERN const char* defiNet_propName (const defiNet* obj, int  index);
  EXTERN const char* defiNet_propValue (const defiNet* obj, int  index);
  EXTERN double defiNet_propNumber (const defiNet* obj, int  index);
! EXTERN const char defiNet_propType (const defiNet* obj, int  index);
  EXTERN int defiNet_propIsNumber (const defiNet* obj, int  index);
  EXTERN int defiNet_propIsString (const defiNet* obj, int  index);
  EXTERN int defiNet_numConnections (const defiNet* obj);
--- 124,130 ----
  EXTERN const char* defiNet_propName (const defiNet* obj, int  index);
  EXTERN const char* defiNet_propValue (const defiNet* obj, int  index);
  EXTERN double defiNet_propNumber (const defiNet* obj, int  index);
! EXTERN char defiNet_propType (const defiNet* obj, int  index);
  EXTERN int defiNet_propIsNumber (const defiNet* obj, int  index);
  EXTERN int defiNet_propIsString (const defiNet* obj, int  index);
  EXTERN int defiNet_numConnections (const defiNet* obj);
***************
*** 223,233 ****
  EXTERN int defiNet_numViaSpecs (const defiNet* obj);
  EXTERN struct defiPoints defiNet_getViaPts (const defiNet* obj, int  index);
  EXTERN const char* defiNet_viaName (const defiNet* obj, int  index);
! EXTERN const int defiNet_viaOrient (const defiNet* obj, int  index);
  EXTERN const char* defiNet_viaOrientStr (const defiNet* obj, int  index);
! EXTERN const int defiNet_topMaskNum (const defiNet* obj, int  index);
! EXTERN const int defiNet_cutMaskNum (const defiNet* obj, int  index);
! EXTERN const int defiNet_bottomMaskNum (const defiNet* obj, int  index);
  EXTERN const char* defiNet_viaRouteStatus (const defiNet* obj, int  index);
  EXTERN const char* defiNet_viaRouteStatusShieldName (const defiNet* obj, int  index);
  EXTERN const char* defiNet_viaShapeType (const defiNet* obj, int  index);
--- 223,233 ----
  EXTERN int defiNet_numViaSpecs (const defiNet* obj);
  EXTERN struct defiPoints defiNet_getViaPts (const defiNet* obj, int  index);
  EXTERN const char* defiNet_viaName (const defiNet* obj, int  index);
! EXTERN int defiNet_viaOrient (const defiNet* obj, int  index);
  EXTERN const char* defiNet_viaOrientStr (const defiNet* obj, int  index);
! EXTERN int defiNet_topMaskNum (const defiNet* obj, int  index);
! EXTERN int defiNet_cutMaskNum (const defiNet* obj, int  index);
! EXTERN int defiNet_bottomMaskNum (const defiNet* obj, int  index);
  EXTERN const char* defiNet_viaRouteStatus (const defiNet* obj, int  index);
  EXTERN const char* defiNet_viaRouteStatusShieldName (const defiNet* obj, int  index);
  EXTERN const char* defiNet_viaShapeType (const defiNet* obj, int  index);
diff -r -c source.lefdef/def.orig/cdef/defiNonDefault.h def/cdef/defiNonDefault.h
*** source.lefdef/def.orig/cdef/defiNonDefault.h	2016-02-05 14:39:14.000000000 -0800
--- def/cdef/defiNonDefault.h	2020-12-30 16:46:37.000000000 -0800
***************
*** 44,50 ****
  EXTERN const char* defiNonDefault_propName (const defiNonDefault* obj, int  index);
  EXTERN const char* defiNonDefault_propValue (const defiNonDefault* obj, int  index);
  EXTERN double defiNonDefault_propNumber (const defiNonDefault* obj, int  index);
! EXTERN const char defiNonDefault_propType (const defiNonDefault* obj, int  index);
  EXTERN int defiNonDefault_propIsNumber (const defiNonDefault* obj, int  index);
  EXTERN int defiNonDefault_propIsString (const defiNonDefault* obj, int  index);
  
--- 44,50 ----
  EXTERN const char* defiNonDefault_propName (const defiNonDefault* obj, int  index);
  EXTERN const char* defiNonDefault_propValue (const defiNonDefault* obj, int  index);
  EXTERN double defiNonDefault_propNumber (const defiNonDefault* obj, int  index);
! EXTERN char defiNonDefault_propType (const defiNonDefault* obj, int  index);
  EXTERN int defiNonDefault_propIsNumber (const defiNonDefault* obj, int  index);
  EXTERN int defiNonDefault_propIsString (const defiNonDefault* obj, int  index);
  
diff -r -c source.lefdef/def.orig/cdef/defiPinProp.h def/cdef/defiPinProp.h
*** source.lefdef/def.orig/cdef/defiPinProp.h	2016-02-05 14:39:14.000000000 -0800
--- def/cdef/defiPinProp.h	2020-12-30 16:46:37.000000000 -0800
***************
*** 45,51 ****
  EXTERN const char* defiPinProp_propName (const defiPinProp* obj, int  index);
  EXTERN const char* defiPinProp_propValue (const defiPinProp* obj, int  index);
  EXTERN double defiPinProp_propNumber (const defiPinProp* obj, int  index);
! EXTERN const char defiPinProp_propType (const defiPinProp* obj, int  index);
  EXTERN int defiPinProp_propIsNumber (const defiPinProp* obj, int  index);
  EXTERN int defiPinProp_propIsString (const defiPinProp* obj, int  index);
  
--- 45,51 ----
  EXTERN const char* defiPinProp_propName (const defiPinProp* obj, int  index);
  EXTERN const char* defiPinProp_propValue (const defiPinProp* obj, int  index);
  EXTERN double defiPinProp_propNumber (const defiPinProp* obj, int  index);
! EXTERN char defiPinProp_propType (const defiPinProp* obj, int  index);
  EXTERN int defiPinProp_propIsNumber (const defiPinProp* obj, int  index);
  EXTERN int defiPinProp_propIsString (const defiPinProp* obj, int  index);
  
diff -r -c source.lefdef/def.orig/cdef/defiPropType.h def/cdef/defiPropType.h
*** source.lefdef/def.orig/cdef/defiPropType.h	2016-02-05 14:39:14.000000000 -0800
--- def/cdef/defiPropType.h	2020-12-30 16:46:37.000000000 -0800
***************
*** 40,45 ****
  /* Struct holds the data type for one property, if the property is            */
  /* either REAL or INTEGER.                                                    */
  
! EXTERN const char defiPropType_propType (const defiPropType* obj, char*  name);
  
  #endif
--- 40,45 ----
  /* Struct holds the data type for one property, if the property is            */
  /* either REAL or INTEGER.                                                    */
  
! EXTERN char defiPropType_propType (const defiPropType* obj, char*  name);
  
  #endif
diff -r -c source.lefdef/def.orig/cdef/defiRegion.h def/cdef/defiRegion.h
*** source.lefdef/def.orig/cdef/defiRegion.h	2016-02-05 14:39:14.000000000 -0800
--- def/cdef/defiRegion.h	2020-12-30 16:46:37.000000000 -0800
***************
*** 45,51 ****
  EXTERN const char* defiRegion_propName (const defiRegion* obj, int  index);
  EXTERN const char* defiRegion_propValue (const defiRegion* obj, int  index);
  EXTERN double defiRegion_propNumber (const defiRegion* obj, int  index);
! EXTERN const char defiRegion_propType (const defiRegion* obj, int  index);
  EXTERN int defiRegion_propIsNumber (const defiRegion* obj, int  index);
  EXTERN int defiRegion_propIsString (const defiRegion* obj, int  index);
  
--- 45,51 ----
  EXTERN const char* defiRegion_propName (const defiRegion* obj, int  index);
  EXTERN const char* defiRegion_propValue (const defiRegion* obj, int  index);
  EXTERN double defiRegion_propNumber (const defiRegion* obj, int  index);
! EXTERN char defiRegion_propType (const defiRegion* obj, int  index);
  EXTERN int defiRegion_propIsNumber (const defiRegion* obj, int  index);
  EXTERN int defiRegion_propIsString (const defiRegion* obj, int  index);
  
diff -r -c source.lefdef/def.orig/cdef/defiRowTrack.h def/cdef/defiRowTrack.h
*** source.lefdef/def.orig/cdef/defiRowTrack.h	2016-02-05 14:39:14.000000000 -0800
--- def/cdef/defiRowTrack.h	2020-12-30 16:46:37.000000000 -0800
***************
*** 54,60 ****
  EXTERN const char* defiRow_propName (const defiRow* obj, int  index);
  EXTERN const char* defiRow_propValue (const defiRow* obj, int  index);
  EXTERN double defiRow_propNumber (const defiRow* obj, int  index);
! EXTERN const char defiRow_propType (const defiRow* obj, int  index);
  EXTERN int defiRow_propIsNumber (const defiRow* obj, int  index);
  EXTERN int defiRow_propIsString (const defiRow* obj, int  index);
  
--- 54,60 ----
  EXTERN const char* defiRow_propName (const defiRow* obj, int  index);
  EXTERN const char* defiRow_propValue (const defiRow* obj, int  index);
  EXTERN double defiRow_propNumber (const defiRow* obj, int  index);
! EXTERN char defiRow_propType (const defiRow* obj, int  index);
  EXTERN int defiRow_propIsNumber (const defiRow* obj, int  index);
  EXTERN int defiRow_propIsString (const defiRow* obj, int  index);
  
diff -r -c source.lefdef/def.orig/cdef/xdefiGroup.cpp def/cdef/xdefiGroup.cpp
*** source.lefdef/def.orig/cdef/xdefiGroup.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/cdef/xdefiGroup.cpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 97,103 ****
      return ((LefDefParser::defiGroup*)obj)->propNumber(index);
  }
  
! const char defiGroup_propType (const ::defiGroup* obj, int  index) {
      return ((const LefDefParser::defiGroup*)obj)->propType(index);
  }
  
--- 97,103 ----
      return ((LefDefParser::defiGroup*)obj)->propNumber(index);
  }
  
! char defiGroup_propType (const ::defiGroup* obj, int  index) {
      return ((const LefDefParser::defiGroup*)obj)->propType(index);
  }
  
diff -r -c source.lefdef/def.orig/cdef/xdefiNet.cpp def/cdef/xdefiNet.cpp
*** source.lefdef/def.orig/cdef/xdefiNet.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/cdef/xdefiNet.cpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 197,203 ****
      return ((LefDefParser::defiNet*)obj)->propNumber(index);
  }
  
! const char defiNet_propType (const ::defiNet* obj, int  index) {
      return ((const LefDefParser::defiNet*)obj)->propType(index);
  }
  
--- 197,203 ----
      return ((LefDefParser::defiNet*)obj)->propNumber(index);
  }
  
! char defiNet_propType (const ::defiNet* obj, int  index) {
      return ((const LefDefParser::defiNet*)obj)->propType(index);
  }
  
***************
*** 501,507 ****
      return ((const LefDefParser::defiNet*)obj)->viaName(index);
  }
  
! const int defiNet_viaOrient (const ::defiNet* obj, int  index) {
      return ((const LefDefParser::defiNet*)obj)->viaOrient(index);
  }
  
--- 501,507 ----
      return ((const LefDefParser::defiNet*)obj)->viaName(index);
  }
  
! int defiNet_viaOrient (const ::defiNet* obj, int  index) {
      return ((const LefDefParser::defiNet*)obj)->viaOrient(index);
  }
  
***************
*** 509,523 ****
      return ((const LefDefParser::defiNet*)obj)->viaOrientStr(index);
  }
  
! const int defiNet_topMaskNum (const ::defiNet* obj, int  index) {
      return ((const LefDefParser::defiNet*)obj)->topMaskNum(index);
  }
  
! const int defiNet_cutMaskNum (const ::defiNet* obj, int  index) {
      return ((const LefDefParser::defiNet*)obj)->cutMaskNum(index);
  }
  
! const int defiNet_bottomMaskNum (const ::defiNet* obj, int  index) {
      return ((const LefDefParser::defiNet*)obj)->bottomMaskNum(index);
  }
  
--- 509,523 ----
      return ((const LefDefParser::defiNet*)obj)->viaOrientStr(index);
  }
  
! int defiNet_topMaskNum (const ::defiNet* obj, int  index) {
      return ((const LefDefParser::defiNet*)obj)->topMaskNum(index);
  }
  
! int defiNet_cutMaskNum (const ::defiNet* obj, int  index) {
      return ((const LefDefParser::defiNet*)obj)->cutMaskNum(index);
  }
  
! int defiNet_bottomMaskNum (const ::defiNet* obj, int  index) {
      return ((const LefDefParser::defiNet*)obj)->bottomMaskNum(index);
  }
  
diff -r -c source.lefdef/def.orig/cdef/xdefiNonDefault.cpp def/cdef/xdefiNonDefault.cpp
*** source.lefdef/def.orig/cdef/xdefiNonDefault.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/cdef/xdefiNonDefault.cpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 61,67 ****
      return ((LefDefParser::defiNonDefault*)obj)->propNumber(index);
  }
  
! const char defiNonDefault_propType (const ::defiNonDefault* obj, int  index) {
      return ((const LefDefParser::defiNonDefault*)obj)->propType(index);
  }
  
--- 61,67 ----
      return ((LefDefParser::defiNonDefault*)obj)->propNumber(index);
  }
  
! char defiNonDefault_propType (const ::defiNonDefault* obj, int  index) {
      return ((const LefDefParser::defiNonDefault*)obj)->propType(index);
  }
  
diff -r -c source.lefdef/def.orig/cdef/xdefiPinProp.cpp def/cdef/xdefiPinProp.cpp
*** source.lefdef/def.orig/cdef/xdefiPinProp.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/cdef/xdefiPinProp.cpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 65,71 ****
      return ((LefDefParser::defiPinProp*)obj)->propNumber(index);
  }
  
! const char defiPinProp_propType (const ::defiPinProp* obj, int  index) {
      return ((const LefDefParser::defiPinProp*)obj)->propType(index);
  }
  
--- 65,71 ----
      return ((LefDefParser::defiPinProp*)obj)->propNumber(index);
  }
  
! char defiPinProp_propType (const ::defiPinProp* obj, int  index) {
      return ((const LefDefParser::defiPinProp*)obj)->propType(index);
  }
  
diff -r -c source.lefdef/def.orig/cdef/xdefiPropType.cpp def/cdef/xdefiPropType.cpp
*** source.lefdef/def.orig/cdef/xdefiPropType.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/cdef/xdefiPropType.cpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 37,43 ****
  #include "defiPropType.hpp"
  
  // Wrappers definitions.
! const char defiPropType_propType (const ::defiPropType* obj, char*  name) {
      return ((const LefDefParser::defiPropType*)obj)->propType(name);
  }
  
--- 37,43 ----
  #include "defiPropType.hpp"
  
  // Wrappers definitions.
! char defiPropType_propType (const ::defiPropType* obj, char*  name) {
      return ((const LefDefParser::defiPropType*)obj)->propType(name);
  }
  
diff -r -c source.lefdef/def.orig/cdef/xdefiRegion.cpp def/cdef/xdefiRegion.cpp
*** source.lefdef/def.orig/cdef/xdefiRegion.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/cdef/xdefiRegion.cpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 57,63 ****
      return ((LefDefParser::defiRegion*)obj)->propNumber(index);
  }
  
! const char defiRegion_propType (const ::defiRegion* obj, int  index) {
      return ((const LefDefParser::defiRegion*)obj)->propType(index);
  }
  
--- 57,63 ----
      return ((LefDefParser::defiRegion*)obj)->propNumber(index);
  }
  
! char defiRegion_propType (const ::defiRegion* obj, int  index) {
      return ((const LefDefParser::defiRegion*)obj)->propType(index);
  }
  
diff -r -c source.lefdef/def.orig/cdef/xdefiRowTrack.cpp def/cdef/xdefiRowTrack.cpp
*** source.lefdef/def.orig/cdef/xdefiRowTrack.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/cdef/xdefiRowTrack.cpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 101,107 ****
      return ((LefDefParser::defiRow*)obj)->propNumber(index);
  }
  
! const char defiRow_propType (const ::defiRow* obj, int  index) {
      return ((const LefDefParser::defiRow*)obj)->propType(index);
  }
  
--- 101,107 ----
      return ((LefDefParser::defiRow*)obj)->propNumber(index);
  }
  
! char defiRow_propType (const ::defiRow* obj, int  index) {
      return ((const LefDefParser::defiRow*)obj)->propType(index);
  }
  
diff -r -c source.lefdef/def.orig/def/defiAlias.cpp def/def/defiAlias.cpp
*** source.lefdef/def.orig/def/defiAlias.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defiAlias.cpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 38,45 ****
  }; 
  
  defiAlias_itr::defiAlias_itr() 
! : first(1),
!   iterator(NULL)
  {
      defiAlias_itr::Init();
  }
--- 38,45 ----
  }; 
  
  defiAlias_itr::defiAlias_itr() 
! : iterator(NULL),
!     first(1)
  {
      defiAlias_itr::Init();
  }
diff -r -c source.lefdef/def.orig/def/defiDebug.cpp def/def/defiDebug.cpp
*** source.lefdef/def.orig/def/defiDebug.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defiDebug.cpp	2022-01-04 13:20:09.000000000 -0800
***************
*** 83,89 ****
    if (defSettings->ErrorLogFunction) {
      (*defSettings->ErrorLogFunction)(mess);
    } else {
!     fprintf(stderr, mess);
    }
  }
  
--- 83,89 ----
    if (defSettings->ErrorLogFunction) {
      (*defSettings->ErrorLogFunction)(mess);
    } else {
!     fprintf(stderr, "%s", mess);
    }
  }
  
diff -r -c source.lefdef/def.orig/def/defiGroup.cpp def/def/defiGroup.cpp
*** source.lefdef/def.orig/def/defiGroup.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defiGroup.cpp	2024-01-14 13:28:25.000000000 -0800
***************
*** 294,300 ****
  const char* defiGroup::propName(int index) const {
    char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (LEFPARS-6050): The index number %d given for the GROUP PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
       defiError (0, 6050, msg);
       return 0;
    }
--- 294,300 ----
  const char* defiGroup::propName(int index) const {
    char msg[160];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (LEFPARS-6050): The index number %d given for the GROUP PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
       defiError (0, 6050, msg);
       return 0;
    }
***************
*** 305,311 ****
  const char* defiGroup::propValue(int index) const {
    char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (LEFPARS-6050): The index number %d given for the GROUP PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
       defiError (0, 6050, msg);
       return 0;
    }
--- 305,311 ----
  const char* defiGroup::propValue(int index) const {
    char msg[160];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (LEFPARS-6050): The index number %d given for the GROUP PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
       defiError (0, 6050, msg);
       return 0;
    }
***************
*** 316,322 ****
  double defiGroup::propNumber(int index) const {
    char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (LEFPARS-6050): The index number %d given for the GROUP PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
       defiError (0, 6050, msg);
       return 0;
    }
--- 316,322 ----
  double defiGroup::propNumber(int index) const {
    char msg[160];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (LEFPARS-6050): The index number %d given for the GROUP PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
       defiError (0, 6050, msg);
       return 0;
    }
***************
*** 324,333 ****
  }
  
  
! const char defiGroup::propType(int index) const {
    char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (LEFPARS-6050): The index number %d given for the GROUP PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
       defiError (0, 6050, msg);
       return 0;
    }
--- 324,333 ----
  }
  
  
! char defiGroup::propType(int index) const {
    char msg[160];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (LEFPARS-6050): The index number %d given for the GROUP PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
       defiError (0, 6050, msg);
       return 0;
    }
***************
*** 338,344 ****
  int defiGroup::propIsNumber(int index) const {
    char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (LEFPARS-6050): The index number %d given for the GROUP PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
       defiError (0, 6050, msg);
       return 0;
    }
--- 338,344 ----
  int defiGroup::propIsNumber(int index) const {
    char msg[160];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (LEFPARS-6050): The index number %d given for the GROUP PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
       defiError (0, 6050, msg);
       return 0;
    }
***************
*** 349,355 ****
  int defiGroup::propIsString(int index) const {
    char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (LEFPARS-6050): The index number %d given for the GROUP PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
       defiError (0, 6050, msg);
       return 0;
    }
--- 349,355 ----
  int defiGroup::propIsString(int index) const {
    char msg[160];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (LEFPARS-6050): The index number %d given for the GROUP PROPERTY is invalid.\nValid index is from 0 to %d", index, numProps_);
       defiError (0, 6050, msg);
       return 0;
    }
diff -r -c source.lefdef/def.orig/def/defiGroup.hpp def/def/defiGroup.hpp
*** source.lefdef/def.orig/def/defiGroup.hpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defiGroup.hpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 72,78 ****
    const char*  propName(int index) const;
    const char*  propValue(int index) const;
    double propNumber(int index) const;
!   const char   propType(int index) const;
    int    propIsNumber(int index) const;
    int    propIsString(int index) const;
  
--- 72,78 ----
    const char*  propName(int index) const;
    const char*  propValue(int index) const;
    double propNumber(int index) const;
!   char   propType(int index) const;
    int    propIsNumber(int index) const;
    int    propIsString(int index) const;
  
diff -r -c source.lefdef/def.orig/def/defiMisc.cpp def/def/defiMisc.cpp
*** source.lefdef/def.orig/def/defiMisc.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defiMisc.cpp	2024-01-14 13:29:25.000000000 -0800
***************
*** 107,113 ****
  void defiGeometries::points(int index, int* x, int* y) const {
    char msg[160];
    if ((index < 0) || (index >= numPoints_)) {
!      sprintf (msg, "ERROR (LEFPARS-6070): The index number %d given for GEOMETRY POINTS is invalid.\nValid index is from 0 to %d", index, numPoints_);
       defiError (0, 6070, msg);
       return;
    }
--- 107,113 ----
  void defiGeometries::points(int index, int* x, int* y) const {
    char msg[160];
    if ((index < 0) || (index >= numPoints_)) {
!      snprintf (msg, sizeof(msg), "ERROR (LEFPARS-6070): The index number %d given for GEOMETRY POINTS is invalid.\nValid index is from 0 to %d", index, numPoints_);
       defiError (0, 6070, msg);
       return;
    }
diff -r -c source.lefdef/def.orig/def/defiNet.cpp def/def/defiNet.cpp
*** source.lefdef/def.orig/def/defiNet.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defiNet.cpp	2024-01-15 08:31:56.000000000 -0800
***************
*** 1195,1204 ****
  
  void defiNet::changeInstance(const char* instance, int index) {
    int len;
!   char errMsg[128];
  
    if ((index < 0) || (index > numPins_)) {
!      sprintf (errMsg, "ERROR (DEFPARS-6083): The index number %d specified for the NET INSTANCE is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numPins_);
       defiError(0, 6083, errMsg);
    }
--- 1195,1204 ----
  
  void defiNet::changeInstance(const char* instance, int index) {
    int len;
!   char errMsg[256];
  
    if ((index < 0) || (index > numPins_)) {
!      snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6083): The index number %d specified for the NET INSTANCE is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numPins_);
       defiError(0, 6083, errMsg);
    }
***************
*** 1213,1222 ****
  
  void defiNet::changePin(const char* pin, int index) {
    int len;
!   char errMsg[128];
  
    if ((index < 0) || (index > numPins_)) {
!      sprintf (errMsg, "ERROR (DEFPARS-6084): The index number %d specified for the NET PIN is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numPins_);
       defiError(0, 6084, errMsg);
    }
--- 1213,1222 ----
  
  void defiNet::changePin(const char* pin, int index) {
    int len;
!   char errMsg[256];
  
    if ((index < 0) || (index > numPins_)) {
!      snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6084): The index number %d specified for the NET PIN is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numPins_);
       defiError(0, 6084, errMsg);
    }
***************
*** 1275,1281 ****
  }
  
  
! const char defiNet::propType(int index) const {
    if (index >= 0 &&  index < numProps_)
      return propTypes_[index];
    return 0;
--- 1275,1281 ----
  }
  
  
! char defiNet::propType(int index) const {
    if (index >= 0 &&  index < numProps_)
      return propTypes_[index];
    return 0;
***************
*** 2508,2516 ****
  
  // 5.6
  const char* defiNet::polygonName(int index) const {
!   char errMsg[128];
    if (index < 0 || index > numPolys_) {
!      sprintf (errMsg, "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numPolys_);
       defiError(0, 6085, errMsg);
       return 0;
--- 2508,2516 ----
  
  // 5.6
  const char* defiNet::polygonName(int index) const {
!   char errMsg[256];
    if (index < 0 || index > numPolys_) {
!      snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numPolys_);
       defiError(0, 6085, errMsg);
       return 0;
***************
*** 2519,2527 ****
  }
  
  const char* defiNet::polyRouteStatus(int index) const {
!   char errMsg[128];
    if (index < 0 || index > numPolys_) {
!      sprintf (errMsg, "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numPolys_);
       defiError(0, 6085, errMsg);
       return 0;
--- 2519,2527 ----
  }
  
  const char* defiNet::polyRouteStatus(int index) const {
!   char errMsg[256];
    if (index < 0 || index > numPolys_) {
!      snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numPolys_);
       defiError(0, 6085, errMsg);
       return 0;
***************
*** 2530,2538 ****
  }
  
  const char* defiNet::polyRouteStatusShieldName(int index) const {
!     char errMsg[128];
      if (index < 0 || index > numPolys_) {
!         sprintf (errMsg, "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numPolys_);
          defiError(0, 6085, errMsg);
          return 0;
--- 2530,2538 ----
  }
  
  const char* defiNet::polyRouteStatusShieldName(int index) const {
!     char errMsg[256];
      if (index < 0 || index > numPolys_) {
!         snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numPolys_);
          defiError(0, 6085, errMsg);
          return 0;
***************
*** 2541,2549 ****
  }
  
  const char* defiNet::polyShapeType(int index) const {
!   char errMsg[128];
    if (index < 0 || index > numPolys_) {
!      sprintf (errMsg, "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numPolys_);
       defiError(0, 6085, errMsg);
       return 0;
--- 2541,2549 ----
  }
  
  const char* defiNet::polyShapeType(int index) const {
!   char errMsg[256];
    if (index < 0 || index > numPolys_) {
!      snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numPolys_);
       defiError(0, 6085, errMsg);
       return 0;
***************
*** 2552,2560 ****
  }
  
  int defiNet::polyMask(int index) const {
!   char errMsg[128];
    if (index < 0 || index > numPolys_) {
!      sprintf (errMsg, "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numPolys_);
       defiError(0, 6085, errMsg);
       return 0;
--- 2552,2560 ----
  }
  
  int defiNet::polyMask(int index) const {
!   char errMsg[256];
    if (index < 0 || index > numPolys_) {
!      snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numPolys_);
       defiError(0, 6085, errMsg);
       return 0;
***************
*** 2658,2666 ****
  
  // 5.6
  const char* defiNet::rectName(int index) const {
!   char errMsg[128];
    if (index < 0 || index > numRects_) {
!      sprintf (errMsg, "ERROR (DEFPARS-6086): The index number %d specified for the NET RECTANGLE is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numRects_);
       defiError(0, 6086, errMsg);
       return 0;
--- 2658,2666 ----
  
  // 5.6
  const char* defiNet::rectName(int index) const {
!   char errMsg[256];
    if (index < 0 || index > numRects_) {
!      snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6086): The index number %d specified for the NET RECTANGLE is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numRects_);
       defiError(0, 6086, errMsg);
       return 0;
***************
*** 2669,2677 ****
  }
  
  const char* defiNet::rectRouteStatus(int index) const {
!   char errMsg[128];
    if (index < 0 || index > numRects_) {
!      sprintf (errMsg, "ERROR (DEFPARS-6086): The index number %d specified for the NET RECTANGLE is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numRects_);
       defiError(0, 6086, errMsg);
       return 0;
--- 2669,2677 ----
  }
  
  const char* defiNet::rectRouteStatus(int index) const {
!   char errMsg[256];
    if (index < 0 || index > numRects_) {
!      snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6086): The index number %d specified for the NET RECTANGLE is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numRects_);
       defiError(0, 6086, errMsg);
       return 0;
***************
*** 2680,2688 ****
  }
  
  const char* defiNet::rectRouteStatusShieldName(int index) const {
!     char errMsg[128];
      if (index < 0 || index > numRects_) {
!         sprintf (errMsg, "ERROR (DEFPARS-6086): The index number %d specified for the NET RECTANGLE is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numRects_);
          defiError(0, 6086, errMsg);
          return 0;
--- 2680,2688 ----
  }
  
  const char* defiNet::rectRouteStatusShieldName(int index) const {
!     char errMsg[256];
      if (index < 0 || index > numRects_) {
!         snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6086): The index number %d specified for the NET RECTANGLE is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numRects_);
          defiError(0, 6086, errMsg);
          return 0;
***************
*** 2691,2699 ****
  }
  
  const char* defiNet::rectShapeType(int index) const {
!   char errMsg[128];
    if (index < 0 || index > numRects_) {
!      sprintf (errMsg, "ERROR (DEFPARS-6086): The index number %d specified for the NET RECTANGLE is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numRects_);
       defiError(0, 6086, errMsg);
       return 0;
--- 2691,2699 ----
  }
  
  const char* defiNet::rectShapeType(int index) const {
!   char errMsg[256];
    if (index < 0 || index > numRects_) {
!      snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6086): The index number %d specified for the NET RECTANGLE is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numRects_);
       defiError(0, 6086, errMsg);
       return 0;
***************
*** 2703,2711 ****
  
  // 5.6
  int defiNet::xl(int index) const {
!   char errMsg[128];
    if (index < 0 || index >= numRects_) {
!      sprintf (errMsg, "ERROR (DEFPARS-6086): The index number %d specified for the NET RECTANGLE is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numRects_);
       defiError(0, 6086, errMsg);
       return 0;
--- 2703,2711 ----
  
  // 5.6
  int defiNet::xl(int index) const {
!   char errMsg[256];
    if (index < 0 || index >= numRects_) {
!      snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6086): The index number %d specified for the NET RECTANGLE is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numRects_);
       defiError(0, 6086, errMsg);
       return 0;
***************
*** 2715,2723 ****
  
  // 5.6
  int defiNet::yl(int index) const {
!   char errMsg[128];
    if (index < 0 || index >= numRects_) {
!      sprintf (errMsg, "ERROR (DEFPARS-6086): The index number %d specified for the NET RECTANGLE is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numRects_);
       defiError(0, 6086, errMsg);
       return 0;
--- 2715,2723 ----
  
  // 5.6
  int defiNet::yl(int index) const {
!   char errMsg[256];
    if (index < 0 || index >= numRects_) {
!      snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6086): The index number %d specified for the NET RECTANGLE is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numRects_);
       defiError(0, 6086, errMsg);
       return 0;
***************
*** 2727,2735 ****
  
  // 5.6
  int defiNet::xh(int index) const {
!   char errMsg[128];
    if (index < 0 || index >= numRects_) {
!      sprintf (errMsg, "ERROR (DEFPARS-6086): The index number %d specified for the NET RECTANGLE is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numRects_);
       defiError(0, 6086, errMsg);
       return 0;
--- 2727,2735 ----
  
  // 5.6
  int defiNet::xh(int index) const {
!   char errMsg[256];
    if (index < 0 || index >= numRects_) {
!      snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6086): The index number %d specified for the NET RECTANGLE is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numRects_);
       defiError(0, 6086, errMsg);
       return 0;
***************
*** 2739,2747 ****
  
  // 5.6
  int defiNet::yh(int index) const {
!   char errMsg[128];
    if (index < 0 || index >= numRects_) {
!      sprintf (errMsg, "ERROR (DEFPARS-6086): The index number %d specified for the NET RECTANGLE is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numRects_);
       defiError(0, 6086, errMsg);
       return 0;
--- 2739,2747 ----
  
  // 5.6
  int defiNet::yh(int index) const {
!   char errMsg[256];
    if (index < 0 || index >= numRects_) {
!      snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6086): The index number %d specified for the NET RECTANGLE is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numRects_);
       defiError(0, 6086, errMsg);
       return 0;
***************
*** 2750,2758 ****
  }
  
  int defiNet::rectMask(int index) const {
!   char errMsg[128];
    if (index < 0 || index >= numRects_) {
!      sprintf (errMsg, "ERROR (DEFPARS-6086): The index number %d specified for the NET RECTANGLE is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numRects_);
       defiError(0, 6086, errMsg);
       return 0;
--- 2750,2758 ----
  }
  
  int defiNet::rectMask(int index) const {
!   char errMsg[256];
    if (index < 0 || index >= numRects_) {
!      snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6086): The index number %d specified for the NET RECTANGLE is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numRects_);
       defiError(0, 6086, errMsg);
       return 0;
***************
*** 2848,2856 ****
  }
  
  const char* defiNet::viaName(int index) const {
!     char errMsg[128];
      if (index < 0 || index > numPts_) {
!         sprintf (errMsg, "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numPts_);
          defiError(0, 6085, errMsg);
          return 0;
--- 2848,2856 ----
  }
  
  const char* defiNet::viaName(int index) const {
!     char errMsg[256];
      if (index < 0 || index > numPts_) {
!         snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numPts_);
          defiError(0, 6085, errMsg);
          return 0;
***************
*** 2859,2867 ****
  }
  
  const char* defiNet::viaRouteStatus(int index) const {
!     char errMsg[128];
      if (index < 0 || index > numPts_) {
!         sprintf (errMsg, "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numPts_);
          defiError(0, 6085, errMsg);
          return 0;
--- 2859,2867 ----
  }
  
  const char* defiNet::viaRouteStatus(int index) const {
!     char errMsg[256];
      if (index < 0 || index > numPts_) {
!         snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numPts_);
          defiError(0, 6085, errMsg);
          return 0;
***************
*** 2870,2878 ****
  }
  
  const char* defiNet::viaRouteStatusShieldName(int index) const {
!     char errMsg[128];
      if (index < 0 || index > numPts_) {
!         sprintf (errMsg, "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numPts_);
          defiError(0, 6085, errMsg);
          return 0;
--- 2870,2878 ----
  }
  
  const char* defiNet::viaRouteStatusShieldName(int index) const {
!     char errMsg[256];
      if (index < 0 || index > numPts_) {
!         snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numPts_);
          defiError(0, 6085, errMsg);
          return 0;
***************
*** 2881,2889 ****
  }
  
  const char* defiNet::viaShapeType(int index) const {
!     char errMsg[128];
      if (index < 0 || index > numPts_) {
!         sprintf (errMsg, "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numPts_);
          defiError(0, 6085, errMsg);
          return 0;
--- 2881,2889 ----
  }
  
  const char* defiNet::viaShapeType(int index) const {
!     char errMsg[256];
      if (index < 0 || index > numPts_) {
!         snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numPts_);
          defiError(0, 6085, errMsg);
          return 0;
***************
*** 2891,2900 ****
      return viaShapeTypes_[index];
  }
  
! const int defiNet::viaOrient(int index) const {
!     char errMsg[128];
      if (index < 0 || index > numPts_) {
!         sprintf (errMsg, "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numPts_);
          defiError(0, 6085, errMsg);
          return 0;
--- 2891,2900 ----
      return viaShapeTypes_[index];
  }
  
! int defiNet::viaOrient(int index) const {
!     char errMsg[256];
      if (index < 0 || index > numPts_) {
!         snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numPts_);
          defiError(0, 6085, errMsg);
          return 0;
***************
*** 2903,2912 ****
  }
  
  const char* defiNet::viaOrientStr(int index) const  {
!     char errMsg[128];
  
      if (index < 0 || index > numPts_) {
!         sprintf (errMsg, "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numPts_);
          defiError(0, 6085, errMsg);
          return 0;
--- 2903,2912 ----
  }
  
  const char* defiNet::viaOrientStr(int index) const  {
!     char errMsg[256];
  
      if (index < 0 || index > numPts_) {
!         snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numPts_);
          defiError(0, 6085, errMsg);
          return 0;
***************
*** 2914,2923 ****
      return (defiOrientStr(viaOrients_[index]));
  }
  
! const int defiNet::topMaskNum(int index) const {
!    char errMsg[128];
      if (index < 0 || index > numPts_) {
!         sprintf (errMsg, "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numPts_);
          defiError(0, 6085, errMsg);
          return 0;
--- 2914,2923 ----
      return (defiOrientStr(viaOrients_[index]));
  }
  
! int defiNet::topMaskNum(int index) const {
!    char errMsg[256];
      if (index < 0 || index > numPts_) {
!         snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numPts_);
          defiError(0, 6085, errMsg);
          return 0;
***************
*** 2926,2935 ****
      return viaMasks_[index] / 100;
  }
  
! const int defiNet::cutMaskNum(int index) const {
!     char errMsg[128];
      if (index < 0 || index > numPts_) {
!         sprintf (errMsg, "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numPts_);
          defiError(0, 6085, errMsg);
          return 0;
--- 2926,2935 ----
      return viaMasks_[index] / 100;
  }
  
! int defiNet::cutMaskNum(int index) const {
!     char errMsg[256];
      if (index < 0 || index > numPts_) {
!         snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numPts_);
          defiError(0, 6085, errMsg);
          return 0;
***************
*** 2938,2947 ****
      return viaMasks_[index] / 10 % 10;
  }
  
! const int defiNet::bottomMaskNum(int index) const {
!     char errMsg[128];
      if (index < 0 || index > numPts_) {
!         sprintf (errMsg, "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numPts_);
          defiError(0, 6085, errMsg);
          return 0;
--- 2938,2947 ----
      return viaMasks_[index] / 10 % 10;
  }
  
! int defiNet::bottomMaskNum(int index) const {
!     char errMsg[256];
      if (index < 0 || index > numPts_) {
!         snprintf (errMsg, sizeof(errMsg), "ERROR (DEFPARS-6085): The index number %d specified for the NET POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
              index, numPts_);
          defiError(0, 6085, errMsg);
          return 0;
diff -r -c source.lefdef/def.orig/def/defiNet.hpp def/def/defiNet.hpp
*** source.lefdef/def.orig/def/defiNet.hpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defiNet.hpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 302,308 ****
    const char*  propName(int index) const;
    const char*  propValue(int index) const;
    double propNumber(int index) const;
!   const char   propType(int index) const;
    int    propIsNumber(int index) const;
    int    propIsString(int index) const;
    int          numConnections() const;
--- 302,308 ----
    const char*  propName(int index) const;
    const char*  propValue(int index) const;
    double propNumber(int index) const;
!   char         propType(int index) const;
    int    propIsNumber(int index) const;
    int    propIsString(int index) const;
    int          numConnections() const;
***************
*** 410,420 ****
    int  numViaSpecs() const;
    struct defiPoints getViaPts(int index) const;                       
    const char* viaName(int index) const;
!   const int viaOrient(int index) const;
    const char* viaOrientStr(int index) const;
!   const int topMaskNum(int index) const;
!   const int cutMaskNum(int index) const;
!   const int bottomMaskNum(int index) const;
    const char* viaRouteStatus(int index) const;
    const char* viaRouteStatusShieldName(int index) const;
    const char* viaShapeType(int index) const;
--- 410,420 ----
    int  numViaSpecs() const;
    struct defiPoints getViaPts(int index) const;                       
    const char* viaName(int index) const;
!   int   viaOrient(int index) const;
    const char* viaOrientStr(int index) const;
!   int   topMaskNum(int index) const;
!   int   cutMaskNum(int index) const;
!   int   bottomMaskNum(int index) const;
    const char* viaRouteStatus(int index) const;
    const char* viaRouteStatusShieldName(int index) const;
    const char* viaShapeType(int index) const;
diff -r -c source.lefdef/def.orig/def/defiNonDefault.cpp def/def/defiNonDefault.cpp
*** source.lefdef/def.orig/def/defiNonDefault.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defiNonDefault.cpp	2024-01-14 13:23:23.000000000 -0800
***************
*** 318,326 ****
  }
  
  const char* defiNonDefault::layerName(int index) const { 
!   char msg[160];
    if (index < 0 || index >= numLayers_) {
!      sprintf (msg, "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
--- 318,326 ----
  }
  
  const char* defiNonDefault::layerName(int index) const { 
!   char msg[256];
    if (index < 0 || index >= numLayers_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
***************
*** 330,338 ****
  
  // Will be obsoleted in 5.7
  double defiNonDefault::layerWidth(int index) const { 
!   char msg[160];
    if (index < 0 || index >= numLayers_) {
!      sprintf (msg, "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
--- 330,338 ----
  
  // Will be obsoleted in 5.7
  double defiNonDefault::layerWidth(int index) const { 
!   char msg[256];
    if (index < 0 || index >= numLayers_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
***************
*** 341,349 ****
  }
  
  int defiNonDefault::layerWidthVal(int index) const { 
!   char msg[160];
    if (index < 0 || index >= numLayers_) {
!      sprintf (msg, "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
--- 341,349 ----
  }
  
  int defiNonDefault::layerWidthVal(int index) const { 
!   char msg[256];
    if (index < 0 || index >= numLayers_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
***************
*** 352,360 ****
  }
  
  int defiNonDefault::hasLayerDiagWidth(int index) const { 
!   char msg[160];
    if (index < 0 || index >= numLayers_) {
!      sprintf (msg, "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
--- 352,360 ----
  }
  
  int defiNonDefault::hasLayerDiagWidth(int index) const { 
!   char msg[256];
    if (index < 0 || index >= numLayers_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
***************
*** 364,372 ****
  
  // Will be obsoleted in 5.7
  double defiNonDefault::layerDiagWidth(int index) const { 
!   char msg[160];
    if (index < 0 || index >= numLayers_) {
!      sprintf (msg, "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
--- 364,372 ----
  
  // Will be obsoleted in 5.7
  double defiNonDefault::layerDiagWidth(int index) const { 
!   char msg[256];
    if (index < 0 || index >= numLayers_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
***************
*** 375,383 ****
  }
  
  int defiNonDefault::layerDiagWidthVal(int index) const { 
!   char msg[160];
    if (index < 0 || index >= numLayers_) {
!      sprintf (msg, "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
--- 375,383 ----
  }
  
  int defiNonDefault::layerDiagWidthVal(int index) const { 
!   char msg[256];
    if (index < 0 || index >= numLayers_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
***************
*** 386,394 ****
  }
  
  int defiNonDefault::hasLayerWireExt(int index) const { 
!   char msg[160];
    if (index < 0 || index >= numLayers_) {
!      sprintf (msg, "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
--- 386,394 ----
  }
  
  int defiNonDefault::hasLayerWireExt(int index) const { 
!   char msg[256];
    if (index < 0 || index >= numLayers_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
***************
*** 397,405 ****
  }
  
  int defiNonDefault::hasLayerSpacing(int index) const { 
!   char msg[160];
    if (index < 0 || index >= numLayers_) {
!      sprintf (msg, "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
--- 397,405 ----
  }
  
  int defiNonDefault::hasLayerSpacing(int index) const { 
!   char msg[256];
    if (index < 0 || index >= numLayers_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
***************
*** 409,417 ****
  
  // Will be obsoleted in 5.7
  double defiNonDefault::layerWireExt(int index) const { 
!   char msg[160];
    if (index < 0 || index >= numLayers_) {
!      sprintf (msg, "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
--- 409,417 ----
  
  // Will be obsoleted in 5.7
  double defiNonDefault::layerWireExt(int index) const { 
!   char msg[256];
    if (index < 0 || index >= numLayers_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
***************
*** 420,428 ****
  }
  
  int defiNonDefault::layerWireExtVal(int index) const { 
!   char msg[160];
    if (index < 0 || index >= numLayers_) {
!      sprintf (msg, "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
--- 420,428 ----
  }
  
  int defiNonDefault::layerWireExtVal(int index) const { 
!   char msg[256];
    if (index < 0 || index >= numLayers_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
***************
*** 432,440 ****
  
  // Will be obsoleted in 5.7
  double defiNonDefault::layerSpacing(int index) const { 
!   char msg[160];
    if (index < 0 || index >= numLayers_) {
!      sprintf (msg, "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
--- 432,440 ----
  
  // Will be obsoleted in 5.7
  double defiNonDefault::layerSpacing(int index) const { 
!   char msg[256];
    if (index < 0 || index >= numLayers_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
***************
*** 443,451 ****
  }
  
  int defiNonDefault::layerSpacingVal(int index) const { 
!   char msg[160];
    if (index < 0 || index >= numLayers_) {
!      sprintf (msg, "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
--- 443,451 ----
  }
  
  int defiNonDefault::layerSpacingVal(int index) const { 
!   char msg[256];
    if (index < 0 || index >= numLayers_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
***************
*** 458,466 ****
  }
  
  const char* defiNonDefault::viaName(int index) const {
!   char msg[160];
    if (index < 0 || index >= numVias_) {
!      sprintf (msg, "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
--- 458,466 ----
  }
  
  const char* defiNonDefault::viaName(int index) const {
!   char msg[256];
    if (index < 0 || index >= numVias_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
***************
*** 473,481 ****
  }
  
  const char* defiNonDefault::viaRuleName(int index) const {
!   char msg[160];
    if (index < 0 || index >= numViaRules_) {
!      sprintf (msg, "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
--- 473,481 ----
  }
  
  const char* defiNonDefault::viaRuleName(int index) const {
!   char msg[256];
    if (index < 0 || index >= numViaRules_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
***************
*** 488,496 ****
  }
  
  const char* defiNonDefault::cutLayerName(int index) const {
!   char msg[160];
    if (index < 0 || index >= numMinCuts_) {
!      sprintf (msg, "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
--- 488,496 ----
  }
  
  const char* defiNonDefault::cutLayerName(int index) const {
!   char msg[256];
    if (index < 0 || index >= numMinCuts_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
***************
*** 499,507 ****
  }
  
  int defiNonDefault::numCuts(int index) const {
!   char msg[160];
    if (index < 0 || index >= numMinCuts_) {
!      sprintf (msg, "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
--- 499,507 ----
  }
  
  int defiNonDefault::numCuts(int index) const {
!   char msg[256];
    if (index < 0 || index >= numMinCuts_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6090): The index number %d specified for the NONDEFAULT LAYER is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numLayers_);
       defiError (0, 6090, msg);
       return 0;
***************
*** 638,646 ****
  }
  
  const char* defiNonDefault::propName(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6091): The index number %d specified for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numProps_);
       defiError (0, 6091, msg);
       return 0;
--- 638,646 ----
  }
  
  const char* defiNonDefault::propName(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6091): The index number %d specified for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numProps_);
       defiError (0, 6091, msg);
       return 0;
***************
*** 649,657 ****
  }
  
  const char* defiNonDefault::propValue(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6091): The index number %d specified for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numProps_);
       defiError (0, 6091, msg);
       return 0;
--- 649,657 ----
  }
  
  const char* defiNonDefault::propValue(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6091): The index number %d specified for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numProps_);
       defiError (0, 6091, msg);
       return 0;
***************
*** 660,668 ****
  }
  
  double defiNonDefault::propNumber(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6091): The index number %d specified for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numProps_);
       defiError (0, 6091, msg);
       return 0;
--- 660,668 ----
  }
  
  double defiNonDefault::propNumber(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6091): The index number %d specified for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numProps_);
       defiError (0, 6091, msg);
       return 0;
***************
*** 670,679 ****
    return dvalues_[index];
  }
  
! const char defiNonDefault::propType(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6091): The index number %d specified for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numProps_);
       defiError (0, 6091, msg);
       return 0;
--- 670,679 ----
    return dvalues_[index];
  }
  
! char defiNonDefault::propType(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6091): The index number %d specified for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numProps_);
       defiError (0, 6091, msg);
       return 0;
***************
*** 682,690 ****
  }
  
  int defiNonDefault::propIsNumber(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6091): The index number %d specified for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numProps_);
       defiError (0, 6091, msg);
       return 0;
--- 682,690 ----
  }
  
  int defiNonDefault::propIsNumber(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6091): The index number %d specified for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numProps_);
       defiError (0, 6091, msg);
       return 0;
***************
*** 693,701 ****
  }
  
  int defiNonDefault::propIsString(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6091): The index number %d specified for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numProps_);
       defiError (0, 6091, msg);
       return 0;
--- 693,701 ----
  }
  
  int defiNonDefault::propIsString(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6091): The index number %d specified for the NONDEFAULT PROPERTY is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again.",
               index, numProps_);
       defiError (0, 6091, msg);
       return 0;
diff -r -c source.lefdef/def.orig/def/defiNonDefault.hpp def/def/defiNonDefault.hpp
*** source.lefdef/def.orig/def/defiNonDefault.hpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defiNonDefault.hpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 67,73 ****
    const char* propName(int index) const;
    const char* propValue(int index) const;
    double      propNumber(int index) const;
!   const char  propType(int index) const;
    int         propIsNumber(int index) const;
    int         propIsString(int index) const;
    
--- 67,73 ----
    const char* propName(int index) const;
    const char* propValue(int index) const;
    double      propNumber(int index) const;
!   char        propType(int index) const;
    int         propIsNumber(int index) const;
    int         propIsString(int index) const;
    
diff -r -c source.lefdef/def.orig/def/defiPath.cpp def/def/defiPath.cpp
*** source.lefdef/def.orig/def/defiPath.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defiPath.cpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 39,47 ****
  defiPath::defiPath()
  : keys_(NULL),
  data_(NULL),
- pointer_(NULL),
  numUsed_(0),
  numAllocated_(0),
  numX_(0),      
  numY_(0),
  stepX_(0),
--- 39,48 ----
  defiPath::defiPath()
  : keys_(NULL),
  data_(NULL),
  numUsed_(0),
  numAllocated_(0),
+ pointer_(NULL),
+ 
  numX_(0),      
  numY_(0),
  stepX_(0),
diff -r -c source.lefdef/def.orig/def/defiPinProp.cpp def/def/defiPinProp.cpp
*** source.lefdef/def.orig/def/defiPinProp.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defiPinProp.cpp	2024-01-14 13:20:49.000000000 -0800
***************
*** 224,232 ****
  
  
  const char* defiPinProp::propName(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6120): The index number %d specified for the PIN PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6120, msg);
       return 0;
--- 224,232 ----
  
  
  const char* defiPinProp::propName(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6120): The index number %d specified for the PIN PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6120, msg);
       return 0;
***************
*** 236,244 ****
  
  
  const char* defiPinProp::propValue(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6120): The index number %d specified for the PIN PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6120, msg);
       return 0;
--- 236,244 ----
  
  
  const char* defiPinProp::propValue(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6120): The index number %d specified for the PIN PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6120, msg);
       return 0;
***************
*** 248,256 ****
  
  
  double defiPinProp::propNumber(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6120): The index number %d specified for the PIN PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6120, msg);
       return 0;
--- 248,256 ----
  
  
  double defiPinProp::propNumber(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6120): The index number %d specified for the PIN PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6120, msg);
       return 0;
***************
*** 259,268 ****
  }
  
  
! const char defiPinProp::propType(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6120): The index number %d specified for the PIN PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6120, msg);
       return 0;
--- 259,268 ----
  }
  
  
! char defiPinProp::propType(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6120): The index number %d specified for the PIN PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6120, msg);
       return 0;
***************
*** 272,280 ****
  
  
  int defiPinProp::propIsNumber(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6120): The index number %d specified for the PIN PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6120, msg);
       return 0;
--- 272,280 ----
  
  
  int defiPinProp::propIsNumber(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6120): The index number %d specified for the PIN PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6120, msg);
       return 0;
***************
*** 284,292 ****
  
  
  int defiPinProp::propIsString(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6120): The index number %d specified for the PIN PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6120, msg);
       return 0;
--- 284,292 ----
  
  
  int defiPinProp::propIsString(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6120): The index number %d specified for the PIN PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6120, msg);
       return 0;
diff -r -c source.lefdef/def.orig/def/defiPinProp.hpp def/def/defiPinProp.hpp
*** source.lefdef/def.orig/def/defiPinProp.hpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defiPinProp.hpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 59,65 ****
    const char*  propName(int index) const;
    const char*  propValue(int index) const;
    double propNumber(int index) const;
!   const char   propType(int index) const;
    int    propIsNumber(int index) const;
    int    propIsString(int index) const;
  
--- 59,65 ----
    const char*  propName(int index) const;
    const char*  propValue(int index) const;
    double propNumber(int index) const;
!   char   propType(int index) const;
    int    propIsNumber(int index) const;
    int    propIsString(int index) const;
  
diff -r -c source.lefdef/def.orig/def/defiPropType.cpp def/def/defiPropType.cpp
*** source.lefdef/def.orig/def/defiPropType.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defiPropType.cpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 114,120 ****
  }
  
  
! const char defiPropType::propType(char* name) const {
    int i;
  
    // Name is NULL, error
--- 114,120 ----
  }
  
  
! char defiPropType::propType(char* name) const {
    int i;
  
    // Name is NULL, error
diff -r -c source.lefdef/def.orig/def/defiPropType.hpp def/def/defiPropType.hpp
*** source.lefdef/def.orig/def/defiPropType.hpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defiPropType.hpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 48,54 ****
    void setPropType(const char* name, const char type);
    void Clear();
  
!   const char propType(char* name) const;
    void bumpProps();
  
  protected:
--- 48,54 ----
    void setPropType(const char* name, const char type);
    void Clear();
  
!   char propType(char* name) const;
    void bumpProps();
  
  protected:
diff -r -c source.lefdef/def.orig/def/defiRegion.cpp def/def/defiRegion.cpp
*** source.lefdef/def.orig/def/defiRegion.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defiRegion.cpp	2024-01-14 13:19:42.000000000 -0800
***************
*** 268,276 ****
  
  
  const char* defiRegion::propName(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6130): The index number %d specified for the REGION PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6130, msg);
       return 0;
--- 268,276 ----
  
  
  const char* defiRegion::propName(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6130): The index number %d specified for the REGION PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6130, msg);
       return 0;
***************
*** 280,288 ****
  
  
  const char* defiRegion::propValue(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6130): The index number %d specified for the REGION PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6130, msg);
       return 0;
--- 280,288 ----
  
  
  const char* defiRegion::propValue(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6130): The index number %d specified for the REGION PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6130, msg);
       return 0;
***************
*** 292,300 ****
  
  
  double defiRegion::propNumber(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6130): The index number %d specified for the REGION PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6130, msg);
       return 0;
--- 292,300 ----
  
  
  double defiRegion::propNumber(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6130): The index number %d specified for the REGION PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6130, msg);
       return 0;
***************
*** 303,312 ****
  }
  
  
! const char defiRegion::propType(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6130): The index number %d specified for the REGION PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6130, msg);
       return 0;
--- 303,312 ----
  }
  
  
! char defiRegion::propType(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6130): The index number %d specified for the REGION PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6130, msg);
       return 0;
***************
*** 315,323 ****
  }
  
  int defiRegion::propIsNumber(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6130): The index number %d specified for the REGION PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6130, msg);
       return 0;
--- 315,323 ----
  }
  
  int defiRegion::propIsNumber(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6130): The index number %d specified for the REGION PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6130, msg);
       return 0;
***************
*** 326,334 ****
  }
  
  int defiRegion::propIsString(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6130): The index number %d specified for the REGION PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6130, msg);
       return 0;
--- 326,334 ----
  }
  
  int defiRegion::propIsString(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6130): The index number %d specified for the REGION PROPERTY is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6130, msg);
       return 0;
***************
*** 342,350 ****
  
  
  int defiRegion::xl(int index) const {
!   char msg[160];
    if (index < 0 || index >= numRectangles_) {
!      sprintf (msg, "ERROR (DEFPARS-6131): The index number %d specified for the REGION RECTANGLE is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numRectangles_);
       defiError (0, 6131, msg);
       return 0;
--- 342,350 ----
  
  
  int defiRegion::xl(int index) const {
!   char msg[256];
    if (index < 0 || index >= numRectangles_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6131): The index number %d specified for the REGION RECTANGLE is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numRectangles_);
       defiError (0, 6131, msg);
       return 0;
***************
*** 354,362 ****
  
  
  int defiRegion::yl(int index) const {
!   char msg[160];
    if (index < 0 || index >= numRectangles_) {
!      sprintf (msg, "ERROR (DEFPARS-6131): The index number %d specified for the REGION RECTANGLE is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numRectangles_);
       defiError (0, 6131, msg);
       return 0;
--- 354,362 ----
  
  
  int defiRegion::yl(int index) const {
!   char msg[256];
    if (index < 0 || index >= numRectangles_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6131): The index number %d specified for the REGION RECTANGLE is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numRectangles_);
       defiError (0, 6131, msg);
       return 0;
***************
*** 366,374 ****
  
  
  int defiRegion::xh(int index) const {
!   char msg[160];
    if (index < 0 || index >= numRectangles_) {
!      sprintf (msg, "ERROR (DEFPARS-6131): The index number %d specified for the REGION RECTANGLE is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numRectangles_);
       defiError (0, 6131, msg);
       return 0;
--- 366,374 ----
  
  
  int defiRegion::xh(int index) const {
!   char msg[256];
    if (index < 0 || index >= numRectangles_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6131): The index number %d specified for the REGION RECTANGLE is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numRectangles_);
       defiError (0, 6131, msg);
       return 0;
***************
*** 378,386 ****
  
  
  int defiRegion::yh(int index) const {
!   char msg[160];
    if (index < 0 || index >= numRectangles_) {
!      sprintf (msg, "ERROR (DEFPARS-6131): The index number %d specified for the REGION RECTANGLE is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numRectangles_);
       defiError (0, 6131, msg);
       return 0;
--- 378,386 ----
  
  
  int defiRegion::yh(int index) const {
!   char msg[256];
    if (index < 0 || index >= numRectangles_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6131): The index number %d specified for the REGION RECTANGLE is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numRectangles_);
       defiError (0, 6131, msg);
       return 0;
diff -r -c source.lefdef/def.orig/def/defiRegion.hpp def/def/defiRegion.hpp
*** source.lefdef/def.orig/def/defiRegion.hpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defiRegion.hpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 58,64 ****
    const char*  propName(int index) const;
    const char*  propValue(int index) const;
    double propNumber(int index) const;
!   const char   propType(int index) const;
    int propIsNumber(int index) const;
    int propIsString(int index) const;
  
--- 58,64 ----
    const char*  propName(int index) const;
    const char*  propValue(int index) const;
    double propNumber(int index) const;
!   char   propType(int index) const;
    int propIsNumber(int index) const;
    int propIsString(int index) const;
  
diff -r -c source.lefdef/def.orig/def/defiRowTrack.cpp def/def/defiRowTrack.cpp
*** source.lefdef/def.orig/def/defiRowTrack.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defiRowTrack.cpp	2024-01-14 13:18:05.000000000 -0800
***************
*** 238,246 ****
  
  
  const char* defiRow::propName(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6140): The index number %d specified for the VIA LAYER RECTANGLE is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6140, msg);
       return 0;
--- 238,246 ----
  
  
  const char* defiRow::propName(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6140): The index number %d specified for the VIA LAYER RECTANGLE is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6140, msg);
       return 0;
***************
*** 250,258 ****
  
  
  const char* defiRow::propValue(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6140): The index number %d specified for the VIA LAYER RECTANGLE is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6140, msg);
       return 0;
--- 250,258 ----
  
  
  const char* defiRow::propValue(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6140): The index number %d specified for the VIA LAYER RECTANGLE is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6140, msg);
       return 0;
***************
*** 261,269 ****
  }
  
  double defiRow::propNumber(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6140): The index number %d specified for the VIA LAYER RECTANGLE is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6140, msg);
       return 0;
--- 261,269 ----
  }
  
  double defiRow::propNumber(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6140): The index number %d specified for the VIA LAYER RECTANGLE is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6140, msg);
       return 0;
***************
*** 271,280 ****
    return propDValues_[index];
  }
  
! const char defiRow::propType(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6140): The index number %d specified for the VIA LAYER RECTANGLE is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6140, msg);
       return 0;
--- 271,280 ----
    return propDValues_[index];
  }
  
! char defiRow::propType(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6140): The index number %d specified for the VIA LAYER RECTANGLE is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6140, msg);
       return 0;
***************
*** 283,291 ****
  }
  
  int defiRow::propIsNumber(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6140): The index number %d specified for the VIA LAYER RECTANGLE is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6140, msg);
       return 0;
--- 283,291 ----
  }
  
  int defiRow::propIsNumber(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6140): The index number %d specified for the VIA LAYER RECTANGLE is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6140, msg);
       return 0;
***************
*** 294,302 ****
  }
  
  int defiRow::propIsString(int index) const {
!   char msg[160];
    if (index < 0 || index >= numProps_) {
!      sprintf (msg, "ERROR (DEFPARS-6140): The index number %d specified for the VIA LAYER RECTANGLE is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6140, msg);
       return 0;
--- 294,302 ----
  }
  
  int defiRow::propIsString(int index) const {
!   char msg[256];
    if (index < 0 || index >= numProps_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6140): The index number %d specified for the VIA LAYER RECTANGLE is invalide.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numProps_);
       defiError (0, 6140, msg);
       return 0;
diff -r -c source.lefdef/def.orig/def/defiRowTrack.hpp def/def/defiRowTrack.hpp
*** source.lefdef/def.orig/def/defiRowTrack.hpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defiRowTrack.hpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 71,77 ****
    const char*  propName(int index) const;
    const char*  propValue(int index) const;
    double propNumber(int index) const;
!   const char   propType(int index) const;
    int propIsNumber(int index) const;
    int propIsString(int index) const;
  
--- 71,77 ----
    const char*  propName(int index) const;
    const char*  propValue(int index) const;
    double propNumber(int index) const;
!   char   propType(int index) const;
    int propIsNumber(int index) const;
    int propIsString(int index) const;
  
diff -r -c source.lefdef/def.orig/def/defiSlot.cpp def/def/defiSlot.cpp
*** source.lefdef/def.orig/def/defiSlot.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defiSlot.cpp	2024-01-14 13:16:03.000000000 -0800
***************
*** 192,200 ****
  
  
  int defiSlot::xl(int index) const {
!   char msg[160];
    if (index < 0 || index >= numRectangles_) {
!      sprintf (msg, "ERROR (DEFPARS-6160): The index number %d specified for the SLOT RECTANGLE is invalid.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numRectangles_);
       defiError (0, 6160, msg);
       return 0;
--- 192,200 ----
  
  
  int defiSlot::xl(int index) const {
!   char msg[256];
    if (index < 0 || index >= numRectangles_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6160): The index number %d specified for the SLOT RECTANGLE is invalid.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numRectangles_);
       defiError (0, 6160, msg);
       return 0;
***************
*** 204,212 ****
  
  
  int defiSlot::yl(int index) const {
!   char msg[160];
    if (index < 0 || index >= numRectangles_) {
!      sprintf (msg, "ERROR (DEFPARS-6160): The index number %d specified for the SLOT RECTANGLE is invalid.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numRectangles_);
       defiError (0, 6160, msg);
       return 0;
--- 204,212 ----
  
  
  int defiSlot::yl(int index) const {
!   char msg[256];
    if (index < 0 || index >= numRectangles_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6160): The index number %d specified for the SLOT RECTANGLE is invalid.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numRectangles_);
       defiError (0, 6160, msg);
       return 0;
***************
*** 216,224 ****
  
  
  int defiSlot::xh(int index) const {
!   char msg[160];
    if (index < 0 || index >= numRectangles_) {
!      sprintf (msg, "ERROR (DEFPARS-6160): The index number %d specified for the SLOT RECTANGLE is invalid.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numRectangles_);
       defiError (0, 6160, msg);
       return 0;
--- 216,224 ----
  
  
  int defiSlot::xh(int index) const {
!   char msg[256];
    if (index < 0 || index >= numRectangles_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6160): The index number %d specified for the SLOT RECTANGLE is invalid.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numRectangles_);
       defiError (0, 6160, msg);
       return 0;
***************
*** 228,236 ****
  
  
  int defiSlot::yh(int index) const {
!   char msg[160];
    if (index < 0 || index >= numRectangles_) {
!      sprintf (msg, "ERROR (DEFPARS-6160): The index number %d specified for the SLOT RECTANGLE is invalid.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numRectangles_);
       defiError (0, 6160, msg);
       return 0;
--- 228,236 ----
  
  
  int defiSlot::yh(int index) const {
!   char msg[256];
    if (index < 0 || index >= numRectangles_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6160): The index number %d specified for the SLOT RECTANGLE is invalid.\nValid index number is from 0 to %d. Specify a valid index number and then try again.",
                index, numRectangles_);
       defiError (0, 6160, msg);
       return 0;
diff -r -c source.lefdef/def.orig/def/defiVia.cpp def/def/defiVia.cpp
*** source.lefdef/def.orig/def/defiVia.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defiVia.cpp	2024-01-14 13:16:52.000000000 -0800
***************
*** 429,435 ****
  const char* defiVia::polygonName(int index) const {
    char msg[160];
    if (index < 0 || index > numPolys_) {
!      sprintf (msg, "ERROR (DEFPARS-6180): The index number %d specified for the VIA POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again",
                index, numPolys_);
       defiError (0, 6180, msg);
       return 0;
--- 429,435 ----
  const char* defiVia::polygonName(int index) const {
    char msg[160];
    if (index < 0 || index > numPolys_) {
!      snprintf (msg, sizeof(msg), "ERROR (DEFPARS-6180): The index number %d specified for the VIA POLYGON is invalid.\nValid index is from 0 to %d. Specify a valid index number and then try again",
                index, numPolys_);
       defiError (0, 6180, msg);
       return 0;
diff -r -c source.lefdef/def.orig/def/def_keywords.cpp def/def/def_keywords.cpp
*** source.lefdef/def.orig/def/def_keywords.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/def_keywords.cpp	2024-01-15 08:25:54.000000000 -0800
***************
*** 289,301 ****
  lines2str(long long lines) 
  {
      static char buffer[30];
! 
! #ifdef _WIN32
!     sprintf(buffer, "%I64d", lines);
! #else
!     sprintf(buffer, "%lld", lines);
! #endif 
! 
      return buffer;
  }
  
--- 289,295 ----
  lines2str(long long lines) 
  {
      static char buffer[30];
!     snprintf(buffer, sizeof(buffer), "%lld", lines);
      return buffer;
  }
  
***************
*** 642,649 ****
     }
  
     if (defData->defInvalidChar) {
!       outMsg = (char*)defMalloc(500 + strlen(defData->deftoken));
!       sprintf(outMsg, "Invalid characters found in \'%s\'.\nThese characters might be using the character types other than English.\nCreate characters by specifying valid characters types.",
                defData->deftoken);
        defError(6008, outMsg);
        defFree(outMsg);
--- 636,644 ----
     }
  
     if (defData->defInvalidChar) {
!       int xlen = 500 + strlen(defData->deftoken);
!       outMsg = (char*)defMalloc(xlen);
!       snprintf(outMsg, xlen, "Invalid characters found in \'%s\'.\nThese characters might be using the character types other than English.\nCreate characters by specifying valid characters types.",
                defData->deftoken);
        defError(6008, outMsg);
        defFree(outMsg);
***************
*** 692,700 ****
                 if ((numVal >= defData->lVal) && (numVal <= defData->rVal))
                    return NUMBER;    /* YES, it's really a number */
                 else {
!                   char* str = (char*)defMalloc(strlen(defData->deftoken)
!                                +strlen(defSettings->FileName)+350);
!                   sprintf(str,
                      "<Number has exceed the limit for an integer> in %s at line %s\n",
                      defSettings->FileName, lines2str(defData->nlines));
                    fflush(stdout);
--- 687,695 ----
                 if ((numVal >= defData->lVal) && (numVal <= defData->rVal))
                    return NUMBER;    /* YES, it's really a number */
                 else {
!                   int xlen = strlen(defData->deftoken) + strlen(defSettings->FileName) + 350;
!                   char* str = (char*)defMalloc(xlen);
!                   snprintf(str, xlen,
                      "<Number has exceed the limit for an integer> in %s at line %s\n",
                      defSettings->FileName, lines2str(defData->nlines));
                    fflush(stdout);
***************
*** 717,725 ****
              if ((numVal >= defData->lVal) && (numVal <= defData->rVal)) 
                 return NUMBER;    /* YES, it's really a number */
              else {
!                char* str = (char*)defMalloc(strlen(defData->deftoken)
!                                 +strlen(defSettings->FileName)+350);
!                sprintf(str,
                   "<Number has exceed the limit for an integer> in %s at line %s\n",
                   defSettings->FileName, lines2str(defData->nlines));
                 fflush(stdout);
--- 712,720 ----
              if ((numVal >= defData->lVal) && (numVal <= defData->rVal)) 
                 return NUMBER;    /* YES, it's really a number */
              else {
!                int xlen = strlen(defData->deftoken) + strlen(defSettings->FileName) + 350;
!                char* str = (char*)defMalloc(xlen);
!                snprintf(str, xlen,
                   "<Number has exceed the limit for an integer> in %s at line %s\n",
                   defSettings->FileName, lines2str(defData->nlines));
                 fflush(stdout);
***************
*** 846,855 ****
  
        if (defGetKeyword(defData->uc_token, &result)) {
           if (K_HISTORY == result) {  /* history - get up to ';' */
!             int n;
              int c;
              int prev;
!             n = 0;
              prev = ' ';
              while (1) {
                 c = GETC();
--- 841,850 ----
  
        if (defGetKeyword(defData->uc_token, &result)) {
           if (K_HISTORY == result) {  /* history - get up to ';' */
! //            int n;
              int c;
              int prev;
! //            n = 0;
              prev = ' ';
              while (1) {
                 c = GETC();
***************
*** 869,880 ****
              }
              defData->History_text.push_back('\0');
           } else if (K_BEGINEXT == result) { /* extension, get up to end */
!             int nn;
              int cc;
              int foundTag = 0;
              int notEmpTag = 0;
              int begQuote = 0;
!             nn = 0;
              /* First make sure there is a name after BEGINEXT within quote */
              /* BEGINEXT "name" */
              while (1) {
--- 864,875 ----
              }
              defData->History_text.push_back('\0');
           } else if (K_BEGINEXT == result) { /* extension, get up to end */
! //            int nn;
              int cc;
              int foundTag = 0;
              int notEmpTag = 0;
              int begQuote = 0;
! //            nn = 0;
              /* First make sure there is a name after BEGINEXT within quote */
              /* BEGINEXT "name" */
              while (1) {
***************
*** 963,971 ****
           if (strcmp(defData->deftoken, "<=") == 0) return K_LE;
           if (strcmp(defData->deftoken, "<>") == 0) return K_NE;
  
!          char* str = (char*)defMalloc(strlen(defData->deftoken)
!                                      +strlen(defSettings->FileName)+350);
!          sprintf(str,
                  "Odd punctuation in %s at line %s, defData->deftoken %s, Token ignored.\n",
           defSettings->FileName, lines2str(defData->nlines), defData->deftoken);
           defiError(1, 0, str);
--- 958,966 ----
           if (strcmp(defData->deftoken, "<=") == 0) return K_LE;
           if (strcmp(defData->deftoken, "<>") == 0) return K_NE;
  
!          int xlen = strlen(defData->deftoken) + strlen(defSettings->FileName) + 350;
!          char* str = (char*)defMalloc(xlen);
!          snprintf(str, xlen,
                  "Odd punctuation in %s at line %s, defData->deftoken %s, Token ignored.\n",
           defSettings->FileName, lines2str(defData->nlines), defData->deftoken);
           defiError(1, 0, str);
***************
*** 1015,1054 ****
     /* PCR 690679, probably missing space before a ';' */
     if (strcmp(s, "parse error") == 0) {
        if ((len > 1) && (defData->deftoken[len] == ';')) {
!          str = (char*)defMalloc(strlen(defData->deftoken)+strlen(s)
!                                        +strlen(defSettings->FileName)+350);
!          sprintf(str, "ERROR (DEFPARS-%d): %s, file %s at line %s\nLast token was <%s>, space is missing before <;>\n",
                msgNum, s, defSettings->FileName, lines2str(defData->nlines), defData->deftoken);
        } else if ((pvLen > 1) && (defData->pv_deftoken[pvLen] == ';')) {
!          str = (char*)defMalloc(strlen(defData->pv_deftoken)+strlen(s)
!                                 +strlen(defSettings->FileName)+350);
!          sprintf(str, "ERROR (DEFPARS-%d): %s, file %s at line %s\nLast token was <%s>, space is missing before <;>\n",
                msgNum, s, defSettings->FileName, lines2str(defData->nlines-1), defData->pv_deftoken);
        } else {
!          str = (char*)defMalloc(strlen(defData->deftoken)+ strlen(defSettings->FileName) + 350);
!          sprintf(str, "ERROR (DEFPARS-%d): Def parser has encountered an error in file %s at line %s, on token %s.\nProblem can be syntax error on the def file or an invalid parameter name.\nDouble check the syntax on the def file with the LEFDEF Reference Manual.\n",
                msgNum, defSettings->FileName, lines2str(defData->nlines), defData->deftoken);
        }
     } else if (strcmp(s, "syntax error") == 0) {
        if ((len > 1) && (defData->deftoken[len] == ';')) {
!          str = (char*)defMalloc(strlen(defData->deftoken)+strlen(s)
!                                        +strlen(defSettings->FileName)+350);
!          sprintf(str, "ERROR (DEFPARS-%d): %s, file %s at line %s\nLast token was <%s>, space is missing before <;>\n",
                msgNum, s, defSettings->FileName, lines2str(defData->nlines), defData->deftoken);
        } else if ((pvLen > 1) && (defData->pv_deftoken[pvLen] == ';')) {
!          str = (char*)defMalloc(strlen(defData->pv_deftoken)+strlen(s)
!                                 +strlen(defSettings->FileName)+350);
!          sprintf(str, "ERROR (DEFPARS-%d): %s, file %s at line %s\nLast token was <%s>, space is missing before <;>\n",
                msgNum, s, defSettings->FileName, lines2str(defData->nlines-1), defData->pv_deftoken);
        } else {
!          str = (char*)defMalloc(strlen(defData->deftoken)+ strlen(defSettings->FileName) + 350);
!          sprintf(str, "ERROR (DEFPARS-%d): Def parser has encountered an error in file %s at line %s, on token %s.\nProblem can be syntax error on the def file or an invalid parameter name.\nDouble check the syntax on the def file with the LEFDEF Reference Manual.\n",
                msgNum, defSettings->FileName, lines2str(defData->nlines), defData->deftoken);
        }
     } else {
!       str = (char*)defMalloc(strlen(defData->deftoken) + strlen(s) +
!                              strlen(defSettings->FileName) + 350);
!       sprintf(str, "ERROR (DEFPARS-%d): %s Error in file %s at line %s, on token %s.\nUpdate the def file before parsing the file again.\n",
             msgNum, s, defSettings->FileName, lines2str(defData->nlines), defData->deftoken);
     }
  
--- 1010,1051 ----
     /* PCR 690679, probably missing space before a ';' */
     if (strcmp(s, "parse error") == 0) {
        if ((len > 1) && (defData->deftoken[len] == ';')) {
!          int xlen = strlen(defData->deftoken)+strlen(s) + strlen(defSettings->FileName) + 350;
!          str = (char*)defMalloc(xlen);
!          snprintf(str, xlen,  "ERROR (DEFPARS-%d): %s, file %s at line %s\nLast token was <%s>, space is missing before <;>\n",
                msgNum, s, defSettings->FileName, lines2str(defData->nlines), defData->deftoken);
        } else if ((pvLen > 1) && (defData->pv_deftoken[pvLen] == ';')) {
!          int xlen = strlen(defData->pv_deftoken) + strlen(s) + strlen(defSettings->FileName) + 350;
!          str = (char*)defMalloc(xlen);
!          snprintf(str, xlen, "ERROR (DEFPARS-%d): %s, file %s at line %s\nLast token was <%s>, space is missing before <;>\n",
                msgNum, s, defSettings->FileName, lines2str(defData->nlines-1), defData->pv_deftoken);
        } else {
!          int xlen = strlen(defData->deftoken) + strlen(defSettings->FileName) + 350;
!          str = (char*)defMalloc(xlen);
!          snprintf(str, xlen, "ERROR (DEFPARS-%d): Def parser has encountered an error in file %s at line %s, on token %s.\nProblem can be syntax error on the def file or an invalid parameter name.\nDouble check the syntax on the def file with the LEFDEF Reference Manual.\n",
                msgNum, defSettings->FileName, lines2str(defData->nlines), defData->deftoken);
        }
     } else if (strcmp(s, "syntax error") == 0) {
        if ((len > 1) && (defData->deftoken[len] == ';')) {
!          int xlen = strlen(defData->deftoken) + strlen(s) + strlen(defSettings->FileName) + 350;
!          str = (char*)defMalloc(xlen);
!          snprintf(str, xlen, "ERROR (DEFPARS-%d): %s, file %s at line %s\nLast token was <%s>, space is missing before <;>\n",
                msgNum, s, defSettings->FileName, lines2str(defData->nlines), defData->deftoken);
        } else if ((pvLen > 1) && (defData->pv_deftoken[pvLen] == ';')) {
!          int xlen = strlen(defData->pv_deftoken) + strlen(s) + strlen(defSettings->FileName) + 350;
!          str = (char*)defMalloc(xlen);
!          snprintf(str, xlen,  "ERROR (DEFPARS-%d): %s, file %s at line %s\nLast token was <%s>, space is missing before <;>\n",
                msgNum, s, defSettings->FileName, lines2str(defData->nlines-1), defData->pv_deftoken);
        } else {
!          int xlen = strlen(defData->deftoken) + strlen(defSettings->FileName) + 350;
!          str = (char*)defMalloc(xlen);
!          snprintf(str, xlen, "ERROR (DEFPARS-%d): Def parser has encountered an error in file %s at line %s, on token %s.\nProblem can be syntax error on the def file or an invalid parameter name.\nDouble check the syntax on the def file with the LEFDEF Reference Manual.\n",
                msgNum, defSettings->FileName, lines2str(defData->nlines), defData->deftoken);
        }
     } else {
!       int xlen = strlen(defData->deftoken) + strlen(s) + strlen(defSettings->FileName) + 350;
!       str = (char*)defMalloc(xlen);
!       snprintf(str, xlen, "ERROR (DEFPARS-%d): %s Error in file %s at line %s, on token %s.\nUpdate the def file before parsing the file again.\n",
             msgNum, s, defSettings->FileName, lines2str(defData->nlines), defData->deftoken);
     }
  
***************
*** 1075,1083 ****
     }
  
     if (defSettings->WarningLogFunction) {
!       char* str = (char*)defMalloc(strlen(defData->deftoken)+strlen(s)
!                                    +strlen(defSettings->FileName)+350);
!       sprintf(str, "INFO (DEFPARS-%d): %s See file %s at line %s.\n",
                msgNum, s, defSettings->FileName, lines2str(defData->nlines));
        (*defSettings->WarningLogFunction)(str);
        defFree(str);
--- 1072,1080 ----
     }
  
     if (defSettings->WarningLogFunction) {
!       int xlen = strlen(defData->deftoken) + strlen(s) + strlen(defSettings->FileName) + 350;
!       char* str = (char*)defMalloc(xlen);
!       snprintf(str, xlen, "INFO (DEFPARS-%d): %s See file %s at line %s.\n",
                msgNum, s, defSettings->FileName, lines2str(defData->nlines));
        (*defSettings->WarningLogFunction)(str);
        defFree(str);
***************
*** 1122,1130 ****
     }
  
     if (defSettings->WarningLogFunction) {
!       char* str = (char*)defMalloc(strlen(defData->deftoken)+strlen(s)
!                                    +strlen(defSettings->FileName)+350);
!       sprintf(str, "WARNING (DEFPARS-%d): %s See file %s at line %s.\n",
                msgNum, s, defSettings->FileName, lines2str(defData->nlines));
        (*defSettings->WarningLogFunction)(str);
        defFree(str);
--- 1119,1127 ----
     }
  
     if (defSettings->WarningLogFunction) {
!       int xlen = strlen(defData->deftoken) + strlen(s) + strlen(defSettings->FileName) + 350;
!       char* str = (char*)defMalloc(xlen);
!       snprintf(str, xlen, "WARNING (DEFPARS-%d): %s See file %s at line %s.\n",
                msgNum, s, defSettings->FileName, lines2str(defData->nlines));
        (*defSettings->WarningLogFunction)(str);
        defFree(str);
diff -r -c source.lefdef/def.orig/def/defrCallbacks.cpp def/def/defrCallbacks.cpp
*** source.lefdef/def.orig/def/defrCallbacks.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defrCallbacks.cpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 51,56 ****
--- 51,57 ----
    ComponentStartCbk(NULL),
    ComponentEndCbk(NULL),
    ComponentCbk(NULL),
+   ComponentMaskShiftLayerCbk(NULL),
    NetStartCbk(NULL),
    NetEndCbk(NULL),
    NetCbk(NULL),
***************
*** 95,101 ****
    GroupsEndCbk(NULL),
    GroupNameCbk(NULL),
    GroupMemberCbk(NULL),
-   ComponentMaskShiftLayerCbk(NULL),
    GroupCbk(NULL),
    AssertionsStartCbk(NULL),
    AssertionsEndCbk(NULL),
--- 96,101 ----
***************
*** 169,175 ****
      if (!FloorPlanNameCbk)
          FloorPlanNameCbk = (defrStringCbkFnType) f;
      if (!UnitsCbk)
!         UnitsCbk = (defrDoubleCbkFnType) f;
      if (!DividerCbk)
          DividerCbk = (defrStringCbkFnType) f;
      if (!BusBitCbk)
--- 169,175 ----
      if (!FloorPlanNameCbk)
          FloorPlanNameCbk = (defrStringCbkFnType) f;
      if (!UnitsCbk)
!         UnitsCbk = (defrDoubleCbkFnType) (void*)f;
      if (!DividerCbk)
          DividerCbk = (defrStringCbkFnType) f;
      if (!BusBitCbk)
***************
*** 181,193 ****
      if (!CannotOccupyCbk)
          CannotOccupyCbk = (defrSiteCbkFnType) f;
      if (!ComponentStartCbk)
!         ComponentStartCbk = (defrIntegerCbkFnType) f;
      if (!ComponentEndCbk)
          ComponentEndCbk = (defrVoidCbkFnType) f;
      if (!ComponentCbk)
          ComponentCbk = (defrComponentCbkFnType) f;
      if (!NetStartCbk)
!         NetStartCbk = (defrIntegerCbkFnType) f;
      if (!NetEndCbk)
          NetEndCbk = (defrVoidCbkFnType) f;
      if (!NetCbk)
--- 181,193 ----
      if (!CannotOccupyCbk)
          CannotOccupyCbk = (defrSiteCbkFnType) f;
      if (!ComponentStartCbk)
!         ComponentStartCbk = (defrIntegerCbkFnType) (void*)f;
      if (!ComponentEndCbk)
          ComponentEndCbk = (defrVoidCbkFnType) f;
      if (!ComponentCbk)
          ComponentCbk = (defrComponentCbkFnType) f;
      if (!NetStartCbk)
!         NetStartCbk = (defrIntegerCbkFnType) (void*)f;
      if (!NetEndCbk)
          NetEndCbk = (defrVoidCbkFnType) f;
      if (!NetCbk)
***************
*** 197,203 ****
          PathCbk = (defrPathCbkFnType) f;
      if ((!VersionCbk) && (!VersionStrCbk)) {
          // both version callbacks weren't set, if either one is set, it is ok
!         VersionCbk = (defrDoubleCbkFnType) f;
          VersionStrCbk = (defrStringCbkFnType) f;
      }
      if (!PinExtCbk)
--- 197,203 ----
          PathCbk = (defrPathCbkFnType) f;
      if ((!VersionCbk) && (!VersionStrCbk)) {
          // both version callbacks weren't set, if either one is set, it is ok
!         VersionCbk = (defrDoubleCbkFnType) (void*)f;
          VersionStrCbk = (defrStringCbkFnType) f;
      }
      if (!PinExtCbk)
***************
*** 227,237 ****
      if (!PinCbk)
          PinCbk = (defrPinCbkFnType) f;
      if (!StartPinsCbk)
!         StartPinsCbk = (defrIntegerCbkFnType) f;
      if (!PinEndCbk)
          PinEndCbk = (defrVoidCbkFnType) f;
      if (!DefaultCapCbk)
!         DefaultCapCbk = (defrIntegerCbkFnType) f;
      if (!RowCbk)
          RowCbk = (defrRowCbkFnType) f;
      if (!TrackCbk)
--- 227,237 ----
      if (!PinCbk)
          PinCbk = (defrPinCbkFnType) f;
      if (!StartPinsCbk)
!         StartPinsCbk = (defrIntegerCbkFnType) (void*)f;
      if (!PinEndCbk)
          PinEndCbk = (defrVoidCbkFnType) f;
      if (!DefaultCapCbk)
!         DefaultCapCbk = (defrIntegerCbkFnType) (void*)f;
      if (!RowCbk)
          RowCbk = (defrRowCbkFnType) f;
      if (!TrackCbk)
***************
*** 239,257 ****
      if (!GcellGridCbk)
          GcellGridCbk = (defrGcellGridCbkFnType) f;
      if (!ViaStartCbk)
!         ViaStartCbk = (defrIntegerCbkFnType) f;
      if (!ViaEndCbk)
          ViaEndCbk = (defrVoidCbkFnType) f;
      if (!ViaCbk)
          ViaCbk = (defrViaCbkFnType) f;
      if (!RegionStartCbk)
!         RegionStartCbk = (defrIntegerCbkFnType) f;
      if (!RegionEndCbk)
          RegionEndCbk = (defrVoidCbkFnType) f;
      if (!RegionCbk)
          RegionCbk = (defrRegionCbkFnType) f;
      if (!SNetStartCbk)
!         SNetStartCbk = (defrIntegerCbkFnType) f;
      if (!SNetEndCbk)
          SNetEndCbk = (defrVoidCbkFnType) f;
      if (!SNetCbk)
--- 239,257 ----
      if (!GcellGridCbk)
          GcellGridCbk = (defrGcellGridCbkFnType) f;
      if (!ViaStartCbk)
!         ViaStartCbk = (defrIntegerCbkFnType) (void*)f;
      if (!ViaEndCbk)
          ViaEndCbk = (defrVoidCbkFnType) f;
      if (!ViaCbk)
          ViaCbk = (defrViaCbkFnType) f;
      if (!RegionStartCbk)
!         RegionStartCbk = (defrIntegerCbkFnType) (void*)f;
      if (!RegionEndCbk)
          RegionEndCbk = (defrVoidCbkFnType) f;
      if (!RegionCbk)
          RegionCbk = (defrRegionCbkFnType) f;
      if (!SNetStartCbk)
!         SNetStartCbk = (defrIntegerCbkFnType) (void*)f;
      if (!SNetEndCbk)
          SNetEndCbk = (defrVoidCbkFnType) f;
      if (!SNetCbk)
***************
*** 259,265 ****
      //  if(! defrSNetPartialPathCbk) defrSNetPartialPathCbk = (defrNetCbkFnType)f;
      //  if(! defrSNetWireCbk) defrSNetWireCbk = (defrNetCbkFnType)f;
      if (!GroupsStartCbk)
!         GroupsStartCbk = (defrIntegerCbkFnType) f;
      if (!GroupsEndCbk)
          GroupsEndCbk = (defrVoidCbkFnType) f;
      if (!GroupNameCbk)
--- 259,265 ----
      //  if(! defrSNetPartialPathCbk) defrSNetPartialPathCbk = (defrNetCbkFnType)f;
      //  if(! defrSNetWireCbk) defrSNetWireCbk = (defrNetCbkFnType)f;
      if (!GroupsStartCbk)
!         GroupsStartCbk = (defrIntegerCbkFnType) (void*)f;
      if (!GroupsEndCbk)
          GroupsEndCbk = (defrVoidCbkFnType) f;
      if (!GroupNameCbk)
***************
*** 271,351 ****
      if (!GroupCbk)
          GroupCbk = (defrGroupCbkFnType) f;
      if (!AssertionsStartCbk)
!         AssertionsStartCbk = (defrIntegerCbkFnType) f;
      if (!AssertionsEndCbk)
          AssertionsEndCbk = (defrVoidCbkFnType) f;
      if (!AssertionCbk)
          AssertionCbk = (defrAssertionCbkFnType) f;
      if (!ConstraintsStartCbk)
!         ConstraintsStartCbk = (defrIntegerCbkFnType) f;
      if (!ConstraintsEndCbk)
          ConstraintsEndCbk = (defrVoidCbkFnType) f;
      if (!ConstraintCbk)
          ConstraintCbk = (defrAssertionCbkFnType) f;
      if (!ScanchainsStartCbk)
!         ScanchainsStartCbk = (defrIntegerCbkFnType) f;
      if (!ScanchainsEndCbk)
          ScanchainsEndCbk = (defrVoidCbkFnType) f;
      if (!ScanchainCbk)
          ScanchainCbk = (defrScanchainCbkFnType) f;
      if (!IOTimingsStartCbk)
!         IOTimingsStartCbk = (defrIntegerCbkFnType) f;
      if (!IOTimingsEndCbk)
          IOTimingsEndCbk = (defrVoidCbkFnType) f;
      if (!IOTimingCbk)
          IOTimingCbk = (defrIOTimingCbkFnType) f;
      if (!FPCStartCbk)
!         FPCStartCbk = (defrIntegerCbkFnType) f;
      if (!FPCEndCbk)
          FPCEndCbk = (defrVoidCbkFnType) f;
      if (!FPCCbk)
          FPCCbk = (defrFPCCbkFnType) f;
      if (!TimingDisablesStartCbk)
!         TimingDisablesStartCbk = (defrIntegerCbkFnType) f;
      if (!TimingDisablesEndCbk)
          TimingDisablesEndCbk = (defrVoidCbkFnType) f;
      if (!TimingDisableCbk)
          TimingDisableCbk = (defrTimingDisableCbkFnType) f;
      if (!PartitionsStartCbk)
!         PartitionsStartCbk = (defrIntegerCbkFnType) f;
      if (!PartitionsEndCbk)
          PartitionsEndCbk = (defrVoidCbkFnType) f;
      if (!PartitionCbk)
          PartitionCbk = (defrPartitionCbkFnType) f;
      if (!PinPropStartCbk)
!         PinPropStartCbk = (defrIntegerCbkFnType) f;
      if (!PinPropEndCbk)
          PinPropEndCbk = (defrVoidCbkFnType) f;
      if (!PinPropCbk)
          PinPropCbk = (defrPinPropCbkFnType) f;
      if (!CaseSensitiveCbk)
!         CaseSensitiveCbk = (defrIntegerCbkFnType) f;
      if (!BlockageStartCbk)
!         BlockageStartCbk = (defrIntegerCbkFnType) f;
      if (!BlockageEndCbk)
          BlockageEndCbk = (defrVoidCbkFnType) f;
      if (!BlockageCbk)
          BlockageCbk = (defrBlockageCbkFnType) f;
      if (!SlotStartCbk)
!         SlotStartCbk = (defrIntegerCbkFnType) f;
      if (!SlotEndCbk)
          SlotEndCbk = (defrVoidCbkFnType) f;
      if (!SlotCbk)
          SlotCbk = (defrSlotCbkFnType) f;
      if (!FillStartCbk)
!         FillStartCbk = (defrIntegerCbkFnType) f;
      if (!FillEndCbk)
          FillEndCbk = (defrVoidCbkFnType) f;
      if (!FillCbk)
          FillCbk = (defrFillCbkFnType) f;
      if (!NonDefaultStartCbk)
!         NonDefaultStartCbk = (defrIntegerCbkFnType) f;
      if (!NonDefaultEndCbk)
          NonDefaultEndCbk = (defrVoidCbkFnType) f;
      if (!NonDefaultCbk)
          NonDefaultCbk = (defrNonDefaultCbkFnType) f;
      if (!StylesStartCbk)
!         StylesStartCbk = (defrIntegerCbkFnType) f;
      if (!StylesEndCbk)
          StylesEndCbk = (defrVoidCbkFnType) f;
      if (!StylesCbk)
--- 271,351 ----
      if (!GroupCbk)
          GroupCbk = (defrGroupCbkFnType) f;
      if (!AssertionsStartCbk)
!         AssertionsStartCbk = (defrIntegerCbkFnType) (void*)f;
      if (!AssertionsEndCbk)
          AssertionsEndCbk = (defrVoidCbkFnType) f;
      if (!AssertionCbk)
          AssertionCbk = (defrAssertionCbkFnType) f;
      if (!ConstraintsStartCbk)
!         ConstraintsStartCbk = (defrIntegerCbkFnType) (void*)f;
      if (!ConstraintsEndCbk)
          ConstraintsEndCbk = (defrVoidCbkFnType) f;
      if (!ConstraintCbk)
          ConstraintCbk = (defrAssertionCbkFnType) f;
      if (!ScanchainsStartCbk)
!         ScanchainsStartCbk = (defrIntegerCbkFnType) (void*)f;
      if (!ScanchainsEndCbk)
          ScanchainsEndCbk = (defrVoidCbkFnType) f;
      if (!ScanchainCbk)
          ScanchainCbk = (defrScanchainCbkFnType) f;
      if (!IOTimingsStartCbk)
!         IOTimingsStartCbk = (defrIntegerCbkFnType) (void*)f;
      if (!IOTimingsEndCbk)
          IOTimingsEndCbk = (defrVoidCbkFnType) f;
      if (!IOTimingCbk)
          IOTimingCbk = (defrIOTimingCbkFnType) f;
      if (!FPCStartCbk)
!         FPCStartCbk = (defrIntegerCbkFnType) (void*)f;
      if (!FPCEndCbk)
          FPCEndCbk = (defrVoidCbkFnType) f;
      if (!FPCCbk)
          FPCCbk = (defrFPCCbkFnType) f;
      if (!TimingDisablesStartCbk)
!         TimingDisablesStartCbk = (defrIntegerCbkFnType) (void*)f;
      if (!TimingDisablesEndCbk)
          TimingDisablesEndCbk = (defrVoidCbkFnType) f;
      if (!TimingDisableCbk)
          TimingDisableCbk = (defrTimingDisableCbkFnType) f;
      if (!PartitionsStartCbk)
!         PartitionsStartCbk = (defrIntegerCbkFnType) (void*)f;
      if (!PartitionsEndCbk)
          PartitionsEndCbk = (defrVoidCbkFnType) f;
      if (!PartitionCbk)
          PartitionCbk = (defrPartitionCbkFnType) f;
      if (!PinPropStartCbk)
!         PinPropStartCbk = (defrIntegerCbkFnType) (void*)f;
      if (!PinPropEndCbk)
          PinPropEndCbk = (defrVoidCbkFnType) f;
      if (!PinPropCbk)
          PinPropCbk = (defrPinPropCbkFnType) f;
      if (!CaseSensitiveCbk)
!         CaseSensitiveCbk = (defrIntegerCbkFnType) (void*)f;
      if (!BlockageStartCbk)
!         BlockageStartCbk = (defrIntegerCbkFnType) (void*)f;
      if (!BlockageEndCbk)
          BlockageEndCbk = (defrVoidCbkFnType) f;
      if (!BlockageCbk)
          BlockageCbk = (defrBlockageCbkFnType) f;
      if (!SlotStartCbk)
!         SlotStartCbk = (defrIntegerCbkFnType) (void*)f;
      if (!SlotEndCbk)
          SlotEndCbk = (defrVoidCbkFnType) f;
      if (!SlotCbk)
          SlotCbk = (defrSlotCbkFnType) f;
      if (!FillStartCbk)
!         FillStartCbk = (defrIntegerCbkFnType) (void*)f;
      if (!FillEndCbk)
          FillEndCbk = (defrVoidCbkFnType) f;
      if (!FillCbk)
          FillCbk = (defrFillCbkFnType) f;
      if (!NonDefaultStartCbk)
!         NonDefaultStartCbk = (defrIntegerCbkFnType) (void*)f;
      if (!NonDefaultEndCbk)
          NonDefaultEndCbk = (defrVoidCbkFnType) f;
      if (!NonDefaultCbk)
          NonDefaultCbk = (defrNonDefaultCbkFnType) f;
      if (!StylesStartCbk)
!         StylesStartCbk = (defrIntegerCbkFnType) (void*)f;
      if (!StylesEndCbk)
          StylesEndCbk = (defrVoidCbkFnType) f;
      if (!StylesCbk)
diff -r -c source.lefdef/def.orig/def/defrData.cpp def/def/defrData.cpp
*** source.lefdef/def.orig/def/defrData.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defrData.cpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 45,51 ****
  defrData *defData = NULL;
  
  defrData::defrData()
! : Subnet(0),
    aOxide(0),
    assertionWarnings(0),
    bit_is_keyword(0),
--- 45,68 ----
  defrData *defData = NULL;
  
  defrData::defrData()
! : defrLog(0),
!   defPropDefType('\0'),
!   ch(NULL),
!   defMsg(NULL),
!   deftoken((char*)defMalloc(TOKEN_SIZE)),
!   uc_token((char*)defMalloc(TOKEN_SIZE)),
!   last(NULL),
!   magic((char*)malloc(1)),
!   next(NULL),
!   pv_deftoken((char*)defMalloc(TOKEN_SIZE)),
!   rowName(NULL),
!   shieldName(NULL),
!   shiftBuf(0),
!   warningMsg(NULL),
!   save_x(0.0),
!   save_y(0.0),
!   lVal(0.0),
!   rVal(0.0),
    aOxide(0),
    assertionWarnings(0),
    bit_is_keyword(0),
***************
*** 53,59 ****
    blockageWarnings(0),
    by_is_keyword(0),
    caseSensitiveWarnings(0),
-   ch(NULL),
    componentWarnings(0),
    constraintWarnings(0),
    cover_is_keyword(0),
--- 70,75 ----
***************
*** 61,75 ****
    defIgnoreVersion(0),
    defInPropDef(0),
    defInvalidChar(0),
-   defMsg(NULL),
    defMsgCnt(5500),
    defMsgPrinted(0),
    defPrintTokens(0),
-   defPropDefType('\0'),
    defRetVal(0),
    def_warnings(0),
    defaultCapWarnings(0),
-   defrLog(0),
    do_is_keyword(0),
    dumb_mode(0),
    errors(0),
--- 77,88 ----
***************
*** 92,99 ****
    hasVer(0),
    iOTimingWarnings(0),
    input_level(-1),
-   last(NULL),
-   magic((char*)malloc(1)),
    mask_is_keyword(0),
    mustjoin_is_keyword(0),
    names_case_sensitive(1),
--- 105,110 ----
***************
*** 102,109 ****
    netOsnet(0),
    netWarnings(0),
    new_is_keyword(0),
-   next(NULL),
-   nlines(1),
    nl_token(FALSE),
    no_num(0),
    nonDefaultWarnings(0),
--- 113,118 ----
***************
*** 119,133 ****
    regionWarnings(0),
    ringPlace(0),
    routed_is_keyword(0),
-   rowName(NULL),
    rowWarnings(0),
    sNetWarnings(0),
-   save_x(0.0),
-   save_y(0.0),
    scanchainWarnings(0),
    shield(FALSE),
-   shieldName(NULL),
-   shiftBuf(0),
    shiftBufLength(0),
    specialWire_mask(0),
    step_is_keyword(0),
--- 128,137 ----
***************
*** 139,153 ****
    viaWarnings(0),
    virtual_is_keyword(0),
    deftokenLength(TOKEN_SIZE),
!   warningMsg(NULL),
    specialWire_routeStatus((char*) "ROUTED"),
    specialWire_routeStatusName((char *)""),
    specialWire_shapeType((char*)""),
    VersionNum(5.7),
    xStep(0),
    yStep(0),
!   lVal(0.0),
!   rVal(0.0),
    // defrReader vars
    Prop(),
    Site(),
--- 143,157 ----
    viaWarnings(0),
    virtual_is_keyword(0),
    deftokenLength(TOKEN_SIZE),
!   nlines(1),
! 
    specialWire_routeStatus((char*) "ROUTED"),
    specialWire_routeStatusName((char *)""),
    specialWire_shapeType((char*)""),
    VersionNum(5.7),
    xStep(0),
    yStep(0),
! 
    // defrReader vars
    Prop(),
    Site(),
***************
*** 177,187 ****
    Fill(),
    NonDefault(),
    Styles(),
    doneDesign(0),
    NeedPathData(0),
!   deftoken((char*)defMalloc(TOKEN_SIZE)),
!   uc_token((char*)defMalloc(TOKEN_SIZE)),
!   pv_deftoken((char*)defMalloc(TOKEN_SIZE))
  {
      magic[0] = '\0';
      deftoken[0] = '\0';
--- 181,191 ----
    Fill(),
    NonDefault(),
    Styles(),
+   Geometries(),
    doneDesign(0),
+ 
    NeedPathData(0),
!   Subnet(0)
  {
      magic[0] = '\0';
      deftoken[0] = '\0';
diff -r -c source.lefdef/def.orig/def/defrData.hpp def/def/defrData.hpp
*** source.lefdef/def.orig/def/defrData.hpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defrData.hpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 90,95 ****
--- 90,96 ----
      int  componentWarnings; 
      int  constraintWarnings; 
      int  cover_is_keyword; 
+ 
      int  defIgnoreVersion; // ignore checking version number
      int  defInPropDef; 
      int  defInvalidChar; 
***************
*** 161,170 ****
      int  deftokenLength;
      long long nlines;
  
-     std::vector<char>  History_text; 
-     defAliasMap        def_alias_set; 
-     defDefineMap       def_defines_set;
- 
      char*  specialWire_routeStatus;
      char*  specialWire_routeStatusName;
      char*  specialWire_shapeType;
--- 162,167 ----
***************
*** 173,179 ****
      double yStep;
          
      //defrParser vars.
-     defiPath PathObj;
      defiProp Prop;
      defiSite Site;
      defiComponent Component;
--- 170,175 ----
***************
*** 214,219 ****
--- 210,220 ----
      char* ring[RING_SIZE];
      int ringSizes[RING_SIZE];
      std::string stack[20];  /* the stack itself */
+ 
+     defiPath PathObj;
+     std::vector<char>  History_text; 
+     defAliasMap        def_alias_set; 
+     defDefineMap       def_defines_set;
  };
  
  extern defrData *defData;
diff -r -c source.lefdef/def.orig/def/defrReader.cpp def/def/defrReader.cpp
*** source.lefdef/def.orig/def/defrReader.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defrReader.cpp	2024-01-14 13:13:21.000000000 -0800
***************
*** 2267,2273 ****
      char msgStr[10];
  
      if ((msgId <= 0) || ((msgId - 5000) >= NODEFMSG)) {   // Def starts at 5000
!         sprintf(msgStr, "%d", msgId);
          defError(204, msgStr);
          return;
      }
--- 2267,2273 ----
      char msgStr[10];
  
      if ((msgId <= 0) || ((msgId - 5000) >= NODEFMSG)) {   // Def starts at 5000
!         snprintf(msgStr, 10, "%d", msgId);
          defError(204, msgStr);
          return;
      }
***************
*** 2395,2401 ****
      //strcpy(v1, value);
      if (marked != 0)
          marked = 1;                 // make sure only 1 digit
!     sprintf(v1, "%d%s", marked, value);
  
      defData->def_alias_set[k1] = v1;
  }
--- 2395,2401 ----
      //strcpy(v1, value);
      if (marked != 0)
          marked = 1;                 // make sure only 1 digit
!     snprintf(v1, len, "%d%s", marked, value);
  
      defData->def_alias_set[k1] = v1;
  }
***************
*** 2469,2475 ****
          //defrPath->reverseOrder();
          (*defCallbacks->PathCbk)(defrPathCbkType, &defData->PathObj, defSettings->UserData);
          defData->PathObj.Destroy();
!         free((char*) &defData->PathObj);
      }
  
      defData->PathObj.Init();
--- 2469,2475 ----
          //defrPath->reverseOrder();
          (*defCallbacks->PathCbk)(defrPathCbkType, &defData->PathObj, defSettings->UserData);
          defData->PathObj.Destroy();
!         //free((char*) &defData->PathObj);
      }
  
      defData->PathObj.Init();
diff -r -c source.lefdef/def.orig/def/defrSettings.cpp def/def/defrSettings.cpp
*** source.lefdef/def.orig/def/defrSettings.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defrSettings.cpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 46,51 ****
--- 46,52 ----
    FillWarnings(999),
    GcellGridWarnings(999),
    IOTimingWarnings(999),
+ 
    NetWarnings(999),
    NonDefaultWarnings(999),
    PinExtWarnings(999),
***************
*** 81,86 ****
--- 82,88 ----
    FreeFunction(NULL),
    LineNumberFunction(NULL),
    LongLineNumberFunction(NULL),
+ 
    CompProp(),
    CompPinProp(),
    DesignProp(),
diff -r -c source.lefdef/def.orig/def/defrSettings.hpp def/def/defrSettings.hpp
*** source.lefdef/def.orig/def/defrSettings.hpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defrSettings.hpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 75,81 ****
      int FillWarnings;
      int GcellGridWarnings;
      int IOTimingWarnings;
-     int LogFileAppend; 
      int NetWarnings;
      int NonDefaultWarnings;
      int PinExtWarnings;
--- 75,80 ----
***************
*** 92,97 ****
--- 91,98 ----
  
      int  nDDMsgs; 
      int* disableDMsgs;
+     int reader_case_sensitive;
+     int reader_case_sensitive_set;
      int  totalDefMsgLimit; // to save the user set total msg limit to output
      int AddPathToNet;
      int AllowComponentNets;
***************
*** 99,107 ****
      int DisPropStrProcess; 
      FILE* File;
      char* FileName;
      defiUserData UserData;
-     int reader_case_sensitive;
-     int reader_case_sensitive_set;
  
      DEFI_READ_FUNCTION ReadFunction;
      DEFI_LOG_FUNCTION ErrorLogFunction;
--- 100,107 ----
      int DisPropStrProcess; 
      FILE* File;
      char* FileName;
+     int LogFileAppend; 
      defiUserData UserData;
  
      DEFI_READ_FUNCTION ReadFunction;
      DEFI_LOG_FUNCTION ErrorLogFunction;
***************
*** 113,122 ****
      DEFI_LINE_NUMBER_FUNCTION LineNumberFunction;
      DEFI_LONG_LINE_NUMBER_FUNCTION LongLineNumberFunction;
  
-     int Debug[DEF_DEBUG_IDS]; /* can set from command line for debugging */
-     int UnusedCallbacks[CBMAX];
-     int MsgLimit[DEF_MSGS];
- 
      // The following global variables are for storing the propertydefination
      // types.  Only real & integer need to store since the parser can
      // distinguish string and quote string
--- 113,118 ----
***************
*** 129,134 ****
--- 125,134 ----
      defiPropType RegionProp;
      defiPropType RowProp;
      defiPropType SNetProp;
+ 
+     int Debug[DEF_DEBUG_IDS]; /* can set from command line for debugging */
+     int UnusedCallbacks[CBMAX];
+     int MsgLimit[DEF_MSGS];
  };
  
  extern defrSettings *defSettings;
Only in def/def: def.tgz
diff -r -c source.lefdef/def.orig/def/defwWriterCalls.cpp def/def/defwWriterCalls.cpp
*** source.lefdef/def.orig/def/defwWriterCalls.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/def/defwWriterCalls.cpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 347,353 ****
  
  int defwCountFunc(defwCallbackType_e e, defiUserData d) {
    int i = (int)e;
!   if (defiDebug(23)) printf("count %d 0x%x\n", (int)e, d);
    if (i >= 0 && i < 100) {
      defwUnusedCount[i] += 1;
      return 0;
--- 347,353 ----
  
  int defwCountFunc(defwCallbackType_e e, defiUserData d) {
    int i = (int)e;
!   if (defiDebug(23)) printf("count %d 0x%p\n", (int)e, d);
    if (i >= 0 && i < 100) {
      defwUnusedCount[i] += 1;
      return 0;
diff -r -c source.lefdef/def.orig/def/def.y def/def/def.y
*** source.lefdef/def.orig/def/def.y	2016-02-05 14:39:14.000000000 -0800
--- def/def/def.y	2024-01-14 12:19:07.000000000 -0800
***************
*** 19,24 ****
--- 19,29 ----
  // 
  // For updates, support, or to become part of the LEF/DEF Community,
  // check www.openeda.org for details.
+ //====
+ // Updated to add missing semicolons for compatibility with bison-3.
+ // Bison no longer repairs this error.
+ // Stephen Whiteley, Whiteley Research Inc.
+ //====
  //******************************************************************************
  // 
  //  $Author: dell $
***************
*** 109,116 ****
  
  #define CHKPROPTYPE(propType, propName, name) \
      if (propType == 'N') { \
!        defData->warningMsg = (char*)defMalloc(strlen(propName)+strlen(name)+40); \
!        sprintf(defData->warningMsg, "The PropName %s is not defined for %s.", \
                 propName, name); \
         defWarning(7010, defData->warningMsg); \
         defFree(defData->warningMsg); \
--- 114,122 ----
  
  #define CHKPROPTYPE(propType, propName, name) \
      if (propType == 'N') { \
!        int sz = strlen(propName)+strlen(name)+40; \
!        defData->warningMsg = (char*)defMalloc(sz); \
!        snprintf(defData->warningMsg, sz, "The PropName %s is not defined for %s.", \
                 propName, name); \
         defWarning(7010, defData->warningMsg); \
         defFree(defData->warningMsg); \
***************
*** 121,127 ****
      if (defData->VersionNum < 5.8 && input > 0) {
        if (warningIndex++ < getWarningsIndex) {
            defData->defMsg = (char*)defMalloc(1000);
!           sprintf (defData->defMsg,
               "The MASK statement is available in version 5.8 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
            defError(7415, defData->defMsg);
            defFree(defData->defMsg);
--- 127,133 ----
      if (defData->VersionNum < 5.8 && input > 0) {
        if (warningIndex++ < getWarningsIndex) {
            defData->defMsg = (char*)defMalloc(1000);
!           snprintf (defData->defMsg, 1000,
               "The MASK statement is available in version 5.8 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
            defError(7415, defData->defMsg);
            defFree(defData->defMsg);
***************
*** 193,199 ****
                  if (defCallbacks->UnitsCbk) {
                    if (defData->unitsWarnings++ < defSettings->UnitsWarnings) {
                      outMsg = (char*)defMalloc(1000);
!                     sprintf (outMsg,
                      "An error has been found while processing the DEF file '%s'\nUnit %d is a 5.6 or later syntax. Define the DEF file as 5.6 and then try again.",
                      defSettings->FileName, values);
                      defError(6501, outMsg);
--- 199,205 ----
                  if (defCallbacks->UnitsCbk) {
                    if (defData->unitsWarnings++ < defSettings->UnitsWarnings) {
                      outMsg = (char*)defMalloc(1000);
!                     snprintf (outMsg, 1000,
                      "An error has been found while processing the DEF file '%s'\nUnit %d is a 5.6 or later syntax. Define the DEF file as 5.6 and then try again.",
                      defSettings->FileName, values);
                      defError(6501, outMsg);
***************
*** 209,215 ****
      if (defCallbacks->UnitsCbk) {
        if (defData->unitsWarnings++ < defSettings->UnitsWarnings) {
          outMsg = (char*)defMalloc(10000);
!         sprintf (outMsg,
            "The value %d defined for DEF UNITS DISTANCE MICRON is invalid\n. The valid values are 100, 200, 400, 800, 1000, 2000, 4000, 8000, 10000, or 20000. Specify a valid value and then try again.", values);
          defError(6502, outMsg);
          defFree(outMsg);
--- 215,221 ----
      if (defCallbacks->UnitsCbk) {
        if (defData->unitsWarnings++ < defSettings->UnitsWarnings) {
          outMsg = (char*)defMalloc(10000);
!         snprintf (outMsg, 10000,
            "The value %d defined for DEF UNITS DISTANCE MICRON is invalid\n. The valid values are 100, 200, 400, 800, 1000, 2000, 4000, 8000, 10000, or 20000. Specify a valid value and then try again.", values);
          defError(6502, outMsg);
          defFree(outMsg);
***************
*** 321,327 ****
          defData->VersionNum = convert_defname2num($3);
          if (defData->VersionNum > CURRENT_VERSION) {
            char temp[300];
!           sprintf(temp,
            "The execution has been stopped because the DEF parser %.1f does not support DEF file with version %s.\nUpdate your DEF file to version 5.8 or earlier.",
                    CURRENT_VERSION, $3);
            defError(6503, temp);
--- 327,333 ----
          defData->VersionNum = convert_defname2num($3);
          if (defData->VersionNum > CURRENT_VERSION) {
            char temp[300];
!           snprintf(temp, 300,
            "The execution has been stopped because the DEF parser %.1f does not support DEF file with version %s.\nUpdate your DEF file to version 5.8 or earlier.",
                    CURRENT_VERSION, $3);
            defError(6503, temp);
***************
*** 416,422 ****
  
              if (!defData->hasVer) {
                char temp[300];
!               sprintf(temp, "No VERSION statement found, using the default value %2g.", defData->VersionNum);
                defWarning(7012, temp);            
              }
              if (!defData->hasNameCase && defData->VersionNum < 5.6)
--- 422,428 ----
  
              if (!defData->hasVer) {
                char temp[300];
!               snprintf(temp, 300, "No VERSION statement found, using the default value %2g.", defData->VersionNum);
                defWarning(7012, temp);            
              }
              if (!defData->hasNameCase && defData->VersionNum < 5.6)
***************
*** 554,560 ****
                if (defData->VersionNum < 5.6) {
                  if (defData->nonDefaultWarnings++ < defSettings->NonDefaultWarnings) {
                    defData->defMsg = (char*)defMalloc(1000); 
!                   sprintf (defData->defMsg,
                       "The NONDEFAULTRULE statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6505, defData->defMsg);
                    defFree(defData->defMsg);
--- 560,566 ----
                if (defData->VersionNum < 5.6) {
                  if (defData->nonDefaultWarnings++ < defSettings->NonDefaultWarnings) {
                    defData->defMsg = (char*)defMalloc(1000); 
!                   snprintf (defData->defMsg, 1000,
                       "The NONDEFAULTRULE statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6505, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 570,581 ****
              }
          | error ';' { yyerrok; yyclearin;}
  
! property_type_and_val: K_INTEGER { defData->real_num = 0 } opt_range opt_num_val
              {
                if (defCallbacks->PropCbk) defData->Prop.setPropInteger();
                defData->defPropDefType = 'I';
              }
!         | K_REAL { defData->real_num = 1 } opt_range opt_num_val
              {
                if (defCallbacks->PropCbk) defData->Prop.setPropReal();
                defData->defPropDefType = 'R';
--- 576,587 ----
              }
          | error ';' { yyerrok; yyclearin;}
  
! property_type_and_val: K_INTEGER { defData->real_num = 0; } opt_range opt_num_val
              {
                if (defCallbacks->PropCbk) defData->Prop.setPropInteger();
                defData->defPropDefType = 'I';
              }
!         | K_REAL { defData->real_num = 1; } opt_range opt_num_val
              {
                if (defCallbacks->PropCbk) defData->Prop.setPropReal();
                defData->defPropDefType = 'R';
***************
*** 758,764 ****
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "The NETEXPR statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6506, defData->defMsg);
                    defFree(defData->defMsg);
--- 764,770 ----
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "The NETEXPR statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6506, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 779,785 ****
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "The SUPPLYSENSITIVITY statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6507, defData->defMsg);
                    defFree(defData->defMsg);
--- 785,791 ----
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "The SUPPLYSENSITIVITY statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6507, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 799,805 ****
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "The GROUNDSENSITIVITY statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6508, defData->defMsg);
                    defFree(defData->defMsg);
--- 805,811 ----
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "The GROUNDSENSITIVITY statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6508, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 823,829 ****
                   if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                       (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                     defData->defMsg = (char*)defMalloc(10000);
!                    sprintf (defData->defMsg,
                       "The PORT in PINS is available in version 5.7 or later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                     defError(6555, defData->defMsg);
                     defFree(defData->defMsg);
--- 829,835 ----
                   if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                       (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                     defData->defMsg = (char*)defMalloc(10000);
!                    snprintf (defData->defMsg, 10000,
                       "The PORT in PINS is available in version 5.7 or later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                     defError(6555, defData->defMsg);
                     defFree(defData->defMsg);
***************
*** 863,869 ****
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "The POLYGON statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6509, defData->defMsg);
                    defFree(defData->defMsg);
--- 869,875 ----
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "The POLYGON statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6509, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 899,905 ****
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "The PIN VIA statement is available in version 5.7 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6556, defData->defMsg);
                    defFree(defData->defMsg);
--- 905,911 ----
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "The PIN VIA statement is available in version 5.7 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6556, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 936,942 ****
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "The ANTENNAPINPARTIALMETALAREA statement is available in version 5.4 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6510, defData->defMsg);
                    defFree(defData->defMsg);
--- 942,948 ----
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "The ANTENNAPINPARTIALMETALAREA statement is available in version 5.4 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6510, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 954,960 ****
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "The ANTENNAPINPARTIALMETALSIDEAREA statement is available in version 5.4 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6511, defData->defMsg);
                    defFree(defData->defMsg);
--- 960,966 ----
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "The ANTENNAPINPARTIALMETALSIDEAREA statement is available in version 5.4 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6511, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 972,978 ****
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "The ANTENNAPINGATEAREA statement is available in version 5.4 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6512, defData->defMsg);
                    defFree(defData->defMsg);
--- 978,984 ----
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "The ANTENNAPINGATEAREA statement is available in version 5.4 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6512, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 990,996 ****
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "The ANTENNAPINDIFFAREA statement is available in version 5.4 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6513, defData->defMsg);
                    defFree(defData->defMsg);
--- 996,1002 ----
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "The ANTENNAPINDIFFAREA statement is available in version 5.4 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6513, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 1008,1014 ****
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "The ANTENNAPINMAXAREACAR statement is available in version 5.4 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6514, defData->defMsg);
                    defFree(defData->defMsg);
--- 1014,1020 ----
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "The ANTENNAPINMAXAREACAR statement is available in version 5.4 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6514, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 1027,1033 ****
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "The ANTENNAPINMAXSIDEAREACAR statement is available in version 5.4 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6515, defData->defMsg);
                    defFree(defData->defMsg);
--- 1033,1039 ----
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "The ANTENNAPINMAXSIDEAREACAR statement is available in version 5.4 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6515, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 1045,1051 ****
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "The ANTENNAPINPARTIALCUTAREA statement is available in version 5.4 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6516, defData->defMsg);
                    defFree(defData->defMsg);
--- 1051,1057 ----
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "The ANTENNAPINPARTIALCUTAREA statement is available in version 5.4 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6516, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 1063,1069 ****
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "The ANTENNAPINMAXCUTCAR statement is available in version 5.4 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6517, defData->defMsg);
                    defFree(defData->defMsg);
--- 1069,1075 ----
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "The ANTENNAPINMAXCUTCAR statement is available in version 5.4 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6517, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 1081,1087 ****
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "The ANTENNAMODEL statement is available in version 5.5 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6518, defData->defMsg);
                    defFree(defData->defMsg);
--- 1087,1093 ----
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "The ANTENNAMODEL statement is available in version 5.5 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6518, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 1136,1142 ****
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "The SPACING statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6519, defData->defMsg);
                    defFree(defData->defMsg);
--- 1142,1148 ----
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "The SPACING statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6519, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 1159,1165 ****
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "DESIGNRULEWIDTH statement is a version 5.6 and later syntax.\nYour def file is defined with version %g", defData->VersionNum);
                    defError(6520, defData->defMsg);
                    defFree(defData->defMsg);
--- 1165,1171 ----
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "DESIGNRULEWIDTH statement is a version 5.6 and later syntax.\nYour def file is defined with version %g", defData->VersionNum);
                    defError(6520, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 1184,1190 ****
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "SPACING statement is a version 5.6 and later syntax.\nYour def file is defined with version %g", defData->VersionNum);
                    defError(6521, defData->defMsg);
                    defFree(defData->defMsg);
--- 1190,1196 ----
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "SPACING statement is a version 5.6 and later syntax.\nYour def file is defined with version %g", defData->VersionNum);
                    defError(6521, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 1207,1213 ****
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "The DESIGNRULEWIDTH statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6520, defData->defMsg);
                    defFree(defData->defMsg);
--- 1213,1219 ----
                  if ((defData->pinWarnings++ < defSettings->PinWarnings) &&
                      (defData->pinWarnings++ < defSettings->PinExtWarnings)) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "The DESIGNRULEWIDTH statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                    defError(6520, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 1316,1322 ****
                  if (defCallbacks->RowCbk) {
                    if (defData->rowWarnings++ < defSettings->RowWarnings) {
                      defData->defMsg = (char*)defMalloc(1000);
!                     sprintf(defData->defMsg,
                              "The DO statement in the ROW statement with the name %s has invalid syntax.\nThe valid syntax is \"DO numX BY 1 STEP spaceX 0 | DO 1 BY numY STEP 0 spaceY\".\nSpecify the valid syntax and try again.", defData->rowName);
                      defWarning(7018, defData->defMsg);
                      defFree(defData->defMsg);
--- 1322,1328 ----
                  if (defCallbacks->RowCbk) {
                    if (defData->rowWarnings++ < defSettings->RowWarnings) {
                      defData->defMsg = (char*)defMalloc(1000);
!                     snprintf(defData->defMsg, 1000,
                              "The DO statement in the ROW statement with the name %s has invalid syntax.\nThe valid syntax is \"DO numX BY 1 STEP spaceX 0 | DO 1 BY numY STEP 0 spaceY\".\nSpecify the valid syntax and try again.", defData->rowName);
                      defWarning(7018, defData->defMsg);
                      defFree(defData->defMsg);
***************
*** 1369,1375 ****
               propTp =  defSettings->RowProp.propType($1);
               CHKPROPTYPE(propTp, $1, "ROW");
               // For backword compatibility, also set the string value 
!              sprintf(str, "%g", $2);
               defData->Row.addNumProperty($1, $2, str, propTp);
            }
          }
--- 1375,1381 ----
               propTp =  defSettings->RowProp.propType($1);
               CHKPROPTYPE(propTp, $1, "ROW");
               // For backword compatibility, also set the string value 
!              snprintf(str, 24, "%g", $2);
               defData->Row.addNumProperty($1, $2, str, propTp);
            }
          }
***************
*** 1404,1410 ****
              if (defCallbacks->TrackCbk)
                if (defData->trackWarnings++ < defSettings->TrackWarnings) {
                  defData->defMsg = (char*)defMalloc(1000);
!                 sprintf (defData->defMsg,
                     "The DO number %g in TRACK is invalid.\nThe number value has to be greater than 0. Specify the valid syntax and try again.", $5);
                  defError(6525, defData->defMsg);
                  defFree(defData->defMsg);
--- 1410,1416 ----
              if (defCallbacks->TrackCbk)
                if (defData->trackWarnings++ < defSettings->TrackWarnings) {
                  defData->defMsg = (char*)defMalloc(1000);
!                 snprintf (defData->defMsg, 1000,
                     "The DO number %g in TRACK is invalid.\nThe number value has to be greater than 0. Specify the valid syntax and try again.", $5);
                  defError(6525, defData->defMsg);
                  defFree(defData->defMsg);
***************
*** 1414,1420 ****
              if (defCallbacks->TrackCbk)
                if (defData->trackWarnings++ < defSettings->TrackWarnings) {
                  defData->defMsg = (char*)defMalloc(1000);
!                 sprintf (defData->defMsg,
                     "The STEP number %g in TRACK is invalid.\nThe number value has to be greater than 0. Specify the valid syntax and try again.", $7);
                  defError(6526, defData->defMsg);
                  defFree(defData->defMsg);
--- 1420,1426 ----
              if (defCallbacks->TrackCbk)
                if (defData->trackWarnings++ < defSettings->TrackWarnings) {
                  defData->defMsg = (char*)defMalloc(1000);
!                 snprintf (defData->defMsg, 1000,
                     "The STEP number %g in TRACK is invalid.\nThe number value has to be greater than 0. Specify the valid syntax and try again.", $7);
                  defError(6526, defData->defMsg);
                  defFree(defData->defMsg);
***************
*** 1475,1481 ****
              if (defCallbacks->GcellGridCbk)
                if (defData->gcellGridWarnings++ < defSettings->GcellGridWarnings) {
                  defData->defMsg = (char*)defMalloc(1000);
!                 sprintf (defData->defMsg,
                     "The DO number %g in GCELLGRID is invalid.\nThe number value has to be greater than 0. Specify the valid syntax and try again.", $5);
                  defError(6527, defData->defMsg);
                  defFree(defData->defMsg);
--- 1481,1487 ----
              if (defCallbacks->GcellGridCbk)
                if (defData->gcellGridWarnings++ < defSettings->GcellGridWarnings) {
                  defData->defMsg = (char*)defMalloc(1000);
!                 snprintf (defData->defMsg, 1000,
                     "The DO number %g in GCELLGRID is invalid.\nThe number value has to be greater than 0. Specify the valid syntax and try again.", $5);
                  defError(6527, defData->defMsg);
                  defFree(defData->defMsg);
***************
*** 1485,1491 ****
              if (defCallbacks->GcellGridCbk)
                if (defData->gcellGridWarnings++ < defSettings->GcellGridWarnings) {
                  defData->defMsg = (char*)defMalloc(1000);
!                 sprintf (defData->defMsg,
                     "The STEP number %g in GCELLGRID is invalid.\nThe number value has to be greater than 0. Specify the valid syntax and try again.", $7);
                  defError(6528, defData->defMsg);
                  defFree(defData->defMsg);
--- 1491,1497 ----
              if (defCallbacks->GcellGridCbk)
                if (defData->gcellGridWarnings++ < defSettings->GcellGridWarnings) {
                  defData->defMsg = (char*)defMalloc(1000);
!                 snprintf (defData->defMsg, 1000,
                     "The STEP number %g in GCELLGRID is invalid.\nThe number value has to be greater than 0. Specify the valid syntax and try again.", $7);
                  defError(6528, defData->defMsg);
                  defFree(defData->defMsg);
***************
*** 1548,1554 ****
                  if (defCallbacks->ViaCbk) {
                    if (defData->viaWarnings++ < defSettings->ViaWarnings) {
                      defData->defMsg = (char*)defMalloc(1000);
!                     sprintf (defData->defMsg,
                         "The POLYGON statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                      defError(6509, defData->defMsg);
                      defFree(defData->defMsg);
--- 1554,1560 ----
                  if (defCallbacks->ViaCbk) {
                    if (defData->viaWarnings++ < defSettings->ViaWarnings) {
                      defData->defMsg = (char*)defMalloc(1000);
!                     snprintf (defData->defMsg, 1000,
                         "The POLYGON statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                      defError(6509, defData->defMsg);
                      defFree(defData->defMsg);
***************
*** 1590,1596 ****
                  if (defCallbacks->ViaCbk) {
                    if (defData->viaWarnings++ < defSettings->ViaWarnings) {
                      defData->defMsg = (char*)defMalloc(1000);
!                     sprintf (defData->defMsg,
                         "The VIARULE statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                      defError(6557, defData->defMsg);
                      defFree(defData->defMsg);
--- 1596,1602 ----
                  if (defCallbacks->ViaCbk) {
                    if (defData->viaWarnings++ < defSettings->ViaWarnings) {
                      defData->defMsg = (char*)defMalloc(1000);
!                     snprintf (defData->defMsg, 1000,
                         "The VIARULE statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                      defError(6557, defData->defMsg);
                      defFree(defData->defMsg);
***************
*** 1777,1783 ****
               // We will use a temporary string to store the number.
               // The string space is borrowed from the ring buffer
               // in the lexer.
!              sprintf(str, "%g", $2);
               defData->Region.addNumProperty($1, $2, str, propTp);
            }
          }
--- 1783,1789 ----
               // We will use a temporary string to store the number.
               // The string space is borrowed from the ring buffer
               // in the lexer.
!              snprintf(str, 24, "%g", $2);
               defData->Region.addNumProperty($1, $2, str, propTp);
            }
          }
***************
*** 1810,1816 ****
             if (defData->VersionNum < 5.8) {
                  if (defData->componentWarnings++ < defSettings->ComponentWarnings) {
                     defData->defMsg = (char*)defMalloc(10000);
!                    sprintf (defData->defMsg,
                       "The MASKSHIFT statement is available in version 5.8 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                     defError(7415, defData->defMsg);
                     defFree(defData->defMsg);
--- 1816,1822 ----
             if (defData->VersionNum < 5.8) {
                  if (defData->componentWarnings++ < defSettings->ComponentWarnings) {
                     defData->defMsg = (char*)defMalloc(10000);
!                    snprintf (defData->defMsg, 10000,
                       "The MASKSHIFT statement is available in version 5.8 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                     defError(7415, defData->defMsg);
                     defFree(defData->defMsg);
***************
*** 1967,1973 ****
               if (defCallbacks->ComponentCbk) {
                 if (defData->componentWarnings++ < defSettings->ComponentWarnings) {
                   defData->defMsg = (char*)defMalloc(1000);
!                  sprintf (defData->defMsg,
                      "The HALO statement is a version 5.6 and later syntax.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                   defError(6529, defData->defMsg);
                   defFree(defData->defMsg);
--- 1973,1979 ----
               if (defCallbacks->ComponentCbk) {
                 if (defData->componentWarnings++ < defSettings->ComponentWarnings) {
                   defData->defMsg = (char*)defMalloc(1000);
!                  snprintf (defData->defMsg, 1000,
                      "The HALO statement is a version 5.6 and later syntax.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                   defError(6529, defData->defMsg);
                   defFree(defData->defMsg);
***************
*** 1990,1996 ****
             if (defCallbacks->ComponentCbk) {
               if (defData->componentWarnings++ < defSettings->ComponentWarnings) {
                  defData->defMsg = (char*)defMalloc(10000);
!                 sprintf (defData->defMsg,
                    "The HALO SOFT is available in version 5.7 or later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                  defError(6550, defData->defMsg);
                  defFree(defData->defMsg);
--- 1996,2002 ----
             if (defCallbacks->ComponentCbk) {
               if (defData->componentWarnings++ < defSettings->ComponentWarnings) {
                  defData->defMsg = (char*)defMalloc(10000);
!                 snprintf (defData->defMsg, 10000,
                    "The HALO SOFT is available in version 5.7 or later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                  defError(6550, defData->defMsg);
                  defFree(defData->defMsg);
***************
*** 2010,2016 ****
             if (defCallbacks->ComponentCbk) {
               if (defData->componentWarnings++ < defSettings->ComponentWarnings) {
                  defData->defMsg = (char*)defMalloc(10000);
!                 sprintf (defData->defMsg,
                    "The ROUTEHALO is available in version 5.7 or later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                  defError(6551, defData->defMsg);
                  defFree(defData->defMsg);
--- 2016,2022 ----
             if (defCallbacks->ComponentCbk) {
               if (defData->componentWarnings++ < defSettings->ComponentWarnings) {
                  defData->defMsg = (char*)defMalloc(10000);
!                 snprintf (defData->defMsg, 10000,
                    "The ROUTEHALO is available in version 5.7 or later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                  defError(6551, defData->defMsg);
                  defFree(defData->defMsg);
***************
*** 2039,2045 ****
              char* str = ringCopy("                       ");
              propTp = defSettings->CompProp.propType($1);
              CHKPROPTYPE(propTp, $1, "COMPONENT");
!             sprintf(str, "%g", $2);
              defData->Component.addNumProperty($1, $2, str, propTp);
            }
          }
--- 2045,2051 ----
              char* str = ringCopy("                       ");
              propTp = defSettings->CompProp.propType($1);
              CHKPROPTYPE(propTp, $1, "COMPONENT");
!             snprintf(str, 24, "%g", $2);
              defData->Component.addNumProperty($1, $2, str, propTp);
            }
          }
***************
*** 2268,2274 ****
              if (defCallbacks->NetCbk) {
                if (defData->netWarnings++ < defSettings->NetWarnings) {
                   defData->defMsg = (char*)defMalloc(1000);
!                  sprintf (defData->defMsg,
                      "The FIXEDBUMP statement is available in version 5.5 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                   defError(6530, defData->defMsg);
                   defFree(defData->defMsg);
--- 2274,2280 ----
              if (defCallbacks->NetCbk) {
                if (defData->netWarnings++ < defSettings->NetWarnings) {
                   defData->defMsg = (char*)defMalloc(1000);
!                  snprintf (defData->defMsg, 1000,
                      "The FIXEDBUMP statement is available in version 5.5 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                   defError(6530, defData->defMsg);
                   defFree(defData->defMsg);
***************
*** 2285,2291 ****
              if (defCallbacks->NetCbk) {
                if (defData->netWarnings++ < defSettings->NetWarnings) {
                   defData->defMsg = (char*)defMalloc(1000);
!                  sprintf (defData->defMsg,
                      "The FREQUENCY statement is a version 5.5 and later syntax.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                   defError(6558, defData->defMsg);
                   defFree(defData->defMsg);
--- 2291,2297 ----
              if (defCallbacks->NetCbk) {
                if (defData->netWarnings++ < defSettings->NetWarnings) {
                   defData->defMsg = (char*)defMalloc(1000);
!                  snprintf (defData->defMsg, 1000,
                      "The FREQUENCY statement is a version 5.5 and later syntax.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                   defError(6558, defData->defMsg);
                   defFree(defData->defMsg);
***************
*** 2432,2438 ****
              char* str = ringCopy("                       ");
              propTp = defSettings->NetProp.propType($1);
              CHKPROPTYPE(propTp, $1, "NET");
!             sprintf(str, "%g", $2);
              defData->Net.addNumProp($1, $2, str, propTp);
            }
          }
--- 2438,2444 ----
              char* str = ringCopy("                       ");
              propTp = defSettings->NetProp.propType($1);
              CHKPROPTYPE(propTp, $1, "NET");
!             snprintf(str, 24, "%g", $2);
              defData->Net.addNumProp($1, $2, str, propTp);
            }
          }
***************
*** 2555,2561 ****
                if (defCallbacks->SNetCbk) {
                  if (defData->sNetWarnings++ < defSettings->SNetWarnings) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "The VIRTUAL statement is available in version 5.8 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                    defError(6536, defData->defMsg);
                    defFree(defData->defMsg);
--- 2561,2567 ----
                if (defCallbacks->SNetCbk) {
                  if (defData->sNetWarnings++ < defSettings->SNetWarnings) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "The VIRTUAL statement is available in version 5.8 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                    defError(6536, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 2572,2578 ****
                if (defCallbacks->SNetCbk) {
                  if (defData->sNetWarnings++ < defSettings->SNetWarnings) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "The RECT statement is available in version 5.8 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                    defError(6536, defData->defMsg);
                    defFree(defData->defMsg);
--- 2578,2584 ----
                if (defCallbacks->SNetCbk) {
                  if (defData->sNetWarnings++ < defSettings->SNetWarnings) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "The RECT statement is available in version 5.8 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                    defError(6536, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 2663,2669 ****
                defCallbacks->SNetCbk) {
              if (defData->netWarnings++ < defSettings->NetWarnings) {
                defData->defMsg = (char*)defMalloc(1000);
!               sprintf (defData->defMsg,
                   "The VIA DO statement is available in version 5.5 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                defError(6532, defData->defMsg);
                defFree(defData->defMsg);
--- 2669,2675 ----
                defCallbacks->SNetCbk) {
              if (defData->netWarnings++ < defSettings->NetWarnings) {
                defData->defMsg = (char*)defMalloc(1000);
!               snprintf (defData->defMsg, 1000,
                   "The VIA DO statement is available in version 5.5 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                defError(6532, defData->defMsg);
                defFree(defData->defMsg);
***************
*** 2697,2703 ****
                defCallbacks->SNetCbk) {
              if (defData->netWarnings++ < defSettings->NetWarnings) {
                defData->defMsg = (char*)defMalloc(1000);
!               sprintf (defData->defMsg,
                   "The VIA DO statement is available in version 5.5 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                defError(6532, defData->defMsg);
                CHKERR();
--- 2703,2709 ----
                defCallbacks->SNetCbk) {
              if (defData->netWarnings++ < defSettings->NetWarnings) {
                defData->defMsg = (char*)defMalloc(1000);
!               snprintf (defData->defMsg, 1000,
                   "The VIA DO statement is available in version 5.5 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                defError(6532, defData->defMsg);
                CHKERR();
***************
*** 2899,2905 ****
                 defCallbacks->SNetCbk)) {
               if (defData->netWarnings++ < defSettings->NetWarnings) {
                 defData->defMsg = (char*)defMalloc(1000);
!                sprintf (defData->defMsg,
                    "The STYLE statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                 defError(6534, defData->defMsg);
                 defFree(defData->defMsg);
--- 2905,2911 ----
                 defCallbacks->SNetCbk)) {
               if (defData->netWarnings++ < defSettings->NetWarnings) {
                 defData->defMsg = (char*)defMalloc(1000);
!                snprintf (defData->defMsg, 1000,
                    "The STYLE statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                 defError(6534, defData->defMsg);
                 defFree(defData->defMsg);
***************
*** 2927,2933 ****
              (defCallbacks->SNetCbk && (defData->netOsnet==2)))) {
              if (defData->netWarnings++ < defSettings->NetWarnings) {
                defData->defMsg = (char*)defMalloc(1000);
!               sprintf (defData->defMsg,
                   "The STYLE statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                defError(6534, defData->defMsg);
                defFree(defData->defMsg);
--- 2933,2939 ----
              (defCallbacks->SNetCbk && (defData->netOsnet==2)))) {
              if (defData->netWarnings++ < defSettings->NetWarnings) {
                defData->defMsg = (char*)defMalloc(1000);
!               snprintf (defData->defMsg, 1000,
                   "The STYLE statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                defError(6534, defData->defMsg);
                defFree(defData->defMsg);
***************
*** 2967,2973 ****
                   if (defData->NeedPathData) {
                     if (defData->fillWarnings++ < defSettings->FillWarnings) {
                       defData->defMsg = (char*)defMalloc(10000);
!                      sprintf (defData->defMsg,
                         "The FILLWIREOPC is available in version 5.7 or later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                       defError(6552, defData->defMsg);
                       defFree(defData->defMsg);
--- 2973,2979 ----
                   if (defData->NeedPathData) {
                     if (defData->fillWarnings++ < defSettings->FillWarnings) {
                       defData->defMsg = (char*)defMalloc(10000);
!                      snprintf (defData->defMsg, 10000,
                         "The FILLWIREOPC is available in version 5.7 or later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                       defError(6552, defData->defMsg);
                       defFree(defData->defMsg);
***************
*** 3011,3017 ****
               } else {
                   if (defCallbacks->SNetCbk) {   // PCR 902306 
                     defData->defMsg = (char*)defMalloc(1024);
!                    sprintf(defData->defMsg, "The SPECIAL NET statement, with type %s, does not have any net statement defined.\nThe DEF parser will ignore this statemnet.", $2);
                     defWarning(7023, defData->defMsg);
                     defFree(defData->defMsg);
                   }
--- 3017,3023 ----
               } else {
                   if (defCallbacks->SNetCbk) {   // PCR 902306 
                     defData->defMsg = (char*)defMalloc(1024);
!                    snprintf(defData->defMsg, 1024, "The SPECIAL NET statement, with type %s, does not have any net statement defined.\nThe DEF parser will ignore this statemnet.", $2);
                     defWarning(7023, defData->defMsg);
                     defFree(defData->defMsg);
                   }
***************
*** 3062,3068 ****
                if (defCallbacks->SNetCbk) {
                  if (defData->sNetWarnings++ < defSettings->SNetWarnings) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "The POLYGON statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                    defError(6535, defData->defMsg);
                    defFree(defData->defMsg);
--- 3068,3074 ----
                if (defCallbacks->SNetCbk) {
                  if (defData->sNetWarnings++ < defSettings->SNetWarnings) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "The POLYGON statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                    defError(6535, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 3103,3109 ****
                if (defCallbacks->SNetCbk) {
                  if (defData->sNetWarnings++ < defSettings->SNetWarnings) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "The RECT statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                    defError(6536, defData->defMsg);
                    defFree(defData->defMsg);
--- 3109,3115 ----
                if (defCallbacks->SNetCbk) {
                  if (defData->sNetWarnings++ < defSettings->SNetWarnings) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "The RECT statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                    defError(6536, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 3136,3142 ****
                if (defCallbacks->SNetCbk) {
                  if (defData->sNetWarnings++ < defSettings->SNetWarnings) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   sprintf (defData->defMsg,
                       "The VIA statement is available in version 5.8 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                    defError(6536, defData->defMsg);
                    defFree(defData->defMsg);
--- 3142,3148 ----
                if (defCallbacks->SNetCbk) {
                  if (defData->sNetWarnings++ < defSettings->SNetWarnings) {
                    defData->defMsg = (char*)defMalloc(1000);
!                   snprintf (defData->defMsg, 1000,
                       "The VIA statement is available in version 5.8 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                    defError(6536, defData->defMsg);
                    defFree(defData->defMsg);
***************
*** 3184,3191 ****
          | '+' K_ESTCAP NUMBER
              { 
                // 11/12/2002 - this is obsolete in 5.5, & will be ignored 
!               if (defData->VersionNum < 5.5)
                   if (defCallbacks->SNetCbk) defData->Net.setCap($3);
                else
                   defWarning(7024, "The ESTCAP statement is obsolete in version 5.5 and later.\nThe DEF parser will ignore this statement.");
              }
--- 3190,3198 ----
          | '+' K_ESTCAP NUMBER
              { 
                // 11/12/2002 - this is obsolete in 5.5, & will be ignored 
!               if (defData->VersionNum < 5.5) {
                   if (defCallbacks->SNetCbk) defData->Net.setCap($3);
+               }
                else
                   defWarning(7024, "The ESTCAP statement is obsolete in version 5.5 and later.\nThe DEF parser will ignore this statement.");
              }
***************
*** 3219,3225 ****
                  if (defCallbacks->SNetCbk) {
                      if (defData->VersionNum < 5.8) { 
                          defData->defMsg = (char*)defMalloc(1024);
!                         sprintf(defData->defMsg, "The SPECIAL NET SHIELD statement doesn't have routing points definition.\nWill be ignored.");
                          defWarning(7025, defData->defMsg);
                          defFree(defData->defMsg);
                      } else {  // CCR 1244433
--- 3226,3232 ----
                  if (defCallbacks->SNetCbk) {
                      if (defData->VersionNum < 5.8) { 
                          defData->defMsg = (char*)defMalloc(1024);
!                         snprintf(defData->defMsg, 1024, "The SPECIAL NET SHIELD statement doesn't have routing points definition.\nWill be ignored.");
                          defWarning(7025, defData->defMsg);
                          defFree(defData->defMsg);
                      } else {  // CCR 1244433
***************
*** 3287,3294 ****
  snet_width: '+' K_WIDTH { defData->dumb_mode = 1; } T_STRING NUMBER
              {
                // 11/12/2002 - this is obsolete in 5.5, & will be ignored 
!               if (defData->VersionNum < 5.5)
                   if (defCallbacks->SNetCbk) defData->Net.setWidth($4, $5);
                else
                   defWarning(7026, "The WIDTH statement is obsolete in version 5.5 and later.\nThe DEF parser will ignore this statement.");
              }
--- 3294,3302 ----
  snet_width: '+' K_WIDTH { defData->dumb_mode = 1; } T_STRING NUMBER
              {
                // 11/12/2002 - this is obsolete in 5.5, & will be ignored 
!               if (defData->VersionNum < 5.5) {
                   if (defCallbacks->SNetCbk) defData->Net.setWidth($4, $5);
+               }
                else
                   defWarning(7026, "The WIDTH statement is obsolete in version 5.5 and later.\nThe DEF parser will ignore this statement.");
              }
***************
*** 3301,3307 ****
                   if (defCallbacks->SNetCbk) {
                     if (defData->sNetWarnings++ < defSettings->SNetWarnings) {
                       defData->defMsg = (char*)defMalloc(1000);
!                      sprintf (defData->defMsg,
                          "The value %s for statement VOLTAGE is invalid. The value can only be integer.\nSpecify a valid value in units of millivolts", $4);
                       defError(6537, defData->defMsg);
                       defFree(defData->defMsg);
--- 3309,3315 ----
                   if (defCallbacks->SNetCbk) {
                     if (defData->sNetWarnings++ < defSettings->SNetWarnings) {
                       defData->defMsg = (char*)defMalloc(1000);
!                      snprintf (defData->defMsg, 1000,
                          "The value %s for statement VOLTAGE is invalid. The value can only be integer.\nSpecify a valid value in units of millivolts", $4);
                       defError(6537, defData->defMsg);
                       defFree(defData->defMsg);
***************
*** 3331,3337 ****
                  propTp = defSettings->SNetProp.propType($1);
                  CHKPROPTYPE(propTp, $1, "SPECIAL NET");
                  // For backword compatibility, also set the string value 
!                 sprintf(str, "%g", $2);
                  defData->Net.addNumProp($1, $2, str, propTp);
                }
              }
--- 3339,3345 ----
                  propTp = defSettings->SNetProp.propType($1);
                  CHKPROPTYPE(propTp, $1, "SPECIAL NET");
                  // For backword compatibility, also set the string value 
!                 snprintf(str, 24, "%g", $2);
                  defData->Net.addNumProp($1, $2, str, propTp);
                }
              }
***************
*** 3532,3538 ****
            char* str = ringCopy("                       ");
            propTp = defSettings->GroupProp.propType($1);
            CHKPROPTYPE(propTp, $1, "GROUP");
!           sprintf(str, "%g", $2);
            defData->Group.addNumProperty($1, $2, str, propTp);
          }
        }
--- 3540,3546 ----
            char* str = ringCopy("                       ");
            propTp = defSettings->GroupProp.propType($1);
            CHKPROPTYPE(propTp, $1, "GROUP");
!           snprintf(str, 24, "%g", $2);
            defData->Group.addNumProperty($1, $2, str, propTp);
          }
        }
***************
*** 3562,3585 ****
  group_soft_option: K_MAXX NUMBER
        {
          // 11/12/2002 - this is obsolete in 5.5, & will be ignored 
!         if (defData->VersionNum < 5.5)
            if (defCallbacks->GroupCbk) defData->Group.setMaxX(ROUND($2));
          else
            defWarning(7028, "The GROUP SOFT MAXX statement is obsolete in version 5.5 and later.\nThe DEF parser will ignore this statement.");
        }
        | K_MAXY NUMBER
        { 
          // 11/12/2002 - this is obsolete in 5.5, & will be ignored 
!         if (defData->VersionNum < 5.5)
            if (defCallbacks->GroupCbk) defData->Group.setMaxY(ROUND($2));
          else
            defWarning(7029, "The GROUP SOFT MAXY statement is obsolete in version 5.5 and later.\nThe DEF parser will ignore this statement.");
        }
        | K_MAXHALFPERIMETER NUMBER
        { 
          // 11/12/2002 - this is obsolete in 5.5, & will be ignored 
!         if (defData->VersionNum < 5.5)
            if (defCallbacks->GroupCbk) defData->Group.setPerim(ROUND($2));
          else
            defWarning(7030, "The GROUP SOFT MAXHALFPERIMETER statement is obsolete in version 5.5 and later.\nThe DEF parser will ignore this statement.");
        }
--- 3570,3596 ----
  group_soft_option: K_MAXX NUMBER
        {
          // 11/12/2002 - this is obsolete in 5.5, & will be ignored 
!         if (defData->VersionNum < 5.5) {
            if (defCallbacks->GroupCbk) defData->Group.setMaxX(ROUND($2));
+         }
          else
            defWarning(7028, "The GROUP SOFT MAXX statement is obsolete in version 5.5 and later.\nThe DEF parser will ignore this statement.");
        }
        | K_MAXY NUMBER
        { 
          // 11/12/2002 - this is obsolete in 5.5, & will be ignored 
!         if (defData->VersionNum < 5.5) {
            if (defCallbacks->GroupCbk) defData->Group.setMaxY(ROUND($2));
+         }
          else
            defWarning(7029, "The GROUP SOFT MAXY statement is obsolete in version 5.5 and later.\nThe DEF parser will ignore this statement.");
        }
        | K_MAXHALFPERIMETER NUMBER
        { 
          // 11/12/2002 - this is obsolete in 5.5, & will be ignored 
!         if (defData->VersionNum < 5.5) {
            if (defCallbacks->GroupCbk) defData->Group.setPerim(ROUND($2));
+         }
          else
            defWarning(7030, "The GROUP SOFT MAXHALFPERIMETER statement is obsolete in version 5.5 and later.\nThe DEF parser will ignore this statement.");
        }
***************
*** 3804,3810 ****
            if (defCallbacks->ScanchainCbk) {
              if (defData->scanchainWarnings++ < defSettings->ScanchainWarnings) {
                defData->defMsg = (char*)defMalloc(1000);
!               sprintf (defData->defMsg,
                   "The PARTITION statement is available in version 5.5 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                defError(6538, defData->defMsg);
                defFree(defData->defMsg);
--- 3815,3821 ----
            if (defCallbacks->ScanchainCbk) {
              if (defData->scanchainWarnings++ < defSettings->ScanchainWarnings) {
                defData->defMsg = (char*)defMalloc(1000);
!               snprintf (defData->defMsg, 1000,
                   "The PARTITION statement is available in version 5.5 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                defError(6538, defData->defMsg);
                defFree(defData->defMsg);
***************
*** 4478,4484 ****
            char* str = ringCopy("                       ");
            propTp = defSettings->CompPinProp.propType($1);
            CHKPROPTYPE(propTp, $1, "PINPROPERTIES");
!           sprintf(str, "%g", $2);
            defData->PinProp.addNumProperty($1, $2, str, propTp);
          }
        }
--- 4489,4495 ----
            char* str = ringCopy("                       ");
            propTp = defSettings->CompPinProp.propType($1);
            CHKPROPTYPE(propTp, $1, "PINPROPERTIES");
!           snprintf(str, 24, "%g", $2);
            defData->PinProp.addNumProperty($1, $2, str, propTp);
          }
        }
***************
*** 4570,4576 ****
            if (defCallbacks->BlockageCbk) {
              if (defData->blockageWarnings++ < defSettings->BlockageWarnings) {
                defData->defMsg = (char*)defMalloc(1000);
!               sprintf (defData->defMsg,
                   "The SPACING statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                defError(6540, defData->defMsg);
                defFree(defData->defMsg);
--- 4581,4587 ----
            if (defCallbacks->BlockageCbk) {
              if (defData->blockageWarnings++ < defSettings->BlockageWarnings) {
                defData->defMsg = (char*)defMalloc(1000);
!               snprintf (defData->defMsg, 1000,
                   "The SPACING statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                defError(6540, defData->defMsg);
                defFree(defData->defMsg);
***************
*** 4710,4716 ****
             if (defCallbacks->BlockageCbk) {
               if (defData->blockageWarnings++ < defSettings->BlockageWarnings) {
                 defData->defMsg = (char*)defMalloc(10000);
!                sprintf (defData->defMsg,
                   "The EXCEPTPGNET is available in version 5.7 or later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                 defError(6549, defData->defMsg);
                 defFree(defData->defMsg);
--- 4721,4727 ----
             if (defCallbacks->BlockageCbk) {
               if (defData->blockageWarnings++ < defSettings->BlockageWarnings) {
                 defData->defMsg = (char*)defMalloc(10000);
!                snprintf (defData->defMsg, 10000,
                   "The EXCEPTPGNET is available in version 5.7 or later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                 defError(6549, defData->defMsg);
                 defFree(defData->defMsg);
***************
*** 4784,4790 ****
             if (defCallbacks->BlockageCbk) {
               if (defData->blockageWarnings++ < defSettings->BlockageWarnings) {
                 defData->defMsg = (char*)defMalloc(10000);
!                sprintf (defData->defMsg,
                   "The PLACEMENT SOFT is available in version 5.7 or later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                 defError(6547, defData->defMsg);
                 defFree(defData->defMsg);
--- 4795,4801 ----
             if (defCallbacks->BlockageCbk) {
               if (defData->blockageWarnings++ < defSettings->BlockageWarnings) {
                 defData->defMsg = (char*)defMalloc(10000);
!                snprintf (defData->defMsg, 10000,
                   "The PLACEMENT SOFT is available in version 5.7 or later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                 defError(6547, defData->defMsg);
                 defFree(defData->defMsg);
***************
*** 4818,4824 ****
             if (defCallbacks->BlockageCbk) {
               if (defData->blockageWarnings++ < defSettings->BlockageWarnings) {
                  defData->defMsg = (char*)defMalloc(10000);
!                 sprintf (defData->defMsg,
                    "The PARTIAL is available in version 5.7 or later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                  defError(6548, defData->defMsg);
                  defFree(defData->defMsg);
--- 4829,4835 ----
             if (defCallbacks->BlockageCbk) {
               if (defData->blockageWarnings++ < defSettings->BlockageWarnings) {
                  defData->defMsg = (char*)defMalloc(10000);
!                 snprintf (defData->defMsg, 10000,
                    "The PARTIAL is available in version 5.7 or later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                  defError(6548, defData->defMsg);
                  defFree(defData->defMsg);
***************
*** 4995,5001 ****
              defData->Fill.addPolygon(&defData->Geometries);
          } else {
              defData->defMsg = (char*)defMalloc(10000);
!             sprintf (defData->defMsg,
                "POLYGON statement in FILLS LAYER is a version 5.6 and later syntax.\nYour def file is defined with version %g.", defData->VersionNum);
              defError(6564, defData->defMsg);
              defFree(defData->defMsg);
--- 5006,5012 ----
              defData->Fill.addPolygon(&defData->Geometries);
          } else {
              defData->defMsg = (char*)defMalloc(10000);
!             snprintf (defData->defMsg, 10000,
                "POLYGON statement in FILLS LAYER is a version 5.6 and later syntax.\nYour def file is defined with version %g.", defData->VersionNum);
              defError(6564, defData->defMsg);
              defFree(defData->defMsg);
***************
*** 5018,5024 ****
             if (defCallbacks->FillCbk) {
               if (defData->fillWarnings++ < defSettings->FillWarnings) {
                 defData->defMsg = (char*)defMalloc(10000);
!                sprintf (defData->defMsg,
                   "The LAYER OPC is available in version 5.7 or later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                 defError(6553, defData->defMsg);
                 defFree(defData->defMsg);
--- 5029,5035 ----
             if (defCallbacks->FillCbk) {
               if (defData->fillWarnings++ < defSettings->FillWarnings) {
                 defData->defMsg = (char*)defMalloc(10000);
!                snprintf (defData->defMsg, 10000,
                   "The LAYER OPC is available in version 5.7 or later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                 defError(6553, defData->defMsg);
                 defFree(defData->defMsg);
***************
*** 5056,5062 ****
             if (defCallbacks->FillCbk) {
               if (defData->fillWarnings++ < defSettings->FillWarnings) {
                 defData->defMsg = (char*)defMalloc(10000);
!                sprintf (defData->defMsg,
                   "The VIA OPC is available in version 5.7 or later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                 defError(6554, defData->defMsg);
                 defFree(defData->defMsg);
--- 5067,5073 ----
             if (defCallbacks->FillCbk) {
               if (defData->fillWarnings++ < defSettings->FillWarnings) {
                 defData->defMsg = (char*)defMalloc(10000);
!                snprintf (defData->defMsg, 10000,
                   "The VIA OPC is available in version 5.7 or later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                 defError(6554, defData->defMsg);
                 defFree(defData->defMsg);
***************
*** 5099,5105 ****
            if (defCallbacks->NonDefaultStartCbk) {
              if (defData->nonDefaultWarnings++ < defSettings->NonDefaultWarnings) {
                defData->defMsg = (char*)defMalloc(1000);
!               sprintf (defData->defMsg,
                   "The NONDEFAULTRULE statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                defError(6545, defData->defMsg);
                defFree(defData->defMsg);
--- 5110,5116 ----
            if (defCallbacks->NonDefaultStartCbk) {
              if (defData->nonDefaultWarnings++ < defSettings->NonDefaultWarnings) {
                defData->defMsg = (char*)defMalloc(1000);
!               snprintf (defData->defMsg, 1000,
                   "The NONDEFAULTRULE statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g.", defData->VersionNum);
                defError(6545, defData->defMsg);
                defFree(defData->defMsg);
***************
*** 5208,5214 ****
            char* str = ringCopy("                       ");
            propTp = defSettings->NDefProp.propType($1);
            CHKPROPTYPE(propTp, $1, "NONDEFAULTRULE");
!           sprintf(str, "%g", $2);
            defData->NonDefault.addNumProperty($1, $2, str, propTp);
          }
        }
--- 5219,5225 ----
            char* str = ringCopy("                       ");
            propTp = defSettings->NDefProp.propType($1);
            CHKPROPTYPE(propTp, $1, "NONDEFAULTRULE");
!           snprintf(str, 24, "%g", $2);
            defData->NonDefault.addNumProperty($1, $2, str, propTp);
          }
        }
***************
*** 5240,5246 ****
            if (defCallbacks->StylesStartCbk) {
              if (defData->stylesWarnings++ < defSettings->StylesWarnings) {
                defData->defMsg = (char*)defMalloc(1000);
!               sprintf (defData->defMsg,
                   "The STYLES statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                defError(6546, defData->defMsg);
                defFree(defData->defMsg);
--- 5251,5257 ----
            if (defCallbacks->StylesStartCbk) {
              if (defData->stylesWarnings++ < defSettings->StylesWarnings) {
                defData->defMsg = (char*)defMalloc(1000);
!               snprintf (defData->defMsg, 1000,
                   "The STYLES statement is available in version 5.6 and later.\nHowever, your DEF file is defined with version %g", defData->VersionNum);
                defError(6546, defData->defMsg);
                defFree(defData->defMsg);
diff -r -c source.lefdef/def.orig/defdiff/diffDefRW.cpp def/defdiff/diffDefRW.cpp
*** source.lefdef/def.orig/defdiff/diffDefRW.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/defdiff/diffDefRW.cpp	2024-07-21 11:56:04.014547929 -0700
***************
*** 91,97 ****
    checkType(c);
    if (ud != userData) dataError();
  
!     if (co->numMaskShiftLayers()) {
  	fprintf(fout, "\nCOMPONENTMASKSHIFT ");
  	
  	for (i = 0; i < co->numMaskShiftLayers(); i++) {
--- 91,97 ----
    checkType(c);
    if (ud != userData) dataError();
  
!     if (co && co->numMaskShiftLayers()) {
  	fprintf(fout, "\nCOMPONENTMASKSHIFT ");
  	
  	for (i = 0; i < co->numMaskShiftLayers(); i++) {
***************
*** 169,176 ****
      if (co->maskShiftSize()) {
  	fprintf(fout, "MASKSHIFT ");
  
!         for (int i = co->maskShiftSize()-1; i >= 0; i--) {
!             fprintf(fout, "%d", co->maskShift(i));
          }
          fprintf(fout, "\n");
      }
--- 169,176 ----
      if (co->maskShiftSize()) {
  	fprintf(fout, "MASKSHIFT ");
  
!         for (int ix = co->maskShiftSize()-1; ix >= 0; ix--) {
!             fprintf(fout, "%d", co->maskShift(ix));
          }
          fprintf(fout, "\n");
      }
***************
*** 202,208 ****
  // Net
  int netf(defrCallbackType_e c, defiNet* net, defiUserData ud) {
    // For net and special net.
!   int         i, j, k, w, x, y, z, px, py, pz;
    defiPath*   p;
    defiSubnet* s;
    int         path;
--- 202,208 ----
  // Net
  int netf(defrCallbackType_e c, defiNet* net, defiUserData ud) {
    // For net and special net.
!   int         i, j, k, w, x, y, z, px = 0, py = 0, pz = 0;
    defiPath*   p;
    defiSubnet* s;
    int         path;
***************
*** 488,493 ****
--- 488,494 ----
                                   net->name(), layerName, x, y);
                           nline = 1;
                        }
+                       break;
                   case DEFIPATH_TAPER:
                        fprintf(fout, " TAPER");
                        break;
***************
*** 630,636 ****
    int        path;
    defiShield* shield;
    defiWire   *wire;
!   int        nline;
    const char* sNLayerName = "N/A";
    int        numX, numY, stepX, stepY;
  
--- 631,637 ----
    int        path;
    defiShield* shield;
    defiWire   *wire;
!   int        nline = 0;
    const char* sNLayerName = "N/A";
    int        numX, numY, stepX, stepY;
  
***************
*** 691,697 ****
           }
        }
        if (net->polyMask(i)) {
! 	  fprintf(fout, "MASK %d POLYGON % s ", 
  		  net->polyMask(i),
  		  net->polygonName(i));
        } else {
--- 692,698 ----
           }
        }
        if (net->polyMask(i)) {
! 	  fprintf(fout, "MASK %d POLYGON %s ", 
  		  net->polyMask(i),
  		  net->polygonName(i));
        } else {
***************
*** 728,735 ****
        
         defiPoints points = net->getViaPts(i);
  
!        for (int j = 0; j < points.numPoints; j++) {
!           fprintf(fout, " %d %d", points.x[j], points.y[j]);
         }
         fprintf(fout, ";\n"); 
       }
--- 729,736 ----
        
         defiPoints points = net->getViaPts(i);
  
!        for (int jx = 0; jx < points.numPoints; jx++) {
!           fprintf(fout, " %d %d", points.x[jx], points.y[jx]);
         }
         fprintf(fout, ";\n"); 
       }
***************
*** 1232,1240 ****
    checkType(c);
    if (ud != userData) dataError();
    if (d == 1)
!      fprintf(fout, "NAMESCASESENSITIVE OFF\n", d);
    else
!      fprintf(fout, "NAMESCASESENSITIVE ON\n", d);
    return 0;
  }
  
--- 1233,1241 ----
    checkType(c);
    if (ud != userData) dataError();
    if (d == 1)
!      fprintf(fout, "NAMESCASESENSITIVE OFF\n");
    else
!      fprintf(fout, "NAMESCASESENSITIVE ON\n");
    return 0;
  }
  
***************
*** 1425,1431 ****
           fprintf(fout, "\n");
  
           if (pin->hasPort()) {
!              struct defiPoints points;
               defiPinPort* port;
               for (j = 0; j < pin->numPorts(); j++) {
                  fprintf(fout, "PIN %s", tmpPinName);
--- 1426,1432 ----
           fprintf(fout, "\n");
  
           if (pin->hasPort()) {
! //             struct defiPoints points;
               defiPinPort* port;
               for (j = 0; j < pin->numPorts(); j++) {
                  fprintf(fout, "PIN %s", tmpPinName);
***************
*** 1594,1600 ****
           --numObjs;
           break;
    case defrDefaultCapCbkType :
!          i = (long)cl;
           fprintf(fout, "DEFAULTCAP %d\n", i);
           numObjs = i;
           break;
--- 1595,1601 ----
           --numObjs;
           break;
    case defrDefaultCapCbkType :
!          i = (intptr_t)cl;
           fprintf(fout, "DEFAULTCAP %d\n", i);
           numObjs = i;
           break;
***************
*** 1697,1703 ****
           }
  	 // POLYGON
           if (via->numPolygons()) {
!            struct defiPoints points;
             for (i = 0; i < via->numPolygons(); i++) {
  	     int polyMask = via->polyMask(i);
  
--- 1698,1704 ----
           }
  	 // POLYGON
           if (via->numPolygons()) {
! //           struct defiPoints points;
             for (i = 0; i < via->numPolygons(); i++) {
  	     int polyMask = via->polyMask(i);
  
***************
*** 1715,1727 ****
           }
  
           if (via->hasViaRule()) {
!              char *vrn, *bl, *cl, *tl;
               int xs, ys, xcs, ycs, xbe, ybe, xte, yte;
               int cr, cc, xo, yo, xbo, ybo, xto, yto;
!              (void)via->viaRule(&vrn, &xs, &ys, &bl, &cl, &tl, &xcs,
                                           &ycs, &xbe, &ybe, &xte, &yte);
               fprintf(fout, "VIA %s VIARULE %s CUTSIZE %d %d LAYERS %s %s %s",
!                      via->name(), vrn, xs, ys, bl, cl, tl);
               fprintf(fout, " CUTSPACING %d %d ENCLOSURE %d %d %d %d", xcs, ycs,
                       xbe, ybe, xte, yte);
               if (via->hasRowCol()) {
--- 1716,1728 ----
           }
  
           if (via->hasViaRule()) {
!              char *vrn, *bl, *tcl, *tl;
               int xs, ys, xcs, ycs, xbe, ybe, xte, yte;
               int cr, cc, xo, yo, xbo, ybo, xto, yto;
!              (void)via->viaRule(&vrn, &xs, &ys, &bl, &tcl, &tl, &xcs,
                                           &ycs, &xbe, &ybe, &xte, &yte);
               fprintf(fout, "VIA %s VIARULE %s CUTSIZE %d %d LAYERS %s %s %s",
!                      via->name(), vrn, xs, ys, bl, tcl, tl);
               fprintf(fout, " CUTSPACING %d %d ENCLOSURE %d %d %d %d", xcs, ycs,
                       xbe, ybe, xte, yte);
               if (via->hasRowCol()) {
***************
*** 1769,1777 ****
               fprintf(fout, "REGION %s ", group->regionName());
           if (group->hasRegionBox()) {
               int *gxl, *gyl, *gxh, *gyh;
!              int size;
!              group->regionRects(&size, &gxl, &gyl, &gxh, &gyh);
!              for (i = 0; i < size; i++)
                   fprintf(fout, "REGION (%d %d) (%d %d) ", gxl[i], gyl[i],
                           gxh[i], gyh[i]);
           }
--- 1770,1778 ----
               fprintf(fout, "REGION %s ", group->regionName());
           if (group->hasRegionBox()) {
               int *gxl, *gyl, *gxh, *gyh;
!              int tsize;
!              group->regionRects(&tsize, &gxl, &gyl, &gxh, &gyh);
!              for (i = 0; i < tsize; i++)
                   fprintf(fout, "REGION (%d %d) (%d %d) ", gxl[i], gyl[i],
                           gxh[i], gyh[i]);
           }
***************
*** 1779,1805 ****
           --numObjs;
           break;
    case defrComponentMaskShiftLayerCbkType :
! 	 fprintf(fout, "COMPONENTMASKSHIFT ");
          
!         for (i = 0; i < maskShiftLayer->numMaskShiftLayers(); i++) {
!            fprintf(fout, "%s ", maskShiftLayer->maskShiftLayer(i));
!         } 
!         fprintf(fout, ";\n");
  	 break;
    case defrScanchainCbkType :
           sc = (defiScanchain*)cl;
           fprintf(fout, "SCANCHAINS %s", sc->name());
           if (sc->hasStart()) {
               sc->start(&a1, &b1);
!              fprintf(fout, " START %s %s", sc->name(), a1, b1);
           }
           if (sc->hasStop()) {
               sc->stop(&a1, &b1);
!              fprintf(fout, " STOP %s %s", sc->name(), a1, b1);
           }
           if (sc->hasCommonInPin() ||
               sc->hasCommonOutPin()) {
!              fprintf(fout, " COMMONSCANPINS ", sc->name());
               if (sc->hasCommonInPin())
                  fprintf(fout, " ( IN %s )", sc->commonInPin());
               if (sc->hasCommonOutPin())
--- 1780,1808 ----
           --numObjs;
           break;
    case defrComponentMaskShiftLayerCbkType :
!          if (maskShiftLayer && maskShiftLayer->numMaskShiftLayers()) {
! 	     fprintf(fout, "COMPONENTMASKSHIFT ");
          
!              for (i = 0; i < maskShiftLayer->numMaskShiftLayers(); i++) {
!                  fprintf(fout, "%s ", maskShiftLayer->maskShiftLayer(i));
!              } 
!          }
!          fprintf(fout, ";\n");
  	 break;
    case defrScanchainCbkType :
           sc = (defiScanchain*)cl;
           fprintf(fout, "SCANCHAINS %s", sc->name());
           if (sc->hasStart()) {
               sc->start(&a1, &b1);
!              fprintf(fout, " START %s %s %s", sc->name(), a1, b1);
           }
           if (sc->hasStop()) {
               sc->stop(&a1, &b1);
!              fprintf(fout, " STOP %s %s %s", sc->name(), a1, b1);
           }
           if (sc->hasCommonInPin() ||
               sc->hasCommonOutPin()) {
!              fprintf(fout, " COMMONSCANPINS %s ", sc->name());
               if (sc->hasCommonInPin())
                  fprintf(fout, " ( IN %s )", sc->commonInPin());
               if (sc->hasCommonOutPin())
***************
*** 1914,1926 ****
           break;
    case defrTimingDisableCbkType :
           td = (defiTimingDisable*)cl;
!          if (td->hasFromTo()) fprintf(fout, "TIMINGDISABLE FROMPIN %s %s ", td->fromInst(), td->fromPin(), td->toInst(), td->toPin()); if (td->hasThru())
               fprintf(fout, " THRUPIN %s %s ", td->thruInst(), td->thruPin());
           if (td->hasMacroFromTo())
               fprintf(fout, " MACRO %s FROMPIN %s %s ", td->macroName(),
                       td->fromPin(), td->toPin());
           if (td->hasMacroThru())
!              fprintf(fout, " MACRO %s THRUPIN %s %s ", td->macroName(),
                       td->fromPin());
           fprintf(fout, "\n");
           break;
--- 1917,1931 ----
           break;
    case defrTimingDisableCbkType :
           td = (defiTimingDisable*)cl;
!          if (td->hasFromTo()) fprintf(fout, "TIMINGDISABLE FROMPIN %s %s %s %s ",
!              td->fromInst(), td->fromPin(), td->toInst(), td->toPin());
!          if (td->hasThru())
               fprintf(fout, " THRUPIN %s %s ", td->thruInst(), td->thruPin());
           if (td->hasMacroFromTo())
               fprintf(fout, " MACRO %s FROMPIN %s %s ", td->macroName(),
                       td->fromPin(), td->toPin());
           if (td->hasMacroThru())
!              fprintf(fout, " MACRO %s THRUPIN %s ", td->macroName(),
                       td->fromPin());
           fprintf(fout, "\n");
           break;
***************
*** 2061,2067 ****
                      slot->xh(i), slot->yh(i));
           }
           for (i = 0; i < slot->numPolygons(); i++) {
!             fprintf(fout, "SLOT LAYER %s POLYGON");
              points = slot->getPolygon(i);
              for (j = 0; j < points.numPoints; j++)
                fprintf(fout, " %d %d", points.x[j], points.y[j]);
--- 2066,2072 ----
                      slot->xh(i), slot->yh(i));
           }
           for (i = 0; i < slot->numPolygons(); i++) {
!             fprintf(fout, "SLOT LAYER %s POLYGON", slot->layerName());
              points = slot->getPolygon(i);
              for (j = 0; j < points.numPoints; j++)
                fprintf(fout, " %d %d", points.x[j], points.y[j]);
***************
*** 2112,2118 ****
           break;
  
    case defrStylesCbkType :
!          struct defiPoints points;
           styles = (defiStyles*)cl;
           fprintf(fout, "STYLE %d", styles->style());
           points = styles->getPolygon();
--- 2117,2123 ----
           break;
  
    case defrStylesCbkType :
! //         struct defiPoints points;
           styles = (defiStyles*)cl;
           fprintf(fout, "STYLE %d", styles->style());
           points = styles->getPolygon();
***************
*** 2163,2169 ****
  int diffDefReadFile(char* inFile, char* outFile, char* ignorePinExtra,
                   char* ignoreRowName, char* ignoreViaName, char* netSegComp) {
    FILE* f;
!   int   res;
  
    userData = (void*)0x01020304;
    defrInit();
--- 2168,2174 ----
  int diffDefReadFile(char* inFile, char* outFile, char* ignorePinExtra,
                   char* ignoreRowName, char* ignoreViaName, char* netSegComp) {
    FILE* f;
!   int   res = 0;
  
    userData = (void*)0x01020304;
    defrInit();
***************
*** 2210,2216 ****
    defrSetPinCapCbk((defrPinCapCbkFnType)cls);
    defrSetPinCbk((defrPinCbkFnType)cls);
    defrSetPinPropCbk((defrPinPropCbkFnType)cls);
!   defrSetDefaultCapCbk((defrIntegerCbkFnType)cls);
    defrSetRowCbk((defrRowCbkFnType)cls);
    defrSetTrackCbk((defrTrackCbkFnType)cls);
    defrSetGcellGridCbk((defrGcellGridCbkFnType)cls);
--- 2215,2221 ----
    defrSetPinCapCbk((defrPinCapCbkFnType)cls);
    defrSetPinCbk((defrPinCbkFnType)cls);
    defrSetPinPropCbk((defrPinPropCbkFnType)cls);
!   defrSetDefaultCapCbk((defrIntegerCbkFnType)(void*)cls);
    defrSetRowCbk((defrRowCbkFnType)cls);
    defrSetTrackCbk((defrTrackCbkFnType)cls);
    defrSetGcellGridCbk((defrGcellGridCbkFnType)cls);
***************
*** 2254,2258 ****
    fclose(f);
    fclose(fout);
  
!   return 0;
  }
--- 2259,2263 ----
    fclose(f);
    fclose(fout);
  
!   return res;
  }
diff -r -c source.lefdef/def.orig/defdiff/differDef.cpp def/defdiff/differDef.cpp
*** source.lefdef/def.orig/defdiff/differDef.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/defdiff/differDef.cpp	2020-12-30 16:46:37.000000000 -0800
***************
*** 48,56 ****
  #endif
  #ifndef WIN32
  #   include <unistd.h>
! extern char VersionIdent[];
! #else
! char* VersionIdent = "N/A";
  #endif /* not WIN32 */
  #include "defrReader.hpp"
  #include "diffDefRW.hpp"
--- 48,56 ----
  #endif
  #ifndef WIN32
  #   include <unistd.h>
! //extern char VersionIdent[];
! //#else
! //char* VersionIdent = "N/A";
  #endif /* not WIN32 */
  #include "defrReader.hpp"
  #include "diffDefRW.hpp"
diff -r -c source.lefdef/def.orig/defrw/defrw.cpp def/defrw/defrw.cpp
*** source.lefdef/def.orig/defrw/defrw.cpp	2016-02-05 14:39:14.000000000 -0800
--- def/defrw/defrw.cpp	2024-07-21 11:59:12.409632253 -0700
***************
*** 77,90 ****
  }
  
  
! int done(defrCallbackType_e c, void* dummy, defiUserData ud) {
    checkType(c);
    if (ud != userData) dataError();
    fprintf(fout, "END DESIGN\n");
    return 0;
  }
  
! int endfunc(defrCallbackType_e c, void* dummy, defiUserData ud) {
    checkType(c);
    if (ud != userData) dataError();
    return 0;
--- 77,90 ----
  }
  
  
! int done(defrCallbackType_e c, void* , defiUserData ud) {
    checkType(c);
    if (ud != userData) dataError();
    fprintf(fout, "END DESIGN\n");
    return 0;
  }
  
! int endfunc(defrCallbackType_e c, void* , defiUserData ud) {
    checkType(c);
    if (ud != userData) dataError();
    return 0;
***************
*** 111,121 ****
    checkType(c);
    if (ud != userData) dataError();
  
!     if (co->numMaskShiftLayers()) {
  	fprintf(fout, "\nCOMPONENTMASKSHIFT ");
  	
  	for (i = 0; i < co->numMaskShiftLayers(); i++) {
!            fprintf(fout, "%s ", co->maskShiftLayer(i));
  	}
  	fprintf(fout, ";\n");
      }
--- 111,121 ----
    checkType(c);
    if (ud != userData) dataError();
  
!     if (co && co->numMaskShiftLayers()) {
  	fprintf(fout, "\nCOMPONENTMASKSHIFT ");
  	
  	for (i = 0; i < co->numMaskShiftLayers(); i++) {
!             fprintf(fout, "%s ", co->maskShiftLayer(i));
  	}
  	fprintf(fout, ";\n");
      }
***************
*** 192,199 ****
          if (co->maskShiftSize()) {
              fprintf(fout, "+ MASKSHIFT ");
  
!             for (int i = co->maskShiftSize()-1; i >= 0; i--) {
!                 fprintf(fout, "%d", co->maskShift(i));
              }
              fprintf(fout, "\n");
          }
--- 192,199 ----
          if (co->maskShiftSize()) {
              fprintf(fout, "+ MASKSHIFT ");
  
!             for (int ix = co->maskShiftSize()-1; ix >= 0; ix--) {
!                 fprintf(fout, "%d", co->maskShift(ix));
              }
              fprintf(fout, "\n");
          }
***************
*** 243,249 ****
  }
  
  
! int netpath(defrCallbackType_e c, defiNet* ppath, defiUserData ud) {
    fprintf(fout, "\n");
  
    fprintf (fout, "Callback of partial path for net\n");
--- 243,249 ----
  }
  
  
! int netpath(defrCallbackType_e , defiNet* , defiUserData ) {
    fprintf(fout, "\n");
  
    fprintf (fout, "Callback of partial path for net\n");
***************
*** 938,945 ****
  
  	    defiPoints points = ppath->getViaPts(i);
  
! 	    for (int j = 0; j < points.numPoints; j++) {
! 		fprintf(fout, " %d %d", points.x[j], points.y[j]);
  	    }
  	}
    }
--- 938,945 ----
  
  	    defiPoints points = ppath->getViaPts(i);
  
! 	    for (int jx = 0; jx < points.numPoints; jx++) {
! 		fprintf(fout, " %d %d", points.x[jx], points.y[jx]);
  	    }
  	}
    }
***************
*** 1220,1226 ****
           }
        }
        if (net->polyMask(i)) {
! 	  fprintf(fout, "\n  + MASK %d + POLYGON % s ", net->polyMask(i),
  		  net->polygonName(i));
        } else {
            fprintf(fout, "\n  + POLYGON %s ", net->polygonName(i));
--- 1220,1226 ----
           }
        }
        if (net->polyMask(i)) {
! 	  fprintf(fout, "\n  + MASK %d + POLYGON %s ", net->polyMask(i),
  		  net->polygonName(i));
        } else {
            fprintf(fout, "\n  + POLYGON %s ", net->polygonName(i));
***************
*** 1284,1291 ****
        
         defiPoints points = net->getViaPts(i);
  
!        for (int j = 0; j < points.numPoints; j++) {
!           fprintf(fout, " %d %d", points.x[j], points.y[j]);
         }
         fprintf(fout, ";\n"); 
  
--- 1284,1291 ----
        
         defiPoints points = net->getViaPts(i);
  
!        for (int jx = 0; jx < points.numPoints; jx++) {
!           fprintf(fout, " %d %d", points.x[jx], points.y[jx]);
         }
         fprintf(fout, ";\n"); 
  
***************
*** 1665,1671 ****
  }
  
  
! int propstart(defrCallbackType_e c, void* dummy, defiUserData ud) {
    checkType(c);
    fprintf(fout, "\nPROPERTYDEFINITIONS\n");
    isProp = 1;
--- 1665,1671 ----
  }
  
  
! int propstart(defrCallbackType_e c, void* , defiUserData ) {
    checkType(c);
    fprintf(fout, "\nPROPERTYDEFINITIONS\n");
    isProp = 1;
***************
*** 1717,1723 ****
  }
  
  
! int propend(defrCallbackType_e c, void* dummy, defiUserData ud) {
    checkType(c);
    if (isProp) {
        fprintf(fout, "END PROPERTYDEFINITIONS\n\n");
--- 1717,1723 ----
  }
  
  
! int propend(defrCallbackType_e c, void* , defiUserData ) {
    checkType(c);
    if (isProp) {
        fprintf(fout, "END PROPERTYDEFINITIONS\n\n");
***************
*** 1797,1805 ****
    checkType(c);
    if (ud != userData) dataError();
    if (d == 1)
!      fprintf(fout, "NAMESCASESENSITIVE ON ;\n", d);
    else
!      fprintf(fout, "NAMESCASESENSITIVE OFF ;\n", d);
    return 0;
  }
  
--- 1797,1805 ----
    checkType(c);
    if (ud != userData) dataError();
    if (d == 1)
!      fprintf(fout, "NAMESCASESENSITIVE ON ;\n");
    else
!      fprintf(fout, "NAMESCASESENSITIVE OFF ;\n");
    return 0;
  }
  
***************
*** 1914,1920 ****
                   fprintf(fout, "+ GROUNDSENSITIVITY %s ",
                           pin->groundSensitivity());
               if (pin->hasLayer()) {
!                  struct defiPoints points;
                   for (i = 0; i < pin->numLayer(); i++) {
                      fprintf(fout, "\n  + LAYER %s ", pin->layer(i));
                      if (pin->layerMask(i)) 
--- 1914,1920 ----
                   fprintf(fout, "+ GROUNDSENSITIVITY %s ",
                           pin->groundSensitivity());
               if (pin->hasLayer()) {
! //                 struct defiPoints points;
                   for (i = 0; i < pin->numLayer(); i++) {
                      fprintf(fout, "\n  + LAYER %s ", pin->layer(i));
                      if (pin->layerMask(i)) 
***************
*** 1961,1967 ****
                   }
               }
               if (pin->hasPort()) {
!                  struct defiPoints points;
                   defiPinPort* port;
                   for (j = 0; j < pin->numPorts(); j++) {
                      port = pin->pinPort(j);
--- 1961,1967 ----
                   }
               }
               if (pin->hasPort()) {
! //                 struct defiPoints points;
                   defiPinPort* port;
                   for (j = 0; j < pin->numPorts(); j++) {
                      port = pin->pinPort(j);
***************
*** 2160,2166 ****
           }
           break;
    case defrDefaultCapCbkType :
!          i = (long)cl;
           fprintf(fout, "DEFAULTCAP %d\n", i);
           numObjs = i;
           break;
--- 2160,2166 ----
           }
           break;
    case defrDefaultCapCbkType :
!          i = (intptr_t)cl;
           fprintf(fout, "DEFAULTCAP %d\n", i);
           numObjs = i;
           break;
***************
*** 2251,2257 ****
               }
               // POLYGON
               if (via->numPolygons()) {
!                  struct defiPoints points;
                   for (i = 0; i < via->numPolygons(); i++) {
                       int polyMask = via->polyMask(i);
  
--- 2251,2257 ----
               }
               // POLYGON
               if (via->numPolygons()) {
! //                 struct defiPoints points;
                   for (i = 0; i < via->numPolygons(); i++) {
                       int polyMask = via->polyMask(i);
  
***************
*** 2268,2281 ****
               }
               fprintf(fout, " ;\n");
               if (via->hasViaRule()) {
!                  char *vrn, *bl, *cl, *tl;
                   int xs, ys, xcs, ycs, xbe, ybe, xte, yte;
                   int cr, cc, xo, yo, xbo, ybo, xto, yto;
!                  (void)via->viaRule(&vrn, &xs, &ys, &bl, &cl, &tl, &xcs,
                                               &ycs, &xbe, &ybe, &xte, &yte);
                   fprintf(fout, "+ VIARULE '%s'\n", ignoreViaNames ? "XXX" : vrn);
                   fprintf(fout, "  + CUTSIZE %d %d\n", xs, ys);
!                  fprintf(fout, "  + LAYERS %s %s %s\n", bl, cl, tl);
                   fprintf(fout, "  + CUTSPACING %d %d\n", xcs, ycs);
                   fprintf(fout, "  + ENCLOSURE %d %d %d %d\n", xbe, ybe, xte, yte);
                   if (via->hasRowCol()) {
--- 2268,2281 ----
               }
               fprintf(fout, " ;\n");
               if (via->hasViaRule()) {
!                  char *vrn, *bl, *tcl, *tl;
                   int xs, ys, xcs, ycs, xbe, ybe, xte, yte;
                   int cr, cc, xo, yo, xbo, ybo, xto, yto;
!                  (void)via->viaRule(&vrn, &xs, &ys, &bl, &tcl, &tl, &xcs,
                                               &ycs, &xbe, &ybe, &xte, &yte);
                   fprintf(fout, "+ VIARULE '%s'\n", ignoreViaNames ? "XXX" : vrn);
                   fprintf(fout, "  + CUTSIZE %d %d\n", xs, ys);
!                  fprintf(fout, "  + LAYERS %s %s %s\n", bl, tcl, tl);
                   fprintf(fout, "  + CUTSPACING %d %d\n", xcs, ycs);
                   fprintf(fout, "  + ENCLOSURE %d %d %d %d\n", xbe, ybe, xte, yte);
                   if (via->hasRowCol()) {
***************
*** 2342,2353 ****
           }
           break;
    case defrComponentMaskShiftLayerCbkType :
! 	 fprintf(fout, "COMPONENTMASKSHIFT ");
          
!         for (i = 0; i < maskShiftLayer->numMaskShiftLayers(); i++) {
!            fprintf(fout, "%s ", maskShiftLayer->maskShiftLayer(i));
!         } 
!         fprintf(fout, ";\n");
  	 break;
    case defrGroupCbkType :
           group = (defiGroup*)cl;
--- 2342,2355 ----
           }
           break;
    case defrComponentMaskShiftLayerCbkType :
!          if (maskShiftLayer && maskShiftLayer->numMaskShiftLayers()) {
! 	     fprintf(fout, "COMPONENTMASKSHIFT ");
          
!              for (i = 0; i < maskShiftLayer->numMaskShiftLayers(); i++) {
!                  fprintf(fout, "%s ", maskShiftLayer->maskShiftLayer(i));
!              } 
!              fprintf(fout, ";\n");
!          }
  	 break;
    case defrGroupCbkType :
           group = (defiGroup*)cl;
***************
*** 2366,2374 ****
               fprintf(fout, "\n  + REGION %s ", group->regionName());
           if (group->hasRegionBox()) {
               int *gxl, *gyl, *gxh, *gyh;
!              int size;
!              group->regionRects(&size, &gxl, &gyl, &gxh, &gyh);
!              for (i = 0; i < size; i++)
                   fprintf(fout, "REGION %d %d %d %d ", gxl[i], gyl[i],
                           gxh[i], gyh[i]);
           }
--- 2368,2376 ----
               fprintf(fout, "\n  + REGION %s ", group->regionName());
           if (group->hasRegionBox()) {
               int *gxl, *gyl, *gxh, *gyh;
!              int tsize;
!              group->regionRects(&tsize, &gxl, &gyl, &gxh, &gyh);
!              for (i = 0; i < tsize; i++)
                   fprintf(fout, "REGION %d %d %d %d ", gxl[i], gyl[i],
                           gxh[i], gyh[i]);
           }
***************
*** 2539,2545 ****
    case defrTimingDisableCbkType :
           td = (defiTimingDisable*)cl;
           if (td->hasFromTo())
!              fprintf(fout, "- FROMPIN %s %s ",
                       td->fromInst(),
                       td->fromPin(),
                       td->toInst(),
--- 2541,2547 ----
    case defrTimingDisableCbkType :
           td = (defiTimingDisable*)cl;
           if (td->hasFromTo())
!              fprintf(fout, "- FROMPIN %s %s %s %s",
                       td->fromInst(),
                       td->fromPin(),
                       td->toInst(),
***************
*** 2554,2560 ****
                       td->fromPin(),
                       td->toPin());
           if (td->hasMacroThru())
!              fprintf(fout, "- MACRO %s THRUPIN %s %s ",
                       td->macroName(),
                       td->fromPin());
           fprintf(fout, ";\n");
--- 2556,2562 ----
                       td->fromPin(),
                       td->toPin());
           if (td->hasMacroThru())
!              fprintf(fout, "- MACRO %s THRUPIN %s ",
                       td->macroName(),
                       td->fromPin());
           fprintf(fout, ";\n");
***************
*** 2794,2800 ****
           }
           break;
    case defrStylesCbkType :
!          struct defiPoints points;
           styles = (defiStyles*)cl;
           fprintf(fout, "- STYLE %d ", styles->style());
           points = styles->getPolygon();
--- 2796,2802 ----
           }
           break;
    case defrStylesCbkType :
! //         struct defiPoints points;
           styles = (defiStyles*)cl;
           fprintf(fout, "- STYLE %d ", styles->style());
           points = styles->getPolygon();
***************
*** 2880,2893 ****
          ccr1131444 = 0;
      }
  
- #ifdef _WIN32
-   fprintf(fout, "Parsed %I64d number of lines!!\n", lineNo);
- #else 
    fprintf(fout, "Parsed %lld number of lines!!\n", lineNo);
- #endif
  }
  
! int unUsedCB(defrCallbackType_e c, void* any, defiUserData ud) {
    fprintf(fout, "This callback is not used.\n");
    return 0;
  }
--- 2882,2891 ----
          ccr1131444 = 0;
      }
  
    fprintf(fout, "Parsed %lld number of lines!!\n", lineNo);
  }
  
! int unUsedCB(defrCallbackType_e , void* , defiUserData ) {
    fprintf(fout, "This callback is not used.\n");
    return 0;
  }
***************
*** 2902,2908 ****
    char* inFile[6];
    char* outFile;
    FILE* f;
!   int res;
    int noCalls = 0;
  //  long start_mem;
    int retStr = 0;
--- 2900,2906 ----
    char* inFile[6];
    char* outFile;
    FILE* f;
!   int res = 0;
    int noCalls = 0;
  //  long start_mem;
    int retStr = 0;
***************
*** 3096,3106 ****
      defrSetPinCapCbk((defrPinCapCbkFnType)cls);
      defrSetPinCbk((defrPinCbkFnType)cls);
      defrSetPinPropCbk((defrPinPropCbkFnType)cls);
!     defrSetDefaultCapCbk((defrIntegerCbkFnType)cls);
      defrSetRowCbk((defrRowCbkFnType)cls);
      defrSetTrackCbk((defrTrackCbkFnType)cls);
      defrSetGcellGridCbk((defrGcellGridCbkFnType)cls);
!     defrSetViaCbk((defrViaCbkFnType)cls);
      defrSetRegionCbk((defrRegionCbkFnType)cls);
      defrSetGroupNameCbk((defrStringCbkFnType)cls);
      defrSetGroupMemberCbk((defrStringCbkFnType)cls);
--- 3094,3104 ----
      defrSetPinCapCbk((defrPinCapCbkFnType)cls);
      defrSetPinCbk((defrPinCbkFnType)cls);
      defrSetPinPropCbk((defrPinPropCbkFnType)cls);
!     defrSetDefaultCapCbk((defrIntegerCbkFnType)(void*)cls);
      defrSetRowCbk((defrRowCbkFnType)cls);
      defrSetTrackCbk((defrTrackCbkFnType)cls);
      defrSetGcellGridCbk((defrGcellGridCbkFnType)cls);
!     defrSetViaCbk((defrViaCbkFnType)(void*)cls);
      defrSetRegionCbk((defrRegionCbkFnType)cls);
      defrSetGroupNameCbk((defrStringCbkFnType)cls);
      defrSetGroupMemberCbk((defrStringCbkFnType)cls);
***************
*** 3192,3198 ****
         res = defrRead(f, inFile[fileCt], userData, 1);
  
         if (res)
!           fprintf(stderr, "Reader returns bad status.\n", inFile[fileCt]);
  
         (void)defrPrintUnusedCallbacks(fout);
         (void)defrReleaseNResetMemory();
--- 3190,3196 ----
         res = defrRead(f, inFile[fileCt], userData, 1);
  
         if (res)
!           fprintf(stderr, "Reader returns bad status.\n");
  
         (void)defrPrintUnusedCallbacks(fout);
         (void)defrReleaseNResetMemory();
***************
*** 3209,3215 ****
      // 2nd will enable 7016 by calling defrEnableParserMsgs
      // 3rd enable all msgs by call defrEnableAllMsgs
  
!     int nMsgs = 2;
      int dMsgs[2];
  
      for (fileCt = 0; fileCt < numInFile; fileCt++) {
--- 3207,3213 ----
      // 2nd will enable 7016 by calling defrEnableParserMsgs
      // 3rd enable all msgs by call defrEnableAllMsgs
  
! //    int nMsgs = 2;
      int dMsgs[2];
  
      for (fileCt = 0; fileCt < numInFile; fileCt++) {
***************
*** 3231,3237 ****
         res = defrRead(f, inFile[fileCt], userData, 1);
   
         if (res)
!           fprintf(stderr, "Reader returns bad status.\n", inFile[fileCt]);
   
         (void)defrPrintUnusedCallbacks(fout);
         (void)defrReleaseNResetMemory();
--- 3229,3235 ----
         res = defrRead(f, inFile[fileCt], userData, 1);
   
         if (res)
!           fprintf(stderr, "Reader returns bad status.\n");
   
         (void)defrPrintUnusedCallbacks(fout);
         (void)defrReleaseNResetMemory();
***************
*** 3253,3259 ****
         res = defrRead(f, inFile[fileCt], userData, 1);
  
         if (res)
!            fprintf(stderr, "Reader returns bad status.\n", inFile[fileCt]);
  
         // Testing the aliases API.
         defrAddAlias ("alias1", "aliasValue1", 1);
--- 3251,3257 ----
         res = defrRead(f, inFile[fileCt], userData, 1);
  
         if (res)
!            fprintf(stderr, "Reader returns bad status.\n");
  
         // Testing the aliases API.
         defrAddAlias ("alias1", "aliasValue1", 1);
diff -r -c source.lefdef/def.orig/template.mk def/template.mk
*** source.lefdef/def.orig/template.mk	2016-02-05 14:39:13.000000000 -0800
--- def/template.mk	2020-12-30 16:46:37.000000000 -0800
***************
*** 23,28 ****
--- 23,38 ----
      ARCH=lnx86 
      CXX=g++
      CC=gcc
+ # S. Whiteley, add some optimization and set PIC.
+     CXXFLAGS = -O -fPIC
+ endif
+ 
+ # S. Whiteley, add OS X (Darwin) support.
+ ifeq ($(OS_TYPE),Darwin)
+     ARCH=darwin 
+     CXX=g++
+     CC=gcc
+     CXXFLAGS = -O
  endif
  
  .SUFFIXES: $(SUFFIXES) .cpp
