
!!  --------------------------------------------------------------- !! 
Xic/WRspice Help System Database !!  $Id:  xiParamCells.hlp,v 1.6
2013/02/26 05:04:48 stevew Exp $ !!  Copyright (C) Whiteley Research
Inc.  2013.  All Rights Reserved !! 
---------------------------------------------------------------

!!TAG Xic

!!KEYWORD
xiParamCells.hlp
!!TITLE
xiParamCells.hlp
!!HTML

!!SUBTOPICS
xic:pcells
constraints
xic:pcparams
pc_stretch
pc_abut
pycell
stdvia

!!REDIRECT prpty:pc_name        xic:pcells#pc_name
!!REDIRECT prpty:pc_params      xic:pcells#pc_params
!!REDIRECT prpty:pc_script      xic:pcells#pc_script

!! 032017
!!KEYWORD
xic:pcells pcell pcells
!!TITLE
Parameterized Cells
!!HTML
    <table border=0>
    <tr><td valign=top><b>jump to</b></td> <td>
    <a href="xic:pcells#intro"><b>How PCells Work</b></a><br>
    <a href="xic:pcells#status"><b>PCell History and Status</b></a><br>
    <a href="xic:pcells#native"><b><i>Xic</i> Native PCells</b></a><br>
    <a href="xic:pcells#create"><b>Creation of a Native Parameterized Cell</b></a><br>
    <a href="xic:pcells#inst"><b>Adding an Instance of a Parameterized Cell</b></a><br>
    <a href="xic:pcells#instchange"><b>Changing the Parameters of an Instance</b></a><br>
    <a href="xic:pcells#submchange"><b>Changing the Parameters of a Sub-Master</b></a>
    </td></tr></table>

    <p>
    Parameterized cells, or "pcells" (or sometimes called "template
    cells") are cells which in addition to possible fixed geometry,
    contain an executable program that creates geometry according to
    one or more parameters supplied to the cell.  The cell is
    instantiated for given sets of parameters, so that instances may
    have layouts that differ.  Parameterized cells are often used to
    represent devices such as MOSFETS that may come in many shapes and
    flavors.  The MOSFET parameters select the size and other
    properties of each instantiation.  As an alternative, in a process
    design kit one might find hundreds of fixed-cells with different
    permutations of size and other parameters.  A single parameterized
    cell that replaces the collection of fixed cells can streamline
    the design process, provide greater flexibility, and reduce
    errors.

    <p>
!!IFDEF OpenAccess
    The full and <a href="xicii"><i>XicII</i></a> feature sets have
    support for native and OpenAccess-based portable pcells, as well
    as the ability to work with the Cadence Virtuoso Express PCells
    feature.  The <a href="xiv"><i>Xiv</i></a> feature set does not
    support pcells.

    <p>
    There is an ongoing effort to strengthen the parameterized
    cell capabilities in <i>Xic</i>.  The effort includes
    <ul>
    <li>Providing support for languages other than the native script
    language.  In particular, the Python language appears to be the
    choice for "open" pcells, i.e., pcells which can be used in tools
    from different vendors.

    <li>Provide commonality and support for Ciranova open pcells and
    standards.

    <li>Provide commonality and support for the OpenAcces pcell
    framework.
    </ul>
!!ELSE
    The full and <a href="xicii"><i>XicII</i></a> feature sets have
    support for native pcells.  The <a href="xiv"><i>Xiv</i></a>
    feature set does not support pcells.

    <p>
    Unfortunately, at the present time legal and financial
    constraints set by the controlling organization prevent use of
    OpenAccess in <i>Xic</i>.  With OpenAccess, support for portable
    pcells, and the ability to work with the Cadence Virtuoso Express
    PCells feature, could be provided.  Please contact Whiteley
    Research if support for OpenAccess would be of use to you.  With
    sufficient demand, the decision to drop OpenAccess support may be
    revisited.
!!ENDIF

    <a name="intro"></a>
    <h2>How PCells Work</h2>

    <p>
    <b>Definitions</b>
    <dl>
    <dt>pcell<dd>
    A "parameterized cell" or "template cell".  This is a cell containing
    an executable component, which acts on a set of one or more parameters.
    When placed in a layout, the cell constructs itself according to the
    parameters given while instantiating.
    </dl>

    <dl>
    <dt>super-master<dd>
    A pcell in memory.
    </dl>

    <dl>
    <dt>sub-master<dd>
    A master cell created from a super-master and a given parameter set.
    Instances of the sub-master are actually placed into the layout.
    A pcell itself is never placed in a layout.
    </dl>

    <p>
    All pcells "work" as follows.  The pcell is supplied as a cell
    file to the design system, which understands the file syntax. 
    Within the design system, an in-memory object called a
    "super-master" is created, which is an in-memory representation of
    the pcell.  This element contains a list of parameter names, and
    for each parameter a default value and acceptable range.  The
    element also provides, by some means, a program or script that can
    be executed from the design system.

    <p>
    When a user wishes to place an instance of a pcell, the pcell is
    selected from a menu, which causes the pcell file to be read from
    disk and a super-master created in memory.  The user will then
    specify the parameter values to the cell to instantiate.  This is
    usually done with a pop-up form, where the user can enter values
    for the various parameters, all of which have defaults.  When this
    entry is complete, the design system will execute the pcell script
    with the entered parameter values.  The result will be creation of
    a cell in memory containing geometry created by the script in
    accord with the parameters.  This cell is called a "sub-master". 
    It is a normal cell is every respect, though it has properties
    that link it to the original pcell super-master.  Instances of
    this sub-master are created where the user specifies.  A separate
    sub-master will be created for every differing parameter set that
    the user provides.  Each instance of a sub-master contains
    properties that contain the parameter set used for instantiation,
    and the name of the original pcell.

    <p>
    A design containing pcells can be saved in two ways.  For a local
    save, for use in the same design environment, the super- and
    sub-masters in memory are discarded (or the sub-masters may be
    cached).  When the design is read in again, the instances provide
    the location of the pcell and the parameter set, which are used to
    recreate the sub-masters.  If instead the design is being sent to
    another environment, one which perhaps does not handle the pcells,
    the sub-masters can be written to disk as ordinary cells.  The
    resulting hierarchy will be normal and portable.  In <i>Xic</i>,
    sub-masters can be included in saved archive files when the <a
    href="PCellKeepSubMasters"><b>PCellKeepSubMasters</b></a> variable
    or equivalently the check box in the <a href="xic:exprt"><b>Export
    Control</b></a> panel is set, or when the <a
    href="StripForExport"><b>StripForExport</b></a> variable or
    equivalent check box in the same panel is set.  If a cell is read
    from a file and is recognized as a pcell sub-master, the PCKEEP <a
    href="cellflags">cell flag</a> will be set.  This will cause the
    cell to be written to output, whether or not writing of pcell
    sub-masters is enabled.

    <a name="status"></a>
    <h2>PCell History and Status</h2>

    <p>
    Historically, the pcell concept was developed for the Cadence
    Virtuoso layout editor, and supported pcells used the Skill
    language which is the scripting language of the Virtuoso system.
    This remains the dominant type of pcell around, due to the
    ubiquity of Cadence installations.  However, the Skill language
    is not available outside of the Cadence environment, so these
    pcells are not portable to other tools.

    <p>
    The OpenAccess project addressed the pcell portability problem by
    providing a standardized interface for pcells, with the execution
    being carried out through a "plug-in" that a vendor, or user, may
    supply.  A pcell, in concept, can be created to use any suitable
    programming language, provided that the tool used to instantiate
    the pcell is capable of executing that language.  With OpenAccess,
    the portability problem is reduced to obtaining a plug-in for the
    pcell language.

    <p>
    There are example plug-ins distributed with OpenAccess that handle
    Tcl and C++.  Unfortunately, the Skill language is not available
    for general use outside of the Cadence environment.  It is not
    really attractive anyway, as it was developed back in the
    prehistoric days when Lisp ws "cool", and abominations like EDIF
    seemed important.  There are far better languages, such as Python,
    available today.

    <p>
    The concept of portable pcells was championed by a company called
    Ciranova, that supplied an OpenAccess plug-in for Python.  They
    released this, along with companion applications for Python pcell
    ("PyCell") development, examples, and precompiled OpenAccess and
    Python libraries as a free "PyCell Studio" download.  Ciranova was
    subsequently bought by Synopsys, but the PyCell Studio remains
    available and apparently is still under development.  An industry
    group, <a href="https://www.iplnow.com">IPLnow.com</a> which
    includes TSMC and other foundries and some tool vendors, is
    pushing the cause of "interoperable" PDK libraries based on
    portable pcells.

!!IFDEF OpenAccess
    <p>
    <i>Xic</i> is intended to be fully compatible with the PyCell Studio
    and PyCells, through the OpenAccess interface <a
    href="oaplugin">plug-in</a>.  In addition, <i>Xic</i> without
    OpenAccess provides support for Python pcells, and the Ciranova
    protocols for stretch handles and abutment.  However, Ciranova
    provides a number of library modules and functions as part of its
    Python implementation that are not present without the Ciranova
    plug-in and OpenAccess.

    <p>
    <i>Xic</i> with OpenAccess has some limited capability with
    Skill-based pcells through the Virtuoso <a
    href="cdsconnect#exprpc">Express PCells</a> feature.  This allows
    export is pre-instantiated cached sub-masters of pcells, but not
    the pcells themselves.  This capability is provided through the
    same OpenAccess plug-in technology mentioned above, but in this
    case if the parameter set does not have a pre-built sub-master in
    cache, the instantiation will fail.

    <p>
    The <a href="!rmpcprops"><b>!rmpcprops</b></a> command will remove
    the properties that make pcells special throughout the hierarchy
    of the current cell.  This operation is not undoable, and renders
    the hierarchy henceforth free of any pcell history.  The user may
    wish to do this to hierarchies imported from Virtuoso, as the
    Skill pcells can not be evaluated in the <i>Xic</i> environment. 
    In this case, retaining the pcell identities may be pointless, and
    in fact this may cause trouble, for example when writing output
    pcell sub-masters are not written unless the user overrides the
    default (e.g., by checking the box in the <a
    href="xic:exprt"><b>Export Control</b></a> panel).
!!ELSE
    Currently, support for OpenAccess pcells is not available. 
    OpenAccess support can easily be provided by paying what amounts
    to a commercial use fee.  Users who may need this feature are
    encouraged to lobby Whiteley Research Inc.
!!ENDIF

    <a name="native"></a>
    <h2><i>Xic</i> Native PCells</h2>

    <i>Xic</i> supports pcells using the native <a
    href="xicscript">scripting language</a>, plus <a
    href="pyplugin">Python</a> or <a href="tclplugin">Tcl</a> if the
    respective <a href="plugins">plug-ins</a> are loaded. 
    Parameterized cells are supported only in physical mode.  This
    section will describe how to create and use native pcells in
    <i>Xic</i>.
!!IFDEF OpenAccess
    By "native", execution within <i>Xic</i> rather than through
    OpenAccess is meant.  As will be seen, native pcells can be saved
    in OpenAccess, too, and they are still native.
!!ENDIF

    <p>
    There are several example native pcells provided in the examples
    directory of the <i>Xic</i> installation.  These provide samples
    of the syntax used in the property strings and other aspects, with
    comments, and their study should facilitate understanding how to
    write native pcells.

    <p>
    A native pcell can be saved in any format supported by <i>Xic</i>,
    with certain limitations to be described.  Probably, the native
    cell format is the most convenient.  These can be easily edited
    with a text editor, which the advanced developer is likely to do
    on occasion.

    <p>
    A pcell can have any name that is compatible with <i>Xic</i>. 
    Earlier releases of <i>Xic</i> required that a pcell name have a
    literal "<tt>XXX</tt>" suffix.  This is no longer the case, but if
    the <tt>XXX</tt> is present, it will be stripped in sub-master
    names and replaced with a unique identifying code for the
    parameter set.  Otherwise, the code is appended to the pcell name.

    <p>
    Super- and sub-master cells, and sub-master instances, differ
    from normal cells and instances by the presence of a few special
    properties.  These are:

    <a name="pc_name"></a>
    <dl>
    <dt><b>pc_name</b> property, number 7197<dd>
    This property is assigned by <i>Xic</i> to pcell sub-masters and
    their instances.  It provides the name of the pcell from which the
    sub-master or instance was derived.
    </dl>

    <a name="pc_params"></a>
    <dl>
    <dt><b>pc_params</b> property, number 7198<dd>
    This property is assigned by the user to pcells, and contains the
    default parameter set.  It will be assigned by <i>Xic</i> to
    sub-masters and instances, and contains the parameter set that was
    used to create the sub-master.

    <p>
    The string of the <b>pc_params</b> property has the form
    <blockquote>
    [<i>typechar</i>:]<i>name</i>[<tt>=</tt>]<i>value</i>[:<i>constraint</i>]
      [[<tt>,</tt>] ...]  
    </blockquote>

    The string consists of a series of <i>name</i> and <i>value</i>
    tokens.  The <i>name</i>s can not contain white space or
    punctuation.  Ahead of the <i>name</i> is a type specification
    character if the value is not string type.  In native pcells, all
    parameters are (for this purpose) string type, so the type
    specifier will never appear.  However, the syntax used may be
    extended in future, so it is documented in the table below.  All
    types except for string type will have a specifier.
!!IFDEF OpenAccess
    These <b>will</b> appear in property strings obtained from
    OpenAccess for non-native pcells.
!!ENDIF

    <blockquote>
    <table border=0>
    <tr><td><tt>b</tt></td> <td>boolean</td></tr>
    <tr><td><tt>i</tt></td> <td>integer<td></tr>
    <tr><td><tt>t</tt></td> <td>time value</td></tr>
    <tr><td><tt>f</tt></td> <td>32-bit float</td></tr>
    <tr><td><tt>d</tt></td> <td>64-bit float</td></tr>
    </table>
    </blockquote>
    
    Each of the <i>name</i> tokens is the name of a parameter that can
    be applied to the pcell.  These will become names of variables in
    the script, so that these names should not be defined or used in
    the script text in a conflicting way.

    <p>
    Every <i>name</i> should have a <i>value</i>, an "empty" value is
    specified as an empty string (<tt>""</tt>).  The <i>value</i> is
    separated from the <i>name</i> by white space, a comma, or an
    equal sign.  The <i>values</i> are taken as default values for the
    parameters, and can be numeric values or strings.  A <i>value</i>
    that contains white space, commas, or colons should be quoted. 
    The value string can also be an executable code fragment using
    only parameters already defined (to the left) and constants, for
    example

    <blockquote>
    <tt>param1=2,param2="param1 + 1"</tt>
    </blockquote>

    This form, however, can not be used with constraints (see below). 
    It can also only appear in super-master <b>pc_params</b>
    properties.  the <b>pc_params</b> strings of sub-masters and
    instances must have constant values.

    <p>
    The quoting behavior is a bit complicated, so as to support Python
    and native languages.  If the <i>value</i> is quoted with
    double-quote marks, the double quote marks will be stripped, and
    the parameter will take the enclosed characters.  However, if a
    backslash character ('\') appears ahead of the first double quote,
    the double quote marks will be retained.  In the native language,
    this will ensure that the parameter is string-type.

    <p>
    For example
    <blockquote>
    <tt>myvar="123"</tt>
    </blockquote>
    The parameter (variable) <tt>myvar</tt> will be assigned the value
    123, causing it to become scalar-type.  On the other hand
    <blockquote>
    <tt>myvar=\"123"</tt>
    </blockquote>
    will assign <tt>"123"</tt> to <tt>myvar</tt> (including the
    quotes) thus <tt>myvar</tt> will be string-type.  In general, if
    the <i>value</i> is to be taken as a string constant in the
    native language, a backslash should be placed ahead of the first
    double quote mark.

    <p>
    If the <i>value</i> is quoted with single-quote marks, the
    single-quote marks are retained, along with the characters between
    them.  This is for Python support.  However, if the second
    character is a double-quote mark, the single-quote marks will be
    stripped, leaving the double-quoted result.  This is an alternative
    and somewhat deprecated way to specify a string constant in the
    native language.
    <blockquote>
    <tt>mystring='"a string constant"'
    </blockquote>

    <p>
    In any case, when the parser is searching for the ending quote
    mark (single or double), if the mark is found but it is preceded
    by a backslash, both characters are taken verbatim and the search
    continues.  Thus, the backslash can be used to hide quote marks
    of the same type in the string.
    
    <p>
    If the <i>value</i> is a constant (not an executable fragment),
    the <i>value</i> can be followed by an optional <a
    href="constraint">constraint</a> specification, separated from the
    <i>value</i> by a colon (no white space is allowed around the
    colon).  Constraints define the scceptable values for the
    parameter, using a syntax described elsewhere.  The constraints
    appear only in <b>pc_params</b> properties of super-masters, and
    are not copied to <b>pc_params</b> properties of sub-masters and
    instances.

    <p>
    The parameter string is logically converted to a series of
    assignment statements which are executed before the script.  For
    example, the parameter string
    <blockquote>
    <tt>param1=1.0,name=\"my template",param2="param1 * 2"</tt>
    </blockquote>
    would map to the following logical script lines
    <blockquote><tt>
    param1 = 1.0<br>
    name = "my template"<br>
    param2 = param1 * 2
    </tt></blockquote>
    </dl>

    <a name="pc_script"></a>
    <dl>
    <dt><b>pc_script</b> property, number 7199<dd>
    This property is assigned by the user to a pcell, and appears only
    in the super-master.  It contains the script, or a path to a
    script, which is executed when the pcell is instantiated.

    <p>
    The <b>pc_script</b> property text is in the form
    <blockquote>
     [<tt>@LANG</tt> <i>langtok</i>] <tt>@READ</tt> <i>path</i>
     [<tt>@MD5</tt> <i>digest</i>] | script text
    </blockquote>
 
    <p>
    The <tt>@LANG</tt>, <tt>@READ</tt>, and <tt>@MD5</tt> tokens are
    literal.  The <i>langtok</i> may be one of (case insensitive)

    <blockquote>
    <table border=0>
    <tr><td><tt>n</tt>[<tt>ative</tt>]</td> <td>native script, the
      default</td></tr>
    <tr><td><tt>p</tt>[<tt>ython</tt>]</td> <td>python script</td></tr>
    <tr><td><tt>t</tt>[<tt>cl</tt>]</td> <td>tcl script</td></tr>
    </table>
    </blockquote>
 
    <p>
    The <i>path</i> token must appear if <tt>@READ</tt> is given.
    If <tt>@READ</tt> is not given, any remaining text is taken as
    literal executable script text.

    <p>
    The <i>path</i> is to a file containing the executable text, and
    should be quoted if it contains white space.  If the <i>path</i>
    is not rooted, it will be searched for in a directory <a
    href="xicpaths">search path</a> set in the <a
    href="PCellScriptPath"><b>PCellScriptPath</b></a> variable.

    <p>
    When a path is given, one can also apply the <tt>@MD5</tt>
    <i>digest</i> clause.  The <i>digest</i> is that for the script
    file, and can be obtained from the <a href="!md5"><b>!md5</b></a>
    command, or the <a href="Md5Digest"><tt>Md5Digest</tt></a> script
    function, or from the command
    <blockquote>
    <tt>openssl dgst -md5</tt> <i>filepath</i>
    </blockquote>
    on most Linux systems.  If given, the script file digest must
    match the digest given, or the script will not be executed.  This
    will ensure that only the "correct" script file is used.
    </dl>

    <p>
    Previous versions of <i>Xic</i> required that the script actually
    appear in the <b>pc_script</b> property string.  This can still be
    done, and may be convenient for many pcells, particularly very
    simple ones.  However, one may encounter a portability issue
    caused by string length limitations of the GDSII and CGX formats
    due to their maximum record length of 64KB.  The native cell
    format, the CIF format as extended by Whiteley Research, and the
    OASIS format have no built-in string length
!!IFDEF OpenAccess
    limit, nor does OpenAccess.
!!ELSE
    limit.
!!ENDIF

    <p>
    When using separate script files, for portability it may be best
    to <b>not</b> provide a full path to the script in the
    <b>pc_script</b> property string, but give the file name only and
    use the search path variable.  Then, the scripts can be kept in
    different locations at different <i>Xic</i> installations, and
    pcells will still be portable provided the <b>PCellScriptPath</b>
    is set (probably from an <a href="initfiles">initialization
    file</a>).  The <tt>MD5</tt> digest keying can ensure that the
    script file found via the search path is correct, or it will
    not execute.

    <p>
    The script, whether in a separate file or not, is basically
    conventional, and uses the native object creation functions to
    build up the geometry, presumably using the parameter values as
    input.  The example native pcells provided with the <i>Xic</i>
    distributions in the examples directory illustrate how the script
    is incorporated.

    <p>
    One aspect of importance is the script return value, which will
    tell the calling program whether or not script evaluation
    succeeded.  If evaluation fails, <i>Xic</i> can gracefully "clean
    up" by destroying partially completed sub-masters, and any
    corresponding instance placements, and alerting the user to the
    error.

    <p>
    The script should return 0 (zero) on success, which is the default
    if no explicit return value is specified.  Any nonzero return
    value indicates faliure.  The mechanics of setting the return value
    differs between the supported languages, and is described below. 
    In every case, just before a nonzero value is returned, the <a
    href="AddError"><tt>AddError</tt></a> function should be called
    with a message explaining the error.

    <dl>
    <dt>Native<dd>
    The <tt>return</tt> keyword, followed by a value, will terminate
    the scrpt and return the value.  For example, here is a snippet
    that checks the value of a parameter named "<tt>top</tt>" and
    fails if it is out of range:

    <blockquote>
    <tt>if (top &#60; 1 | top > 20)<br>
    &nbsp;&nbsp;&nbsp;&nbsp;AddError("Parameter top is out of range [1 - 20].")<br>
    &nbsp;&nbsp;&nbsp;&nbsp;return 1<br>
    end</tt>
    </blockquote>

    <p>
    Actually, if the value following <tt>return</tt> is omitted, the
    return value is 1, so just a bare "<tt>return</tt>" will signal
    the error condition.  If the end of execution is reached and no
    <tt>return</tt> keyword is encountered, the value returned is 0
    (success).  If the script is terminated with the <tt>Halt</tt> or
    <tt>Exit</tt> functions, the return value is 0.  If the script is
    halted by an internal error, the return value is -1.  If the
    script is halted due to an interrupt signal, the return value is
    1.
    </dl>

    <dl>
    <dt>Python<dd>
    The recommended way to induce an error exit in a Python script is
    to call "<tt>sys.exit</tt>" with a nonzero argument.  The example
    above translated to Python will read:

    <blockquote>
    <tt>if (top &#60; 1 or top > 20):<br>
    &nbsp;&nbsp;&nbsp;&nbsp;xic.AddError("Parameter top is out of range [1 - 20].")<br>
    &nbsp;&nbsp;&nbsp;&nbsp;sys.exit(1)</tt>
    </blockquote>

    <p>
    Errors detected by the Python interpreter are passed back as
    nonzero exit returns.
    </dl>

    <dl>
    <dt>Tcl<dd>
    The recommended way to induce an error exit from a Tcl script is
    to call "<tt>return -code error</tt>".  The example above
    translated to Tcl will read:

    <blockquote>
    <tt>if {$top &#60; 1 || $top > 20} {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;AddError {"Parameter top is out of range [1 - 20]."}<br>
    &nbsp;&nbsp;&nbsp;&nbsp;return -code error<br>
    }</tt>
    </blockquote>

    <p>
    Errors detected by the Tcl interpreter are passed back as nonzero exit
    returns.
    </dl>

    <p>
    To summarize, a pcell is never itself instantiated.  When one
    places an instance of a pcell, the following steps occur:

    <ol> <li>The pcell is read into memory as a "super-master" if it
    is not already there.

    <li>The user enters the parameter values.

    <li>The database is searched for another cell derived from the
    same pcell with the same parameter values, i.e., an equivalent
    sub-master.  If one is found, a new instance is created and given
    <b>pc_name</b> and <b>pc_params</b> properties copied from the
    sub-master, and we're done.

    <li>Otherwise, the script is executed, in the context of a new,
    empty cell whose name consists of the pcell name suffixed by a
    unique identifier.  This is the sub-master cell.  It is given a
    <b>pc_name</b> property to identify the pcell, and a
    <b>pc_params</b> property to list the parameters used.  The new
    sub-master is instantiated and the instance given the same two
    properties, and we're done.
    </ol>

    <p>
    Once the instance is placed, it behaves in all respects as a
    normal cell.  It has a "master" derived from the pcell as a
    sub-master, and a unique sub-master exists for each unique
    parameter set.  Writing the hierarchy, including the sub-masters,
    to an archive produces a perfectly normal file.  However, by
    default the sub-masters are <b>not</b> written to output, instead
    they are expected to be recreated from the pcell when needed.  The
    pcells (super-masters) are <b>never</b> included in the output
    file, since they are not directly instantiated in the hierarchy. 
    Thus, when exporting, the pcell should be supplied separately, if
    needed.  If sub-masters are included in the archive, then the
    pcell is not needed, unless further parameter changes are
    required.  In <i>Xic</i>, sub-masters can be included in saved
    archive files when the <a
    href="PCellKeepSubMasters"><b>PCellKeepSubMasters</b></a> variable
    or equivalently the check box in the <a href="xic:exprt"><b>Export
    Control</b></a> panel is set, or when the <a
    href="StripForExport"><b>StripForExport</b></a> variable or
    equivalent check box in the same panel is set.

    <a name="create"></a>
    <h2>Creation of a Native Parameterized Cell</h2>

    To create a native pcell, one can follow this procedure:

    <dl>
    <dt><b>Write the script</b><dd>
    Write a script that creates the geometry desired, in response
    to a set of variables that will become the parameters.  The script
    can be authored as any other script.  It should be thoroughly
    debugged before committing it to a parameterized cell.

    <p>
    It is recommended that the top of the script contain a comment
    listing the parameters and their purposes, and explicit tests of
    the values that will abort the script (returning nonzero) if a
    value is out of range or otherwise not acceptable.  Any nonzero
    return should have a call to <tt>AddError</tt> explaining the
    error.  This text will be included in the system error reporting.
    </dl>

    <dl>
    <dt><b>Create the parameterized cell</b><dd>
    Use the <a href="xic:open"><b>Open</b></a> command to edit a new
    cell which will become the pcell.  Add any fixed geometry to the
    cell that is necessary.  This can be done at any time.  Keep this
    cell as the current cell and add the properties listed below.
    </dl>

    <dl>
    <dt><b>Add the pc_script property</b><dd>
    Bring up the <a href="xic:cprop"><b>Cell Property Editor</b></a>. 
    Press <b>Add</b>, which brings up a pop-up menu, and select <a
    href="prpty:pc_script"><b>pc_script</b></a> in the pop-up menu. 
    This will prompt for the property string on the prompt line.

    <p>
    At this point we need to decide whether to incorporate the script
    into the property string itself, or to keep the script in a separate
    file.  One consideration is that GDSII and CGX files have 16-bit record
    lengths, which will limit the lengths of property strings.  In the
    present <i>Xic</i> release, CIF and native string lengths, and
    OASIS string lengths, are unlimited.
!!IFDEF OpenAccess
    There is also no limit when storing the cell in OpenAccess.
!!ENDIF

    <p>
    First, assume that the script is to be stored in the property
    string.  We will use the "long text" feature to facilitate entering
    the script.
    </dl>

    <dl>
    <dt><b>Enter property text with script</b><dd>
    Press the "<b>L</b>" button to the left of the prompt line. 
    This brings up the <a href="texteditor"><b>Text Editor</b></a>
    pop-up.  If the script text is Python or Tcl, a <tt>@LANG</tt>
    specification must appear first.  Type one of the following
    into the editor window.  For Python
    <blockquote>
    <tt>@LANG Python</tt>
    </blockquote>
    or if Tcl
    <blockquote>
    <tt>@LANG Tcl</tt>
    </blockquote>
    Neither is needed for native script language.

    <p>
    The next step is to import the script text.  This is presumed to
    exist in a file, though for very simple scripts an advanced user
    can type it in.  For the script in a file, one can use the
    <b>Read</b> button of the text editor (in the <b>File</b> menu) to
    read in the script file.  Then perform any last minute editing,
    such as removal of the variable declarations that would be
    redundant with the parameters.

    <p>
    Press the <b>Save</b> button in the <b>File</b> menu of the text
    editor.  The text editor will disappear, and the script will have
    been saved in the <b>pc_script</b> property of the current cell.
    </dl>

    <dl>
    <dt><b>Enter property text without script</b><dd>
    One can use the "long text" text editor feature, or simply type
    into the prompt line.  Without the script, there generally isn't
    much to type.

    <p>
    First, if the script text is Python or Tcl, one must enter a
    <tt>@LANG</tt> specifier as explained above.  If needed, just
    type in the two tokens.  Next, enter a <tt>@READ</tt> directive
    in the form
    <blockquote>
    <tt>@READ</tt> <i>path</i>
    </blockquote>
    where <i>path</i> is a path to the file containing the script. 
    This can be an absolute path, however it may be more convenient to
    just specify the file name, and set the <a
    href="PCellScriptPath"><b>PCellScriptPath</b></a> variable to a
    directory where pcell script files are kept.  Then, the location
    can change without one having to edit the property string.  This
    completes text entry.  Exit the text editor as above if it is
    being used, or press <b>Enter</b> to terminate text entry into the
    prompt line.  The text is saved in the <b>pc_script</b> property
    of the current cell.

    <p>
    Optionally, one can append a directive of the form
    <blockquote>
    <tt>@MD5</tt> <i>digest</i>
    </blockquote>
    The <i>digest</i> is the 32-character string obtained from the <a
    href="!md5"><b>!md5</b></a> command for the script file.  When
    included, the script will not execute unless the script file has a
    matching MD5 digest, which ensures that the script file accessed
    is the correct one and hasn't been modified.
    </dl>

    <dl>
    <dt><b>Add a pc_params property</b><dd>
    Next, we program the pcell's parameters and default values by
    adding a <a href="prpty:pc_params"><b>pc_params</b></a> property. 
    In the <b>Cell Property Editor</b>, press <b>Add</b>, then select
    <b>pc_params</b> in the pop-up menu.

    <p>
    Again, one can use the "long text" editor, or type directly into
    the prompt line.  For long parameter lists, the editor would be
    preferred.  Enter the parameter list in the format described for
    this property string.  If using the editor, any combination of
    multiple lines and/or multiple specifications per line can be
    used.  A parameter specification consists of a parameter name
    followed by '<tt>=</tt>' and its value, optionally followed by a
    colon and a <a href="constraint">constraint</a> string.  There
    must be no white space around the colon that delimits the
    constraint string, but the constraint string itself may contain
    white space, which is ignored.

    <p>
    Save the text if using the text editor, or press <b>Enter</b> if
    using the prompt line, when done.
    </dl>

    <dl>
    <dt><b>Add additional properties</b><dd>
    There are other properties that may be required, to support <a
    href="pc_stretch">stretch handles</a> (draggable edges) and <a
    href="pc_abut">auto-abutment</a> protocols.  Text is added as for
    the properties we've described.  This may be a second pass, after
    getting the basic cell working.
    </dl>

    <p>
    Save the current cell to disk, the native format is probably
    most convenient.  Congratulations, you have yourself a pcell!

    <a name="inst"></a>
    <h2>Adding an Instance of a Parameterized Cell</h2>

    Adding a pcell to the current layout is the same procedure,
    whether the pcell is native, or not.  One adds an instance of a
    pcell like one would add an instance of any other cell.  If a
    native pcell, the cell file name can be given to the <b>New</b>
    text entry pop-up of the <a href="xic:place"><b>Cell Placement
    Control</b></a> panel brought up with the <b>place</b> button in
    the side menu.

!!IFDEF OpenAccess
    <p>
    Pcells saved in OpenAccess can be instantiated with the
    <b>Place</b> button in the <b>Contents</b> listing window from the
    <a href="xic:oalib"><b>OpenAccess Libraries</b></a> pop-up from
    the <b>File Menu</b>.  These cells are also available through the
    <b>Cell Placement Control</b> panel.  In the text input pop-up from
    the <b>New</b> button, enter the OpenAccess library name that
    contains the desired pcell, followed by space, then the pcell
    name.
!!ENDIF

    <p>
    When cell placement becomes active, by pressing the <b>Place</b>
    button the <b>Cell Placement Control</b> panel, the <a
    href="xic:pcparams"><b>Parameters</b></a> pop-up appears.  This
    pop-up displays a text entry area for every parameter, loaded with
    the default value.  The user can enter the values desired.

    <p>
    In addition, a double-line box is ghost-drawn and attached to the
    mouse pointer.  This figure does <b>not</b> represent the actual
    size of the instance, in fact it illustrates that the instance
    size is unknown.  The instance size will not be known until the
    parameter set is used to create or identify the corresponding
    sub-master cell.  This will happen when the user clicks in the
    drawing window to place an instance.  Better, the <b>Apply</b>
    button in the <b>Parameters</b> pop-up can be pressed, which will
    create a sub-master without instance placement.  The box attached
    to the mouse pointer will now be formed with a single line, and
    will have the actual size.

    <p>
    As with a normal cell, instances are placed where the user clicks. 
    Note that the <b>Parameters</b> pop-up remains visible while
    instances are being placed.  The parameters can be changed, and
    the <b>Apply</b> button pressed, to change the type of
    instantiation to be subsequently placed.  Note that the subsequent
    instances will use the new parameter values, pressing <b>Apply</b>
    merely updates the bounding box attached to the mouse pointer.

    <a name="instchange"></a>
    <h2>Changing the Parameters of an Instance</h2>

    Once a pcell has been instantiated, the instance can be changed to
    represent a new set of parameter values <b>if</b> the pcell
    is available.  Thus, when a design is exported to another
    site that may wish to modify the cell parameters, the pcells must
    be exported as well.  The pcells are <b>not</b>
    automatically added to GDSII files or the other file formats. 
    They can be supplied as <i>Xic</i> cells, in addition to the
    GDSII or other output.  Further, <i>Xic</i> native pcells are
    <b>not</b> directly portable to other design systems, they are
    known to <i>Xic</i> only.

    <p>
    One possible way to maintain native pcells is to place them
    in a <a href="libraries">library</a>.

    <p>
    Assuming that the pcell is available, one can change the
    parameters of an existing pcell instance with the following
    procedure.  First, <a href="selection">select</a> the pcell instance
    to modify.  Then, while holding down the <b>Ctrl</b> key, click on
    the selected pcell.  The <a
    href="xic:pcparams"><b>Parameters</b></a> panel will appear.  One
    can now change parameter values as needed, and press <b>Apply</b>
    to reparameterize the instance.

    <p>
    Less conveniently, the <b>pc_params</b> property can be edited
    with the <a href="xic:prpty"><b>Property Editor</b></a> with the
    same effect.  Bring up the <b>Property Editor</b> with the
    <b>Properties</b> button in the <b>Edit Menu</b>.  With the editor
    active, click on a pcell instance.  The instance will be marked,
    and its properties listed.  Among the listed properties will be
    the <b>pc_params</b>.  Click on this entry in the listing window,
    the text will show as selected.  Then, press the <b>Edit</b>
    button in the <b>Property Editor</b>, which will bring up our old
    friend the <b>Parameters</b> panel.  Adjust the parameters, then
    press <b>Apply</b>.  The new parameter set will be applied to the
    marked instance.

    <a name="submchange"></a>
    <h2>Changing the Parameters of a Sub-Master</h2>

    One can change all of the instances that use a particular
    parameter set to a new parameter set by changing the parameters of
    the sub-master cell of the instances.  The original pcell must be
    accessible, as for changing individual instances.  The procedure
    is to edit the parameters of a sub-master, which will have the
    effect of reparameterizing all of its instances.

    <p>
    A quick way to do this is to select an instance of the sub-master
    to be edited, and press the <a href="xic:push"><b>Push</b></a>
    button in the <b>Cells Menu</b>.  The editing context will be
    pushed to the sub-master.  The sub-master can also be selected for
    editing from the <a href="xic:cells"><b>Cells Listing</b></a>
    pop-up, or by giving its name in the <a
    href="xic:open"><b>Open</b></a> command.

    <p>
    With the sub-master as the current cell, bring up the <a
    href="xic:cprop"><b>Cell Property Editor</b></a> with the <b>Cell
    Properties</b> button in the <b>Edit Menu</b>.  The listing of
    properties will include a line for the <b>pc_params</b> property. 
    Select the property by clicking on it, then press the <b>Edit</b>
    button.  Again, the <b>Parameters</b> pop-up will appear.  One
    should modify the parameters desired, then press <b>Apply</b>. 
    The new parameter set will then apply to the instance pushed into,
    and all other instances of the same sub-master.  Use the
    <b>Pop</b> button in the <b>Cells Menu</b> to return to the
    original editing context if <b>Push</b> was used.
!!LATEX xic:pcells pcells.tex
Parameterized cells, or ``pcells'' (or sometimes called ``template
cells'') are cells which in addition to possible fixed geometry,
contain an executable program that creates geometry according to one
or more parameters supplied to the cell.  The cell is instantiated for
given sets of parameters, so that instances may have layouts that
differ.  Parameterized cells are often used to represent devices such
as MOSFETS that may come in many shapes and flavors.  The MOSFET
parameters select the size and other properties of each instantiation. 
As an alternative, in a process design kit one might find hundreds of
fixed-cells with different permutations of size and other parameters. 
A single parameterized cell that replaces the collection of fixed
cells can streamline the design process, provide greater flexibility,
and reduce errors.

%\ifoa
The full and {\XicII} feature sets have support for native and
OpenAccess-based portable pcells, as well as the ability to work with
the Cadence Virtuoso Express PCells$^{TM}$ feature.  The {\Xiv}
feature set, does not support pcells.

There is an ongoing effort to strengthen the parameterized
cell capabilities in {\Xic}.  The effort includes
\begin{itemize}
\item{Providing support for languages other than the native script
language.  In particular, the Python language appears to be the choice
for ``open'' pcells, i.e., pcells which can be used in tools from
different vendors.}

\item{Provide commonality and support for Ciranova open pcells and
standards.}

\item{Provide commonality and support for the OpenAccess pcell
framework.}
\end{itemize}
%\else
%The full and {\XicII} feature sets have support for native pcells.  The
%{\Xiv} feature set does not support pcells.
%
%Unfortunately, at the present time legal and financial constraints set
%by the controlling organization prevent use of OpenAccess in {\Xic}. 
%With OpenAccess, support for portable pcells, and the ability to work
%with the Cadence Virtuoso Express PCells feature, could be provided. 
%Please contact Whiteley Research if support for OpenAccess would be of
%use to you.  With sufficient demand, the decision to drop OpenAccess
%support may be revisited.
%\fi

\subsection{How PCells Work}
\index{pcell}
\index{super-master}
\index{sub-master}

Provided below are definitions of some terms used frequently in the
discussion that follows.
\begin{description}
\item{\et pcell}\\
A ``parameterized cell'' or ``template cell''.  This is a cell
containing an executable component, which acts on a set of one or more
parameters.  When placed in a layout, the cell constructs itself
according to the parameters given while instantiating.

\item{\et super-master}\\
A {\et pcell} in memory.

\item{\et sub-master}\\
A master cell created from a {\et super-master} and a given parameter
set.  Instances of the sub-master are actually placed into the layout. 
A {\et pcell} itself is never placed in a layout.
\end{description}

All pcells ``work'' as follows.  The pcell is supplied as a cell file
to the design system, which understands the file syntax.  Within the
design system, an in-memory object called a ``super-master'' is
created, which is an in-memory representation of the pcell.  This
element contains a list of parameter names, and for each parameter a
default value and acceptable range.  The element also provides, by
some means, a program or script that can be executed from the design
system.

When a user wishes to place an instance of a pcell, the pcell is
selected from a menu, which causes the pcell file to be read from disk
and a super-master created in memory.  The user will then specify the
parameter values to the cell to instantiate.  This is usually done
with a pop-up form, where the user can enter values for the various
parameters, all of which have defaults.  When this entry is complete,
the design system will execute the pcell script with the entered
parameter values.  The result will be creation of a cell in memory
containing geometry created by the script in accord with the
parameters.  This cell is called a ``sub-master''.  It is a normal
cell is every respect, though it has properties that link it to the
original pcell super-master.  Instances of this sub-master are created
where the user specifies.  A separate sub-master will be created for
every differing parameter set that the user provides.  Each instance
of a sub-master contains properties that contain the parameter set
used for instantiation, and the name of the original pcell.

\index{PCKEEP flag}
A design containing pcells can be saved in two ways.  For a local
save, for use in the same design environment, the super- and
sub-masters in memory are discarded (or the sub-masters may be
cached).  When the design is read in again, the instances provide the
location of the pcell and the parameter set, which are used to
recreate the sub-masters.  If instead the design is being sent to
another environment, one which perhaps does not handle the pcells, the
sub-masters can be written to disk as ordinary cells.  The resulting
hierarchy will be normal and portable.  In {\Xic}, sub-masters can be
included in saved archive files when the {\cb PCellKeepSubMasters}
variable or equivalently the check box in the {\cb Export Control}
panel is set, or when the {\et StripForExport} variable or equivalent
check box in the same panel is set.  If a cell is read from a file and
is recognized as a pcell sub-master, the PCKEEP cell flag will be set. 
This will cause the cell to be written to output, whether or not
writing of pcell sub-masters is enabled.

\subsection{PCell History and Status}

Historically, the pcell concept was developed for the Cadence Virtuoso
layout editor, and supported pcells used the Skill$^{TM}$ language
which is the scripting language of the Virtuoso system.  This remains
the dominant type of pcell around, due to the ubiquity of Cadence
installations.  However, the Skill language is not available outside
of the Cadence environment, so these pcells are not portable to other
tools.

The OpenAccess project addressed the pcell portability problem by
providing a standardized interface for pcells, with the execution
being carried out through a ``plug-in'' that a vendor, or user, may
supply.  A pcell, in concept, can be created to use any suitable
programming language, provided that the tool used to instantiate the
pcell is capable of executing that language.  With OpenAccess, the
portability problem is reduced to obtaining a plug-in for the pcell
language.

There are example plug-ins distributed with OpenAccess that handle Tcl
and C++.  Unfortunately, the Skill language is not available for
general use outside of the Cadence environment.  It is not really
attractive anyway, as it was developed back in the prehistoric days
when Lisp ws ``cool'', and abominations like EDIF seemed important. 
There are far better languages, such as Python, available today.

The concept of portable pcells was championed by a company called
Ciranova, that supplied an OpenAccess plug-in for Python.  They
released this, along with companion applications for Python pcell
(``PyCell'') development, examples, and precompiled OpenAccess and
Python libraries as a free ``PyCell Studio'' download.  Ciranova was
subsequently bought by Synopsys, but the PyCell Studio remains
available and apparently is still under development.  An industry
group, IPLnow.com ({\vt http://www.iplnow.com}) which includes TSMC
and other foundries and some tool vendors, is pushing the cause of
``interoperable'' PDK libraries based on portable pcells.

%\ifoa
{\Xic} is intended to be fully compatible with the PyCell Studio and
PyCells, through the OpenAccess interface plug-in.  In addition,
{\Xic} without OpenAccess provides support for Python pcells, and the
Ciranova protocols for stretch handles and abutment.  However,
Ciranova provides a number of library modules and functions as part of
its Python implementation that are not present without the Ciranova
plug-in and OpenAccess.

{\Xic} with OpenAccess has some limited capability with Skill-based
pcells through the Virtuoso Express PCells feature.  This allows
export is pre-instantiated cached sub-masters of pcells, but not the
pcells themselves.  This capability is provided through the same
OpenAccess plug-in technology mentioned above, but in this case if the
parameter set does not have a pre-built sub-master in cache, the
instantiation will fail.

The {\cb !rmpcprops} command will remove the properties that make
pcells special throughout the hierarchy of the current cell.  This
operation is not undoable, and renders the hierarchy henceforth free
of any pcell history.  The user may wish to do this to hierarchies
imported from Virtuoso, as the Skill pcells can not be evaluated in
the {\Xic} environment.  In this case, retaining the pcell identities
may be pointless, and in fact this may cause trouble, for example when
writing output pcell sub-masters are not written unless the user
overrides the default (e.g., by checking the box in the {\cb Export
Control} panel).
%\else
%Currently, support for OpenAccess pcells is not available.  OpenAccess
%support can easily be provided by paying what amounts to a commercial
%use fee.  Users who may need this feature are encouraged to lobby
%Whiteley Research Inc..
%\fi

\subsection{{\Xic} Native PCells}
\label{pcnative}
\index{native pcell}

{\Xic} supports pcells using the native scripting language, plus
Python or Tcl if the respective plug-ins are loaded.  Parameterized
cells are supported only in physical mode.  This section will describe
how to create and use native pcells in {\Xic}.
%\ifoa
By ``native'', execution within {\Xic} rather than through OpenAccess
is meant.  As will be seen, native pcells can be saved in OpenAccess,
too, and they are still native.
%\fi

There are several example native pcells provided in the examples
directory of the {\it Xic} installation.  These provide samples of the
syntax used in the property strings and other aspects, with comments,
and their study should facilitate understanding how to write native
pcells.

A native pcell can be saved in any format supported by {\Xic}, with
certain limitations to be described.  Probably, the native cell format
is the most convenient.  These can be easily edited with a text
editor, which the advanced developer is likely to do on occasion.

A pcell can have any name that is compatible with {\Xic}.  Earlier
releases of {\Xic} required that a pcell name have a literal ``{\vt
XXX}'' suffix.  This is no longer the case, but if the {\vt XXX} is
present, it will be stripped in sub-master names and replaced with a
unique identifying code for the parameter set.  Otherwise, the code is
appended to the pcell name.

Super- and sub-master cells, and sub-master instances, differ from
normal cells and instances by the presence of a few special
properties.  These are:

\begin{description}
\index{properties!pc\_name}
\index{pc\_name property}
\item{\et pc\_name} property, number 7197\\
This property is assigned by {\Xic} to pcell sub-masters and their
instances.  It provides the name of the pcell from which the
sub-master or instance was derived.

\index{properties!pc\_params}
\index{pc\_params property}
\item{\et pc\_params} property, number 7198\\
This property is assigned by the user to pcells, and contains the
default parameter set.  It will be assigned by {\Xic} to sub-masters
and instances, and contains the parameter set that was used to create
the sub-master.

The string of the {\et pc\_params} property has the form
\begin{quote}
[{\it typechar\/}:]{\it name\/}[{\vt =}]{\it value}[:{\it constraint\/}]
 [[{\vt ,}] ...]  
\end{quote}

The string consists of a series of {\it name} and {\it value} tokens. 
The {\it name}s can not contain white space or punctuation.  Ahead of
the {\it name} is a type specification character if the value is not
string type.  In native pcells, all parameters are (for this purpose)
string type, so the type specifier will never appear.  However, the
syntax used may be extended in future, so it is documented in the
table below.  All types except for string type will have a specifier.
%\ifoa
These {\bf will} appear in property strings obtained from OpenAccess
for non-native pcells.
%\fi

\begin{quote}
\begin{tabular}{ll}\\
\vt b & boolean\\
\vt i & integer\\
\vt t & time value\\
\vt f & 32-bit float\\
\vt d & 64-bit float\\
\end{tabular}
\end{quote}

Each of the {\it name} tokens is the name of a parameter that can be
applied to the pcell.  These will become names of variables in the
script, so that these names should not be defined or used in the
script text in a conflicting way.

Every {\it name} should have a {\it value}, an ``empty'' value is
specified as an empty string ({\vt ""}).  The {\it value} is separated
from the {\it name} by white space, a comma, or an equal sign.  The
{\it values} are taken as default values for the parameters, and can
be numeric values or strings.  A {\it value} that contains white
space, commas, or colons should be quoted.  The value string can also
be an executable code fragment using only parameters already defined
(to the left) and constants, for example

\begin{quote} \vt
param1=2,param2="param1 + 1"
\end{quote}

This form, however, can not be used with constraints (see below).  It
can also only appear in super-master {\et pc\_params} properties.  the
{\et pc\_params} strings of sub-masters and instances must have
constant values.

The quoting behavior is a bit complicated, so as to support Python and
native languages.  If the {\it value} is quoted with double-quote
marks, the double quote marks will be stripped, and the parameter will
take the enclosed characters.  However, if a backslash character
(`$\backslash$') appears ahead of the first double quote, the double
quote marks will be retained.  In the native language, this will
ensure that the parameter is string-type.

For example
\begin{quote} \vt
myvar="123"
\end{quote}
The parameter (variable) {\vt myvar} will be assigned the value 123,
causing it to become scalar-type.  On the other hand
\begin{quote} \vt
myvar=$\backslash$"123"
\end{quote}
will assign {\vt "123"} to {\vt myvar} (including the quotes) thus
{\vt myvar} will be string-type.  In general, if the {\it value} is to
be taken as a string constant in the native language, a backslash
should be placed ahead of the first double quote mark.

If the {\it value} is quoted with single-quote marks, the single-quote
marks are retained, along with the characters between them.  This is
for Python support.  However, if the second character is a
double-quote mark, the single-quote marks will be stripped, leaving
the double-quoted result.  This is an alternative and somewhat
deprecated way to specify a string constant in the native language.

\begin{quote} \vt
mystring='"a string constant"'
\end{quote}

In any case, when the parser is searching for the ending quote mark
(single or double), if the mark is found but it is preceded by a
backslash, both characters are taken verbatim and the search
continues.  Thus, the backslash can be used to hide quote marks of the
same type in the string.

If the {\it value} is a constant (not an executable fragment), the
{\it value} can be followed by an optional constraint specification,
separated from the {\it value} by a colon (no white space is allowed
around the colon).  Constraints define the scceptable values for the
parameter, using a syntax described in \ref{constraints}.  The
constraints appear only in {\et pc\_params} properties of
super-masters, and are not copied to {\et pc\_params} properties of
sub-masters and instances.

The parameter string is logically converted to a series of assignment
statements which are executed before the script.  For example, the
parameter string
\begin{quote}
\vt param1=1.0,name=$\backslash$"my template",param2="param1 * 2"
\end{quote}
would map to the following logical script lines
\begin{quote} \vt
param1 = 1.0\\
name = "my template"\\
param2 = param1 * 2
\end{quote}

\index{pc\_script property}
\index{properties!pc\_script}
\item{\et pc\_script} property, number 7199\\
This property is assigned by the user to a pcell, and appears only in
the super-master.  It contains the script, or a path to a script,
which is executed when the pcell is instantiated.

The {\et pc\_script} property text is in the form
\begin{quote}
[{\vt @LANG} {\it langtok\/}] {\vt @READ} {\it path}
 [{\vt @MD5} {\it digest\/}] {\vt |} {\it script text}
\end{quote}
 
The {\vt @LANG}, {\vt @READ}, and {\vt @MD5} tokens are literal.  The
{\it langtok} may be one of (case insensitive)
\begin{quote}
\begin{tabular}{ll}\\
{\vt n}[{\vt ative}] & native sript, the default\\
{\vt p}[{\vt ython}] & python script\\
{\vt t}[{\vt cl}] & tcl script\\
\end{tabular}
\end{quote}
 
The {\it path} token must appear if {\vt @READ} is given.  If {\vt
@READ} is not given, any remaining text is taken as literal executable
script text.

The {\it path} is to a file containing the executable text, and should
be quoted if it contains white space.  If the {\it path} is not
rooted, it will be searched for in a directory search path set in the
{\et PCellScriptPath} variable.

When a path is given, one can also apply the {\vt @MD5} {\it digest}
clause.  The {\it digest} is that for the script file, and can be
obtained from the {\cb !md5} command, or the {\vt Md5Digest} script
function, or from the command
\begin{quote}
{\vt openssl dgst -md5} {\it filepath}
\end{quote}
on most Linux systems.  If given, the script file digest must match
the digest given, or the script will not be executed.  This will
ensure that only the ``correct'' script file is used.
\end{description}

Previous versions of {\Xic} required that the script actually appear
in the {\et pc\_script} property string.  This can still be done, and
may be convenient for many pcells, particularly very simple ones. 
However, one may encounter a portability issue caused by string length
limitations of the GDSII and CGX formats due to their maximum record
length of 64KB.  The native cell format, the CIF format as extended by
Whiteley Research, and the OASIS format have no built-in string length
%\ifoa
limit, nor does OpenAccess.
%\else
%limit.
%\fi

When using separate script files, for portability it may be best to
{\bf not} provide a full path to the script in the {\et pc\_script}
property string, but give the file name only and use the search path
variable.  Then, the scripts can be kept in different locations at
different {\Xic} installations, and pcells will still be portable
provided the {\et PCellScriptPath} is set (probably from an
initialization file).  The {\vt MD5} digest keying can ensure that the
script file found via the search path is correct, or it will not
execute.

The script, whether in a separate file or not, is basically
conventional, and uses the native object creation functions to build
up the geometry, presumably using the parameter values as input.  The
example native pcells provided with the {\Xic} distributions in the
examples directory illustrate how the script is incorporated.

One aspect of importance is the script return value, which will tell
the calling program whether or not script evaluation succeeded.  If
evaluation fails, {\Xic} can gracefully ``clean up'' by destroying
partially completed sub-masters, and any corresponding instance
placements, and alerting the user to the error.

The script should return 0 (zero) on success, which is the default if
no explicit return value is specified.  Any nonzero return value
indicates faliure.  The mechanics of setting the return value differs
between the supported languages, and is described below.  In every
case, just before a nonzero value is returned, the {\vt AddError}
function should be called with a message explaining the error.

\begin{description}
\item{Native}\\
The {\vt return} keyword, followed by a value, will terminate the scrpt
and return the value.  For example, here is a snippet that checks the
value of a parameter named ``{\vt top}'' and fails if it is out of range:
\begin{quote} \vt
if (top < 1 | top > 20)\\
\hspace*{5mm}AddError("Parameter top is out of range [1 - 20].")\\
\hspace*{5mm}return 1\\
end
\end{quote}

Actually, if the value following {\vt return} is omitted, the return
value is 1, so just a bare ``{\vt return}'' will signal the error
condition.  If the end of execution is reached and no {\vt return}
keyword is encountered, the value returned is 0 (success).  If the
script is terminated with the {\vt Halt} or {\vt Exit} functions, the
return value is 0.  If the script is halted by an internal error, the
return value is -1.  If the script is halted due to an interrupt
signal, the return value is 1.

\item{Python}\\
The recommended way to induce an error exit in a Python script is to
call ``{\vt sys.exit}'' with a nonzero argument.  The example above
translated to Python will read:
\begin{quote} \vt
if (top < 1 or top > 20):\\
\hspace*{5mm}xic.AddError("Parameter top is out of range [1 - 20].")\\
\hspace*{5mm}sys.exit(1)
\end{quote}

Errors detected by the Python interpreter are passed back as nonzero
exit returns.

\item{Tcl}\\
The recommended way to induce an error exit from a Tcl script is to
call ``{\vt return -code error}''.  The example above translated to
Tcl will read:
\begin{quote} \vt
if \{\$top < 1 || \$top > 20\} \{\\
\hspace*{5mm}AddError \{"Parameter top is out of range [1 - 20]."\}\\
\hspace*{5mm}return -code error\\
\}
\end{quote}

Errors detected by the Tcl interpreter are passed back as nonzero exit
returns.
\end{description}

To summarize, a pcell is never itself instantiated.  When one
places an instance of a pcell, the following steps occur:

\begin{enumerate}
\item{The pcell is read into memory as a ``super-master'' if it
is not already there.}

\item{The user enters the parameter values.}

\item{The database is searched for another cell derived from the same
pcell with the same parameter values, i.e., an equivalent sub-master. 
If one is found, a new instance is created and given {\et pc\_name}
and {\et pc\_params} properties copied from the sub-master, and we're
done.}

\item{Otherwise, the script is executed, in the context of a new,
empty cell whose name consists of the pcell name suffixed by a unique
identifier.  This is the sub-master cell.  It is given a {\et
pc\_name} property to identify the pcell, and a {\et pc\_params}
property to list the parameters used.  The new sub-master is
instantiated and the instance given the same two properties, and we're
done.}
\end{enumerate}

Once the instance is placed, it behaves in all respects as a normal
cell.  It has a ``master'' derived from the pcell as a sub-master, and
a unique sub-master exists for each unique parameter set.  Writing the
hierarchy, including the sub-masters, to an archive produces a
perfectly normal file.  However, by default the sub-masters are {\bf
not} written to output, instead they are expected to be recreated from
the pcell when needed.  The pcells (super-masters) are {\bf never}
included in the output file, since they are not directly instantiated
in the hierarchy.  Thus, when exporting, the pcell should be supplied
separately, if needed.  If sub-masters are included in the archive,
then the pcell is not needed, unless further parameter changes are
required.  In {\Xic}, sub-masters can be included in saved archive
files when the {\et PCellKeepSubMasters} variable or equivalently the
check box in the {\cb Export Control} panel is set, or when the
{\et StripForExport} variable or equivalent check box in the same
panel is set.

\subsection{Creation of a Native Parameterized Cell}

To create a native pcell, one can follow this procedure:

\begin{description}
\item{\bf Write the script}\\
Write a script that creates the geometry desired, in response
to a set of variables that will become the parameters.  The script
can be authored as any other script.  It should be thoroughly
debugged before committing it to a parameterized cell.

It is recommended that the top of the script contain a comment listing
the parameters and their purposes, and explicit tests of the values
that will abort the script (returning nonzero) if a value is out of
range or otherwise not acceptable.  Any nonzero return should have a
call to {\vt AddError} explaining the error.  This text will be
included in the system error reporting.

\item{\bf Create the parameterized cell}\\
Use the {\cb Open} ({\cb File menu}) command to edit a new cell which
will become the pcell.  Add any fixed geometry to the cell that is
necessary.  This can be done at any time.  Keep this cell as the
current cell and add the properties listed below.

\item{\bf Add the {\et pc\_script} property}\\
Bring up the {\cb Cell Property Editor} ({\cb Edit Menu}).  Press {\cb
Add}, which brings up a pop-up menu, and select {\cb pc\_script} in
the pop-up menu.  This will prompt for the property string on the
prompt line.

At this point we need to decide whether to incorporate the script
into the property string itself, or to keep the script in a separate
file.  One consideration is that GDSII and CGX files have 16-bit record
lengths, which will limit the lengths of property strings.  In the
present {\Xic} release, CIF and native string lengths, and
OASIS string lengths, are unlimited.
%\ifoa
There is also no limit when storing the cell in OpenAccess.
%\fi

First, assume that the script is to be stored in the property string. 
We will use the ``long text'' feature to facilitate entering the
script.

\item{\bf Enter property text with script}\\
Press the ``{\cb L}'' button to the left of the prompt line.  This
brings up the {\cb Text Editor} pop-up.  If the script text is Python
or Tcl, a {\vt @LANG} specification must appear first.  Type one of
the following into the editor window.  For Python
\begin{quote}
\vt @LANG Python
\end{quote}
or if Tcl
\begin{quote}
\vt @LANG Tcl
\end{quote}
Neither is needed for native script language.

The next step is to import the script text.  This is presumed to exist
in a file, though for very simple scripts an advanced user can type it
in.  For the script in a file, one can use the {\cb Read} button of
the text editor (in the {\cb File} menu) to read in the script file. 
Then perform any last minute editing, such as removal of the variable
declarations that would be redundant with the parameters.

Press the {\cb Save} button in the {\cb File} menu of the text editor. 
The text editor will disappear, and the script will have been saved in
the {\et pc\_script} property of the current cell.

\item{\bf Enter property text without script}\\
One can use the ``long text'' text editor feature, or simply type into
the prompt line.  Without the script, there generally isn't much to
type.

First, if the script text is Python or Tcl, one must enter a {\vt
@LANG} specifier as explained above.  If needed, just type in the two
tokens.  Next, enter a {\vt @READ} directive in the form
\begin{quote}
{\vt @READ} {\it path}
\end{quote}
where {\it path} is a path to the file containing the script.  This
can be an absolute path, however it may be more convenient to just
specify the file name, and set the {\et PCellScriptPath} variable to a
directory where pcell script files are kept.  Then, the location can
change without one having to edit the property string.  This completes
text entry.  Exit the text editor as above if it is being used, or
press {\kb Enter} to terminate text entry into the prompt line.  The
text is saved in the {\et pc\_script} property of the current cell.

Optionally, one can append a directive of the form
\begin{quote}
{\vt @MD5} {\it digest}
\end{quote}
The {\it digest} is the 32-character string obtained from the {\cb
!md5} command for the script file.  When included, the script will not
execute unless the script file has a matching MD5 digest, which
ensures that the script file accessed is the correct one and hasn't
been modified.

\item{\bf Add a {\et pc\_params} property}\\
Next, we program the pcell's parameters and default values by adding a
{\et pc\_params} property.  In the {\cb Cell Property Editor} ({\cb
Edit Menu}), press {\cb Add}, then select {\cb pc\_params} in the
pop-up menu.

Again, one can use the ``long text'' editor, or type directly into the
prompt line.  For long parameter lists, the editor would be preferred. 
Enter the parameter list in the format described for this property
string (see \ref{pcnative}).  If using the editor, any combination of
multiple lines and/or multiple specifications per line can be used.  A
parameter specification consists of a parameter name followed by `{\vt
=}' and its value, optionally followed by a colon and a constraint
string (see \ref{constraints}).  There must be no white space around
the colon that delimits the constraint string, but the constraint
string itself may contain white space, which is ignored.

Save the text if using the text editor, or press {\kb Enter} if using
the prompt line, when done.

\item{\bf Add additional properties}\\
There are other properties that may be required, to support stretch
handles (draggable edges, see \ref{pcstretch}) and auto-abutment (see
\ref{pcabut}) protocols.  Text is added as for the properties we've
described.  This may be a second pass, after getting the basic cell
working.
\end{description}

Save the current cell to disk, the native format is probably
most convenient.  Congratulations, you have yourself a pcell!

\subsection{Adding an Instance of a Parameterized Cell}

Adding a pcell to the current layout is the same procedure, whether
the pcell is native, or not.  One adds an instance of a pcell like one
would add an instance of any other cell.  If a native pcell, the cell
file name can be given to the {\cb New} text entry pop-up of the {\cb
Cell Placement Control} panel brought up with the {\cb place} button
in the side menu.

%\ifoa
Pcells saved in OpenAccess can be instantiated with the {\cb Place}
button in the {\cb Contents} listing window from the {\cb OpenAccess
Libraries} pop-up from the {\cb File Menu}.  These cells are also
available through the {\cb Cell Placement Control} panel.  In the text
input pop-up from the {\cb New} button, enter the OpenAccess library
name that contains the desired pcell, followed by space, then the
pcell name.
%\fi

When cell placement becomes active, by pressing the {\cb Place} button
the {\cb Cell Placement Control} panel, the {\cb Parameters} pop-up
appears.  This pop-up displays a text entry area for every parameter,
loaded with the default value.  The user can enter the values desired.

In addition, a double-line box is ghost-drawn and attached to the
mouse pointer.  This figure does {\bf not} represent the actual size
of the instance, in fact it illustrates that the instance size is
unknown.  The instance size will not be known until the parameter set
is used to create or identify the corresponding sub-master cell.  This
will happen when the user clicks in the drawing window to place an
instance.  Better, the {\cb Apply} button in the {\cb Parameters}
pop-up can be pressed, which will create a sub-master without instance
placement.  The box attached to the mouse pointer will now be formed
with a single line, and will have the actual size.

As with a normal cell, instances are placed where the user clicks. 
Note that the {\cb Parameters} pop-up remains visible while instances
are being placed.  The parameters can be changed, and the {\cb Apply}
button pressed, to change the type of instantiation to be subsequently
placed.  Note that the subsequent instances will use the new parameter
values, pressing {\cb Apply} merely updates the bounding box attached
to the mouse pointer.

\subsection{Changing the Parameters of an Instance}

Once a pcell has been instantiated, the instance can be changed to
represent a new set of parameter values {\bf if} the pcell is
available.  Thus, when a design is exported to another site that may
wish to modify the cell parameters, the pcells must be exported as
well.  The pcells are {\bf not} automatically added to GDSII files or
the other file formats.  They can be supplied as {\Xic} cells, in
addition to the GDSII or other output.  Further, {\Xic} native pcells
are {\bf not} directly portable to other design systems, they are
known to {\Xic} only.

One possible way to maintain native pcells is to place them
in a library.

Assuming that the pcell is available, one can change the parameters of
an existing pcell instance with the following procedure.  First,
select the pcell instance to modify.  Then, while holding down the
{\kb Ctrl} key, click on the selected pcell.  The {\cb Parameters}
panel will appear.  One can now change parameter values as needed, and
press {\cb Apply} to reparameterize the instance.

Less conveniently, the {\et pc\_params} property can be edited with
the {\cb Property Editor} with the same effect.  Bring up the {\cb
Property Editor} with the {\cb Properties} button in the {\cb Edit
Menu}.  With the editor active, click on a pcell instance.  The
instance will be marked, and its properties listed.  Among the listed
properties will be the {\et pc\_params}.  Click on this entry in the
listing window, the text will show as selected.  Then, press the {\cb
Edit} button in the {\cb Property Editor}, which will bring up our old
friend the {\cb Parameters} panel.  Adjust the parameters, then press
{\cb Apply}.  The new parameter set will be applied to the marked
instance.

\subsection{Changing the Parameters of a Sub-Master}

One can change all of the instances that use a particular parameter
set to a new parameter set by changing the parameters of the
sub-master cell of the instances.  The original pcell must be
accessible, as for changing individual instances.  The procedure is to
edit the parameters of a sub-master, which will have the effect of
reparameterizing all of its instances.

A quick way to do this is to select an instance of the sub-master to
be edited, and press the {\cb Push} button in the {\cb Cells Menu}. 
The editing context will be pushed to the sub-master.  The sub-master
can also be selected for editing from the {\cb Cells Listing} pop-up
({\cb Cells Menu}), or by giving its name in the {\cb Open} command
({\cb File menu}).

With the sub-master as the current cell, bring up the {\cb Cell
Property Editor} with the {\cb Cell Properties} button in the {\cb
Edit Menu}.  The listing of properties will include a line for the
{\et pc\_params} property.  Select the property by clicking on it,
then press the {\cb Edit} button.  Again, the {\cb Parameters} pop-up
will appear.  One should modify the parameters desired, then press
{\cb Apply}.  The new parameter set will then apply to the instance
pushed into, and all other instances of the same sub-master.  Use the
{\cb Pop} button in the {\cb Cells Menu} to return to the original
editing context if {\cb Push} was used.
    
!!SEEALSO
xic:pcparams
pc_stretch
pc_abut

!! 102214
!!KEYWORD
constraint
!!TITLE
Parameter Constraints
!!HTML
    Constraints are described by text strings included in the <a
    href="prpty:pc_params"><b>pc_params</b></a> property contained in
    the super-master cell.  Constraints do not appear in the
    sub-master or instance properties.
!!IFDEF OpenAccess
    Constraint support is also provided for Ciranove/Python
    OpenAccess pcells, though the constraint strings are provided by
    another method internally as there are no corresponding
    super-master <i>Xic</i> cells.
!!ENDIF

    <p>
    In <i>Xic</i>, constraints are mainly handled in the <a
    href="xic:pcparams"><b>Parameters</b></a> panel, which is where
    parameter setting is primarily handled.  The constraints may
    affect the type of input widget for the parameter.  It will not be
    possible to set a value for the parameter that is not allowed by
    the associated constraint.

    <p>
    The constraint strings follow closely the Ciranova format.  Each
    is in the form of a Python function call, with a set of arguments
    that define the constraint.  The arguments can be either
    positional or named.  For example, the <tt>range</tt> constraint
    has the following template:

    <blockquote>
    <tt>range(</tt><i>low</i>,<i>high</i>,<i>resolution</i>=<tt>None</tt>,<i>action</i>=<tt>REJECT)</tt>
    </blockquote>

    The two final arguments have defaults, and are therefor optional. 
    Arguments can be given positionally, or as an assignment using the
    argument name keyword.  The following forms are equivalent:

    <blockquote>
    <tt>range(0,10)</tt><br>
    <tt>range(high=10,low=0)
    </blockquote>

    The first line follows the argument order of the template.  The
    second line does not, but supplies the argument name explicitly. 
    Arguments can appear in any order if the name is given.  An
    argument list can use both positional and explicit assignment. 
    Note that the <i>resolution</i> and <i>action</i> arguments are
    not given in either example, so that the defaults will be used.

    <p>
    All keywords are case-insensitive.

    <p>
    Each constraint type contains an <i>action</i> argument, which can
    be set to one of the literal enumerators <tt>REJECT</tt>,
    <tt>ACCEPT</tt>, or <tt>USE_DEFAULT</tt>.  This specifies what
    happens when an attempt is made to set the parameter to a value not
    allowed by the constraint.  The <tt>REJECT</tt> option (the
    default) will simply fail, causing the command that initiated the
    operation to also fail.  The <tt>ACCEPT</tt> action will accept
    the new parameter value, basically ignoring the constraint.  The
    <tt>USE_DEFAULT</tt> option is intended to reset the parameter to
    the default value when the constraint test fails, but this is not
    implemented in <i>Xic</i>, <tt>REJECT</tt> will be done instead. 

    <p>
    The enumeration value <tt>None</tt> can be given to most
    arguments.  This usually means to ignore the argument, and skip
    any test that would use the argument.  For example, a range
    constraint may give a <i>high</i> value of <tt>None</tt>, meaning
    that the parameter value can be arbitrarily large.

    <p>
    The available constraint types are as follows.

    <dl>
    <dt><tt>choice</tt><dd>
    The <tt>choice</tt> constraint restricts the parameter to a number
    of alternatives.  These alternatives can be numbers or strings, as
    appropriate for the parameter data type.  The keyword
    "<tt>choiceConstraint</tt>" is a (case-insensitive) synonym.  The
    template is

    <blockquote>
    <tt>choice(</tt><i>choices</i>,<i>action</i>=<tt>REJECT)</tt>
    </blockquote>

    where the <i>choices</i> argument is a list in the form

    <blockquote>
    <tt>[</tt><i>element</i>,<i>element</i>...<tt>]</tt>
    </blockquote>

    The square brackets are literal, <i>elements</i> are numbers or
    strings (single or double-quoted) which are separated by commas.

    <p>
    Examples:<br>
    <tt>choice([1,2,4,8])</tt><br>
    <tt>choice(["red","green","blue"])</tt>

    <p>
    The first line restricts the numeric parameter to the values
    listed.  The second line would restrict a string parameter to the
    strings listed.  Note that if the script is Python, single quotes
    must be used instead of double quotes.  Single or double quotes
    can be used with native scripts.
    </dl>

    <dl>
    <dt><tt>range</tt><dd>
    The <tt>ramge</tt> constraint restricts a numerical parameter to a
    range of values.  The keyword "<tt>rangeConstraint</tt>"
    (case-insensitive) is a synonym.  The template is

    <blockquote>
    <tt>range(</tt><i>low</i>,<i>high</i>,<i>resolution</i>=<tt>None</tt>,<i>action</i>=<tt>REJECT)</tt>
    </blockquote>

    The <i>low</i> and <i>high</i> are numerical endpoints of the
    range.  Either can be the enumeration value <tt>None</tt>, which
    skips testing against that endpoint.  For example,

    <blockquote>
    <tt>range(0,None)
    </blockquote>

    simply indicates that the value must be zero or larger.

    <p>
    The numerical values passed for <i>low</i> and <i>high</i> must be
    consistent with the language used for the script.  In particular,
    Python requires a standard integer or floating-point format.  The
    native language allows SPICE-type numbers (e.g., 1.2K), hex
    numbers with a "<tt>0x</tt>" prefix (e.g., <tt>0xff00</tt>) and
    character constants (e.g., <tt>'\n'</tt>) in addition.

    <p>
    The <i>resolution</i> argument is used in the <a
    href="xic:pcparams"><b>Parameters</b></a> panel to set the number
    of <a href="xic:pcparams#resol">digits</a> to include following a
    decimal point.
    </dl>

    <dl>
    <dt><tt>step</tt><dd>
    The <tt>step</tt> constraint limits the numerical parameter value
    to multiples of a given delta between a starting and ending value. 
    The keyword "<tt>stepConstraint</tt>" (case-insensitive) is a
    synonym.  The template is

    <blockquote>
    <tt>step(</tt><i>step</i>,<i>start</i>=<tt>0</tt>,<i>limit</i>=<tt>None</tt>,<i>resolution</i>=<tt>None</tt>,<i>action</i>=<tt>REJECT)</tt>
    </blockquote>

    The parameter must be numeric.  If the <i>step</i> value is 0 or
    <tt>None</tt>, the constraint acts the same as the <tt>range</tt>
    constraint, with <i>start</i> and <i>limit</i> providing the low
    and high values, respectively.

    <p>
    Otherwise, the allowed values are given by

    <blockquote>
    <i>start</i> <tt>+ N*</tt><i>step</i>
    </blockquote>

    where <tt>N</tt> is a non-negative integer, and the value of the
    expression is within the range terminated by <i>limit</i>, if
    <i>limit</i> is not <tt>None</tt>.  Note that <i>step</i> can be
    negative, in which case the parameter value must be greater than
    or equal to <i>limit</i>.

    <p>
    The <i>resolution</i> is treated as in the <tt>range</tt>
    constraint.
    </dl>

    <dl>
    <dt><tt>numericStep</tt><dd>
    This is very much like the <tt>step</tt> constraint, but is
    intended for use with string variables used for numeric input to
    support SPICE-like multipliers.  This is needed for script
    languages that don't handle numbers in this format.  Since the
    native script language understands this number format directly, it
    is not clear that the <tt>numericStep</tt> constraint will ever be
    needed in pcells with native scripts.  The keyword
    "<tt>numericStepConstraint</tt>" is a synonym.  The template is

    <blockquote>
    <tt>step(</tt><i>step</i>,<i>start</i>=<tt>0</tt>,<i>limit</i>=<tt>None</tt>,<i>resolution</i>=<tt>None</tt>,<i>scaleFactor</i>=<tt>'u'</tt>,<i>action</i>=<tt>REJECT)</tt>
    </blockquote>

    The arguments are the same as for the <tt>step</tt> constraint,
    with the addition of <i>scaleFactor</i>.  The <i>scaleFactor</i>
    is a string set to one of the scaling suffixes from the table
    below:

    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th>suffix</th> <th>multiplier</th> <th>name</th></tr>
    <tr><td><tt>a</tt></td> <td><tt>1e-18</tt></td> <td><tt>atto</tt></td></tr>
    <tr><td><tt>f</tt></td> <td><tt>1e-15</tt></td> <td><tt>femto</tt></td></tr>
    <tr><td><tt>p</tt></td> <td><tt>1e-12</tt></td> <td><tt>pico</tt></td></tr>
    <tr><td><tt>n</tt></td> <td><tt>1e-9</tt></td> <td><tt>nano</tt></td></tr>
    <tr><td><tt>u</tt></td> <td><tt>1e-6</tt></td> <td><tt>micro</tt></td></tr>
    <tr><td><tt>m</tt></td> <td><tt>1e-3</tt></td> <td><tt>milli</tt></td></tr>
    <tr><td><tt>mil</tt></td> <td><tt>25.4</tt></td> <td><tt>mil</tt></td></tr>
    <tr><td><tt>k</tt></td> <td><tt>1e3</tt></td> <td><tt>kilo</tt></td></tr>
    <tr><td><tt>meg</tt></td> <td><tt>1e6</tt></td> <td><tt>mega</tt></td></tr>
    <tr><td><tt>g</tt></td> <td><tt>1e9</tt></td> <td><tt>giga</tt></td></tr>
    <tr><td><tt>t</tt></td> <td><tt>1e12</tt></td> <td><tt>tera</tt></td></tr>
    </table>
    </blockquote>

    The scale fastor is case-insensitive.  If the <i>scaleFactor</i>
    is assigned the value <tt>None</tt>, no scale fastor is assumed,
    and the constraint is basically identical to <tt>step</tt>.  If a
    scale factor is given, numbers given for <i>step</i>,
    <i>start</i>, and <i>limit</i> are internally multiplied by the
    scale factor, before comparison to the parameter value.
!!LATEX constraint pcells.tex
Constraints are described by text strings included in the {\et
pc\_params} property contained in the super-master cell.  Constraints
do not appear in the sub-master or instance properties.
%\ifoa
Constraint support is also provided for Ciranove/Python OpenAccess
pcells, though the constraint strings are provided by another method
internally as there are no corresponding super-master {\Xic} cells.
%\fi

In {\Xic}, constraints are mainly handled in the {\cb Parameters}
panel (see \ref{pcparams}), which is where parameter setting is
primarily handled.  The constraints may affect the type of input
widget for the parameter.  It will not be possible to set a value for
the parameter that is not allowed by the associated constraint.

The constraint strings follow closely the Ciranova format.  Each is in
the form of a Python function call, with a set of arguments that
define the constraint.  The arguments can be either positional or
named.  For example, the {\vt range} constraint has the following
template:

\begin{quote}
{\vt range(}{\it low\/},{\it high\/},{\it resolution\/}={\vt None},{\it
 action\/}={\vt REJECT)}
\end{quote}

The two final arguments have defaults, and are therefor optional. 
Arguments can be given positionally, or as an assignment using the
argument name keyword.  The following forms are equivalent:

\begin{quote} \vt
range(0,10)\\
range(high=10,low=0)
\end{quote}

The first line follows the argument order of the template.  The second
line does not, but supplies the argument name explicitly.  Arguments
can appear in any order if the name is given.  An argument list can
use both positional and explicit assignment.  Note that the {\it
resolution} and {\it action} arguments are not given in either
example, so that the defaults will be used.

All keywords are case-insensitive.

Each constraint type contains an {\it action} argument, which can be
set to one of the literal enumerators {\vt REJECT}, {\vt ACCEPT}, or
{\vt USE\_DEFAULT}.  This specifies what happens when an attempt is
made to set the parameter to a value not allowed by the constraint. 
The {\vt REJECT} option (the default) will simply fail, causing the
command that initiated the operation to also fail.  The {\vt ACCEPT}
action will accept the new parameter value, basically ignoring the
constraint.  The {\vt USE\_DEFAULT} option is intended to reset the
parameter to the default value when the constraint test fails, but
this is not implemented in {\Xic}, {\vt REJECT} will be done instead.

The enumeration value {\vt None} can be given to most arguments.  This
usually means to ignore the argument, and skip any test that would use
the argument.  For example, a range constraint may give a {\it high}
value of {\vt None}, meaning that the parameter value can be
arbitrarily large.

The available constraint types are as follows.

\begin{description}
\item{\vt choice}\\
\index{choice constraint}
The {\vt choice} constraint restricts the parameter to a number of
alternatives.  These alternatives can be numbers or strings, as
appropriate for the parameter data type.  The keyword ``{\vt
choiceConstraint}'' is a (case-insensitive) synonym.  The template is

\begin{quote}
{\vt choice(}{\it choices\/},{\it action\/}={\vt REJECT)}
\end{quote}

where the {\it choices} argument is a list in the form

\begin{quote}
{\vt [}{\it element\/},{\it element\/}...{\vt ]}
\end{quote}

The square brackets are literal, {\it elements} are numbers or strings
(single or double-quoted) which are separated by commas.

Examples:\\
{\vt choice([1,2,4,8])}\\
{\vt choice(["red","green","blue"])}

The first line restricts the numeric parameter to the values listed. 
The second line would restrict a string parameter to the strings
listed.  Note that if the script is Python, single quotes must be used
instead of double quotes.  Single or double quotes can be used with
native scripts.

\item{\vt range}\\
\index{range constraint}
The {\vt ramge} constraint restricts a numerical parameter to a
range of values.  The keyword ``{\vt rangeConstraint}''
(case-insensitive) is a synonym.  The template is

\begin{quote}
{\vt range(}{\it low\/},{\it high\/},{\it resolution\/}={\vt None},{\it
 action\/}={\vt REJECT)}
\end{quote}

The {\it low} and {\it high} are numerical endpoints of the range. 
Either can be the enumeration value {\vt None}, which skips testing
against that endpoint.  For example,

\begin{quote}
{\vt range(0,None)}
\end{quote}

simply indicates that the value must be zero or larger.

The numerical values passed for {\it low} and {\it high} must be
consistent with the language used for the script.  In particular,
Python requires a standard integer or floating-point format.  The
native language allows SPICE-type numbers (e.g., {\vt 1.2K}), hex
numbers with a ``{\vt 0x}'' prefix (e.g., {\vt 0xff00}) and character
constants (e.g., {\vt '$\backslash$n'}) in addition.

The {\it resolution} argument is used in the {\cb Parameters} panel to
set the number of digits to include following a decimal point (see
\ref{pcparams}).

\item{\vt step}\\
\index{step constraint}
The {\vt step} constraint limits the numerical parameter value to
multiples of a given delta between a starting and ending value.  The
keyword ``{\vt stepConstraint}'' (case-insensitive) is a synonym.  The
template is

\begin{quote}
{\vt step(}{\it step\/},{\it start\/}={\vt 0},{\it limit\/}={\vt
 None},{\it resolution\/}={\vt None},{\it action\/}={\vt REJECT)}
\end{quote}

The parameter must be numeric.  If the {\it step} value is 0 or {\vt
None}, the constraint acts the same as the {\vt range} constraint,
with {\it start} and {\it limit} providing the low and high values,
respectively.

Otherwise, the allowed values are given by

\begin{quote}
{\it start} {\vt + N*}{\it step}
\end{quote}

where {\vt N} is a non-negative integer, and the value of the
expression is within the range terminated by {\it limit\/}, if {\it
limit} is not {\vt None}.  Note that {\it step} can be negative, in
which case the parameter value must be greater than or equal to {\it
limit\/}.

The {\it resolution} is treated as in the {\vt range} constraint.

\item{\vt numericStep}\\
\index{numericStep constraint}
This is very much like the {\vt step} constraint, but is intended for
use with string variables used for numeric input to support SPICE-like
multipliers.  This is needed for script languages that don't handle
numbers in this format.  Since the native script language understands
this number format directly, it is not clear that the {\vt
numericStep} constraint will ever be needed in pcells with native
scripts.  The keyword ``{\vt numericStepConstraint}'' is a synonym. 
The template is

\begin{quote}
{\vt step(}{\it step\/},{\it start\/}={\vt 0},{\it limit\/}={\vt
 None},{\it resolution\/}={\vt None},{\it scaleFactor\/}={\vt
 'u'},{\it action\/}={\vt REJECT)}
\end{quote}

The arguments are the same as for the {\vt step} constraint, with the
addition of {\it scaleFactor\/}.  The {\it scaleFactor} is a string
set to one of the scaling suffixes from the table below:

\begin{quote}
\begin{tabular}{|l|l|l|} \hline
\bf suffix & \bf multiplier & \bf name\\ \hline\hline
\vt a & \vt 1e-18 & \vt atto\\ \hline
\vt f & \vt 1e-15 & \vt femto\\ \hline
\vt p & \vt 1e-12 & \vt pico\\ \hline
\vt n & \vt 1e-9 & \vt nano\\ \hline
\vt u & \vt 1e-6 & \vt micro\\ \hline
\vt m & \vt 1e-3 & \vt milli\\ \hline
\vt mil & \vt 25.4 & \vt mil\\ \hline
\vt k & \vt 1e3 & \vt kilo\\ \hline
\vt meg & \vt 1e6 & \vt mega\\ \hline
\vt g & \vt 1e9 & \vt giga\\ \hline
\vt t & \vt 1e12 & \vt tera\\ \hline
\end{tabular}
\end{quote}

The scale fastor is case-insensitive.  If the {\it scaleFactor} is
assigned the value {\vt None}, no scale fastor is assumed, and the
constraint is basically identical to {\vt step}.  If a scale factor is
given, numbers given for {\it step\/}, {\it start\/}, and {\it limit}
are internally multiplied by the scale factor, before comparison to
the parameter value.
\end{description}

!! 020615
!!KEYWORD
xic:pcparams
!!TITLE
Parameters Panel:  Set PCell Parameters
!!HTML
    <img src="screenshots/params.png" align=right>
    The <b>Parameters</b> panel appears when it is necessary to
    provide parameters for a <a href="xic:pcells">parameterized
    cell</a> (pcell) instantiation.  These situations include

    <ul>
    <li>During placement of pcell instances with the <a
    href="xic:place"><b>Cell Placement Control</b></a> panel from the
    <b>place</b> button in the side menu.

    <li>While editing a <a href="prpty:pc_params"><b>pc_params</b></a>
    instance property with the <a href="xic:prpty"><b>Property
    Editor</b></a>, which is obtained with the <b>Properties</b>
    button in the <b>Edit Menu</b>.

    <li>If the user clicks with <a href="button1">button 1</a> and the
    <b>Ctrl</b> key held on a selected pcell instance, The
    <b>Parameters</b> panel will appear.  The user can reparameterize
    the instance.

    <li>While editing the <b>pc_params</b> property of the current
    cell with the <a href="xic:cprop"><b>Cell Property Editor</b></a>,
    which is obtained with the <b>Cell Properties</b> button in the
    <b>Edit Menu</b>.

    <li>If one opens a non-native pcell for editing, the
    <b>Parameters</b> panel will appear.  In this case, the label on
    the leftmost button is "<b>Open</b>" rather than "<b>Apply</b>". 
    Entering parameters then pressing <b>Open</b> will create or find
    the sub-master for the parameter set, and make it the current
    cell.  This will not happen with native pcells, which can be
    edited directly in <i>Xic</i>.
    </ul>

    <p>
    The <b>Parameters</b> panel provides an entry area for each pcell
    parameter.  In cases where there more parameters than will fit
    within the window, a scroll bar will appear, allowing the user to
    scroll the parameter listing.  The listing order of the parameters
    is as provided by the pcell.

    <p>
    The type of entry widget shown in the panel depends on the data type
    of the parameter, and the parameter <a href="constraint">constraint</a>
    specification.  The constraint string, if any, is obtained from the
    <a href="prpty:pc_params"><b>pc_params</b></a> property of the pcell
    super-master.  The following logic is used:

    <ul>
    <li>If the parameter is boolean, any constraint is ignored, and a
    check box is created.

    <li>If the parameter has a <tt>choice</tt> constraint, a drop-down
    menu containing the given choices is created.  The choices can be
    numeric or string values.

    <li>If the parameter has a <tt>range</tt> or <tt>step</tt>
    constraint, a numeric entry "spin" button is created.  The numbers
    displayed in the text area follow the constraint, i.e., the range is
    limited, and the step value (if any) is enforced.  The up/down
    arrows add or subtract a step value.  Further, the floating-point
    precision used for the number will follow the <i>resolution</i>
    value of the constraint.  This is described below.

    <li>If the parameter has a <tt>numericStep</tt> constraint, the
    set-up is very similar to the <tt>step</tt> constraint, but an
    additional label will appear showing the <i>scaleFactor</i>, if
    any.  This scale factor is logically appeaded to the number that
    appears in the entry area.

    <li>If there is no constraint, a simple text-entry area is created.
    </ul>

    <a name="resol"></a>
    For numeric entries, the constraint <i>resolution</i> value will
    set the number of digits that follow the decimal point in the
    display.  For the default value of <tt>None</tt>, or if less than
    1.0, the number of digits will be based on the current database
    resolution, as set at program startup with the <a
    href="DatabaseResolution"><b>DatabaseResolution</b></a> variable. 
    If the resolution is the default value of 1000, three digits will
    be used (<tt>1.235</tt>), otherwise four (<tt>1.2345</tt>).

    <p>
    Otherwise, the number of digits following the decimal will be set
    by the following logic:
    <blockquote><tt>
    if (resol > 1e5)  num = 6<br>
    else if (resol > 1e4)  num = 5<br>
    else if (resol > 1e3)  num = 4<br>
    else if (resol > 1e2)  num = 3<br>
    else if (resol > 1e1)  num = 2<br>
    else if (resol > 1e0)  num = 1<br>
    else num = 0</tt>
    </blockquote>

    Note that giving a <i>resolution</i> of 1.0 will set the number of
    digits to zero, indicating integer values only (no decimal point is
    shown in this case).

    <p>
    The panel logic differs somewhat depending on the context.  When
    editing an existing property, with the <b>Property Editor</b> or
    <b>Cell Property Editor</b>, the <b>Parameters</b> panel is
    "modal", meaning that the rest of <i>Xic</i> is inactive while the
    panel is visible.  The user is expected to enter the appropriate
    parameter data and either press <b>Apply</b> which will accept the
    new parameter set, or <b>Dismiss</b>, which will abort the current
    parameter edit.  In both cases, the <b>Parameters</b> panel will
    disappear, and <i>Xic</i> will return to normal status.
    The <b>Reset</b> button will revert all parameter settings
    in the panel to the initial settings when the panel was created,
    i.e., the values from the existing property string.

    <p>
    When placing instances, on the other hand, the <b>Parameters</b>
    panel is not modal.  The parameters can be changed at any time,
    and the changed parameter set will apply when new instances are
    created, whether or not <b>Apply</b> is pressed.  Pressing
    <b>Apply</b> will create or find the existing sub-master for the
    parameter set, from which the instance bounding box is obtained
    and used in the ghost-highlighting during instance creation.  The
    <b>Dismiss</b> button will remove the panel, but the instance
    placement will continue.  The <b>Reset</b> button will reset all
    parameter values displayed in the panel to the defaults provided
    in the pcell.

    <p>
    When opening a foreign pcell, the <b>Parameters</b> panel is
    non-model, and nothing happens unless/until <b>Open</b> is
    pressed.  Pressing <b>Open</b> will create a new sub-master if
    necessary for the parameters as set, and make the sub-master the
    current cell for editing.  Editing the sub-master is generally not
    a great idea, unless the user understands the issues.  Changing
    the <b>pc_params</b> property, though, is a valid way to modify
    all instances of the master.  Other changes to the sub-master will
    be lost, unless the sub-master is saved, possibly with the <a
    href="PCellKeepSubMasters"><b>PCellKeepSubMasters</b></a> variable
    set.  Pressing <b>Dismiss</b> simply retires the panel.  Pressing
    <b>Reset</b> returns all parameter values shown in the panel to
    the pcell default values.
!!LATEX xic:pcparams pcells.tex
The {\cb Parameters} panel appears when it is necessary to provide
parameters for a parameterized cell (pcell) instantiation.  These
situations include

\begin{itemize}
\item{During placement of pcell instances with the {\cb Cell Placement
Control} panel from the {\cb place} button in the side menu.}

\item{While editing a {\et pc\_params} instance property with the {\cb
Property Editor}, which is obtained with the {\cb Properties} button
in the {\cb Edit Menu}.}

\item{If the user clicks with button 1 and the {\kb Ctrl} key held on
a selected pcell instance, The {\cb Parameters} panel will appear. 
The user can reparameterize the instance.}

\item{While editing the {\et pc\_params} property of the current cell
with the {\cb Cell Property Editor}, which is obtained with the {\cb
Cell Properties} button in the {\cb Edit Menu}.}

\item{If one opens a non-native pcell for editing, the {\cb
Parameters} panel will appear.  In this case, the label on the
leftmost button is ``{\cb Open}'' rather than ``{\cb Apply}''. 
Entering parameters then pressing {\cb Open} will create or find the
sub-master for the parameter set, and make it the current cell.  This
will not happen with native pcells, which can be edited directly in
{\Xic}.}
\end{itemize}

The {\cb Parameters} panel provides an entry area for each pcell
parameter.  In cases where there more parameters than will fit within
the window, a scroll bar will appear, allowing the user to scroll the
parameter listing.  The listing order of the parameters is as provided
by the pcell.

The type of entry widget shown in the panel depends on the data type
of the parameter, and the parameter constraint specification.  The
constraint string, if any, is obtained from the {\et pc\_params}
property of the pcell super-master.  The following logic is used:

\begin{itemize}
\item{If the parameter is boolean, any constraint is ignored, and a
check box is created.}

\item{If the parameter has a {\vt choice} constraint, a drop-down
menu containing the given choices is created.  The choices can be
numeric or string values.}

\item{If the parameter has a {\vt range} or {\vt step}
constraint, a numeric entry ``spin'' button is created.  The numbers
displayed in the text area follow the constraint, i.e., the range is
limited, and the step value (if any) is enforced.  The up/down arrows
add or subtract a step value.  Further, the floating-point precision
used for the number will follow the {\it resolution} value of the
constraint.  This is described below.}

\item{If the parameter has a {\vt numericStep} constraint, the
set-up is very similar to the {\vt step} constraint, but an additional
label will appear showing the {\it scaleFactor\/}, if any.  This scale
factor is logically appeaded to the number that appears in the entry
area.}

\item{If there is no constraint, a simple text-entry area is created.}
\end{itemize}

For numeric entries, the constraint {\it resolution} value will set
the number of digits that follow the decimal point in the display. 
For the default value of {\vt None}, or if less than 1.0, the number
of digits will be based on the current database resolution, as set at
program startup with the {\et DatabaseResolution} variable.  If the
resolution is the default value of 1000, three digits will be used
({\vt 1.235}), otherwise four ({\vt 1.2345}).

Otherwise, the number of digits following the decimal will be set
by the following logic:
\begin{quote} \vt
    if (resol > 1e5)  num = 6\\
    else if (resol > 1e4)  num = 5\\
    else if (resol > 1e3)  num = 4\\
    else if (resol > 1e2)  num = 3\\
    else if (resol > 1e1)  num = 2\\
    else if (resol > 1e0)  num = 1\\
    else num = 0
\end{quote}

Note that giving a {\it resolution} of 1.0 will set the number of
digits to zero, indicating integer values only (no decimal point is
shown in this case).

The panel logic differs somewhat depending on the context.  When
editing an existing property, with the {\cb Property Editor} or {\cb
Cell Property Editor}, the {\cb Parameters} panel is ``modal'',
meaning that the rest of {\Xic} is inactive while the panel is
visible.  The user is expected to enter the appropriate parameter data
and either press {\cb Apply} which will accept the new parameter set,
or {\cb Dismiss}, which will abort the current parameter edit.  In
both cases, the {\cb Parameters} panel will disappear, and {\Xic} will
return to normal status.  The {\cb Reset} button will revert all
parameter settings in the panel to the initial settings when the panel
was created, i.e., the values from the existing property string.

When placing instances, on the other hand, the {\cb Parameters} panel
is not modal.  The parameters can be changed at any time, and the
changed parameter set will apply when new instances are created,
whether or not {\cb Apply} is pressed.  Pressing {\cb Apply} will
create or find the existing sub-master for the parameter set, from
which the instance bounding box is obtained and used in the
ghost-highlighting during instance creation.  The {\cb Dismiss} button
will remove the panel, but the instance placement will continue.  The
{\cb Reset} button will reset all parameter values displayed in the
panel to the defaults provided in the pcell.

When opening a foreign pcell, the {\cb Parameters} panel is non-model,
and nothing happens unless/until {\cb Open} is pressed.  Pressing {\cb
Open} will create a new sub-master if necessary for the parameters as
set, and make the sub-master the current cell for editing.  Editing
the sub-master is generally not a great idea, unless the user
understands the issues.  Changing the {\et pc\_params} property,
though, is a valid way to modify all instances of the master.  Other
changes to the sub-master will be lost, unless the sub-master is
saved, possibly with the {\et PCellKeepSubMasters} variable set. 
Pressing {\cb Dismiss} simply retires the panel.  Pressing {\cb Reset}
returns all parameter values shown in the panel to the pcell default
values.

!!REDIRECT prpty:grip           pc_stretch#grip

!! 111919
!!KEYWORD
pc_stretch
!!TITLE
PCell Stretch Handles
!!HTML
    <i>Xic</i> supports the protocol for stretch handles defined by
    Ciranova.  This provides support for stretch handles defined
    in PyCells, but also allows use of stretch handles in native
    pcells.

    <p>
    A stretch handle is a graphical item that can be moved with the
    mouse pointer, where the motion causes a change in a parameter
    value.  Usually, the object is associated with a parameterized
    cell instantiation, and motion causes remastering of the instance
    to a new sub-master created with the new parameter.  For example,
    stretch handles might be used to graphically change the gate length
    and width of a MOSFET pcell instance, if the corresponding pcell
    supports the protocol.

    <p>
    Stretch handles are visible and activated only when the containing
    instance is shown large enough on-screen, to avoid
    false-triggering.  The size threshold can be set from the <a
    href="xic:pcctl"><b>PCell Control</b></a> panel from the <b>Edit
    Menu</b>, or equivalently with the <a
    href="PCellGripInstSize"><b>PCellGripInstSize</b></a> variable.

    <p>
    In <i>Xic</i>, when editing a sub-master containing stretch
    handles, the handles are visible as well, and can be moved.  This
    will change the parameterization of the sub-master, and all of its
    instances.  This is equivalent to modifying the <a
    href="pc_params"><b>pc_params</b></a> property with the <a
    href="xic:cprop"><b>Cell Property Editor</b></a> from the <b>Edit
    Menu</b>.

    <p>
    If the <b>Hide and disable stretch handles</b> check box in the <a
    href="xic:pcctl"><b>PCell Control</b></a> panel from the <b>Edit
    Menu</b> is checked, or equivalently if the <a
    href="PCellHideGrips"><b>PCellHideGrips</b></a> variable is set,
    all stretch handles will be invisible and disabled.

    <p>
    Adding stretch handles to a pcell amounts to adding box objects
    with the <b>grip</b> property applied.  The <b>grip</b> property
    provides the setup information.

    <p>
    There are example capacitor pcells that use stretch handles that
    can be found in the examples directory of the <i>Xic</i> program
    distribution area.  These demonstrate use of stretch handles and
    illustrate the property syntax.

    <a name="grip"></a>
    <dl>
    <dt><b>grip</b> property, number 7195<dd>
    This property is very similar to the Ciranova <tt>pycStretch</tt>
    property, used to implement stretch handles.  The property has
    meaning when applied to physical-mode boxes only.  The property
    string has the following format:

    <blockquote>
    <tt>name:</tt><i>val</i><tt>; stretchType:</tt><i>val</i><tt>,
    direction:</tt><i>val</i><tt>, parameter:</tt><i>val</i><tt>,
    minVal:</tt><i>val</i><tt>, maxVal:</tt><i>val</i><tt>,
    location:</tt><i>val</i><tt>, userScale:</tt><i>val</i><tt>,
    userSnap:</tt><i>val</i><tt>, key:</tt><i>val</i>
    </blockquote>

    <p>
    The terms have precisely the same names and interpretation as the
    <tt>pycStretch</tt> property described in the <i>Ciranova PyCell
    EDA Tool Integration Guidelines</i> document provided with the
    Ciranova PyCell Studio package (now available from Synopsys). 
    However, there are some differences.

    <ol>
    <li>Ciranova does not allow white space within the string.  In
    <i>Xic</i>, white space can appear between the terms as shown
    above.

    <li>The semicolon following the name and the commas are optional,
    the terms can be white-space separated.

    <li>In both cases a property string can contain multiple grip
    specifications.  Ciranova separates the specifications by white
    space.  In <i>Xic</i>, a new specification is started whenever a
    keyword is repeated.

    <li>Ciranova requires that all keywords be provided in each
    specification, except for the name, which can be omitted for names
    with varying <tt>key</tt> strings.  In <i>Xic</i>, when parsing
    multiple specifications, previous values of the various parameters
    are retained, so only changed values need be given.

    <li><i>Xic</i> keyword matching is case-insensitive.
    </ol>

    The terms have the following significance.
    <dl>
    <dt><tt>name</tt><dd>
    A name for the stretch handle, which should be a unique string
    token within the pcell.

    <dt><tt>stretchType</tt><dd>
    Set to one of the keywords "<tt>relative</tt>" or
    "<tt>absolute</tt>".  Per Ciranova, if <tt>relative</tt>, the
    increment is measured relative to the center of the rectangle,
    while <tt>absolute</tt> is the increment measured according to the
    absolute X and Y directions.  This parameter is ignored in
    <i>Xic</i>, since the explanation does not seem to make sense.

    <dt><tt>direction</tt><dd>
    Set to one of the keywords "<tt>NORTH_SOUTH</tt>" or
    "<tt>EAST_WEST</tt>", specifying the translation direction of the
    stretch handle.

    <dt><tt>parameter</tt><dd>
    The name of the pcell parameter that is modified by the stretch
    handle.

    <dt><tt>minVal</tt><dd>
    A numerical value giving the minimum value of the parameter being
    modified.  SPICE-style scaling suffix values and units, e.g.,
    <tt>1K</tt>, <tt>100nM</tt>, are acceptable, units are ignored.

    <dt><tt>maxVal</tt><dd>
    A numerical value giving the maximum value of the parameter being
    modified.

    <dt><tt>location</tt><dd>
    This specifies the location point for the graphical stretch handle
    on the layout rectangle.  The value must be one of
    "<tt>Location.CENTER_LEFT</tt>", "<tt>Location.LOWER_CENTER</tt>",
    "<tt>Location.CENTER_RIGHT</tt>",
    "<tt>Location.UPPER_CENTER</tt>", which specify the left, bottom,
    right, and top sides.  All Ciranova codes are handled, those
    listed above display a line stretch handle, others will show a
    glyph.

    <dt><tt>userScale</tt><dd>
    This is a real number scale factor used to multiply the change in
    parameter value.

    <dt><tt>userSnap</tt><dd>
    The real number resolution value which should be used for snapping
    the parameter value, i.e., the reported parameter value will be an
    integer multiple of the <tt>userSnap</tt>.

    <dt><tt>key</tt><dd>
    The name used as a key to specify values for multi-valued
    parameters, and should be "<tt>None</tt>" for ordinary parameters. 
    Multi-valued parameters are not supported in <i>Xic</i>.
    </dl>
    </dl>

    <p>
    In <i>Xic</i>, stretch handles are available only in physical mode.
    They are visible in selected, expanded instances only.  A stretch
    handle is represented as a double-line highlighting of one of the
    four edges of the rectangle to which the <b>grip</b> property is
    applied.

    <p>
    The user can drag the highlighted edge in a direction normal to
    the edge over a range set in the property.  The edge is
    ghost-drawn and attached to the mouse pointer during the move. 
    Unlike some other move operations in <i>Xic</i>, only dragging is
    allowed, clicking on a grip will do nothing special.  If the
    associated parameter has a <a href="constraint">constraint</a>
    string defined, the highlighting will be visible only for allowed
    values of the parameter.
!!LATEX pc_stretch pcells.tex
{\Xic} supports the protocol for stretch handles defined by Ciranova. 
This provides support for stretch handles defined in PyCells, but also
allows use of stretch handles in native pcells.

A stretch handle is a graphical item that can be moved with the mouse
pointer, where the motion causes a change in a parameter value. 
Usually, the object is associated with a parameterized cell
instantiation, and motion causes remastering of the instance to a new
sub-master created with the new parameter.  For example, stretch
handles might be used to graphically change the gate length and width
of a MOSFET pcell instance, if the corresponding pcell supports the
protocol.

Stretch handles are visible and activated only when the containing
instance is shown large enough on-screen, to avoid false-triggering. 
The size threshold can be set from the {\cb PCell Control} panel from
the {\cb Edit Menu}, or equivalently with the {\et PCellGripInstSize}
variable.

In {\Xic}, when editing a sub-master containing stretch handles, the
handles are visible as well, and can be moved.  This will change the
parameterization of the sub-master, and all of its instances.  This is
equivalent to modifying the {\et pc\_params} property with the {\cb
Cell Property Editor} from the {\cb Edit Menu}.

If the {\cb Hide and disable stretch handles} check box in the {\cb
PCell Control} panel from the {\cb Edit Menu} is checked, or
equivalently if the {\et PCellHideGrips} variable is set, all stretch
handles will be invisible and disabled.

Adding stretch handles to a pcell amounts to adding box objects with
the {\et grip} property applied.  The {\et grip} property provides the
setup information.

There are example capacitor pcells that use stretch handles that can
be found in the examples directory of the {\Xic} program distribution
area.  These demonstrate use of stretch handles and illustrate the
property syntax.

\begin{description}
\index{grip property}
\index{properties!grip}
\item{\et grip} property, number 7195\\
This property is very similar to the Ciranova {\et pycStretch}
property, used to implement stretch handles.  The property has meaning
when applied to physical-mode boxes only.  The property string has the
following format:

\begin{quote}
{\vt name:}{\it val}{\vt ; stretchType:}{\it val\/}{\vt ,
direction:}{\it val\/}{\vt , parameter:}{\it val\/}{\vt ,
minVal:}{\it val\/}{\vt , maxVal:}{\it val\/}{\vt ,
location:}{\it val\/}{\vt , userScale:}{\it val}{\vt ,
userSnap:}{\it val\/}{\vt , key:}{\it val}
\end{quote}

The terms have precisely the same names and interpretation as the {\et
pycStretch} property described in the {\it Ciranova PyCell EDA Tool
Integration Guidelines} document provided with the Ciranova PyCell
Studio package (now available from Synopsys).  However, there are some
differences.

\begin{enumerate}
\item{Ciranova does not allow white space within the string.  In
{\Xic}, white space can appear between the terms as shown above.}

\item{The semicolon following the name and the commas are optional,
the terms can be white-space separated.}

\item{In both cases a property string can contain multiple grip
specifications.  Ciranova separates the specifications by white space. 
In {\Xic}, a new specification is started whenever a keyword is
repeated.}

\item{Ciranova requires that all keywords be provided in each
specification, except for the name, which can be omitted for names
with varying {\vt key} strings.  In {\Xic}, when parsing multiple
specifications, previous values of the various parameters are
retained, so only changed values need be given.}

\item{{\Xic} keyword matching is case-insensitive.}
\end{enumerate}

The terms have the following significance.
\begin{description}
\item{\vt name}\\
A name for the stretch handle, which should be a unique string token
within the pcell.

\item{\vt stretchType}\\
Set to one of the keywords `{\vt relative}'' or ``{\vt absolute}''. 
Per Ciranova, if {\vt relative}, the increment is measured relative to
the center of the rectangle, while {\vt absolute} is the increment
measured according to the absolute X and Y directions.  This parameter
is ignored in {\it Xic}, since the explanation does not seem to make
sense.

\item{\vt direction}\\
Set to one of the keywords ``{\vt NORTH\_SOUTH}'' or ``{\vt
EAST\_WEST}'', specifying the translation direction of the stretch
handle.

\item{\vt parameter}\\
The name of the pcell parameter that is modified by the stretch
handle.

\item{\vt minVal}\\
A numerical value giving the minimum value of the parameter being
modified.  SPICE-style scaling suffix values and units, e.g., {\vt
1K}, {\vt 100nM}, are acceptable, units are ignored.

\item{\vt maxVal}\\
A numerical value giving the maximum value of the parameter being
modified.

\item{\vt location}\\
This specifies the location point for the graphical stretch handle
on the layout rectangle.  The value must be one of
\begin{quote}
``{\vt Location.CENTER\_LEFT}'',\\
``{\vt Location.LOWER\_CENTER}'',\\
``{\vt Location.CENTER\_RIGHT}'',\\
``{\vt Location.UPPER\_CENTER}'',\\
\end{quote}
which specify the left, bottom, right, and top sides.  All Ciranova
codes are handled, those listed above display a line stretch handle,
others will show a glyph.

\item{\vt userScale}\\
This is a real number scale factor used to multiply the change in
parameter value.

\item{\vt userSnap}\\
The real number resolution value which should be used for snapping the
parameter value, i.e., the reported parameter value will be an integer
multiple of the {\vt userSnap}.

\item{\vt key}\\
The name used as a key to specify values for multi-valued parameters,
and should be ``{\vt None}'' for ordinary parameters.  Multi-valued
parameters are not supported in {\Xic}.
\end{description}
\end{description}

In {\Xic}, stretch handles are available only in physical mode.  They
are visible in selected, expanded instances only.  A stretch handle is
represented as a double-line highlighting of one of the four edges of
the rectangle to which the {\et rip} property is applied.

The user can drag the highlighted edge in a direction normal to the
edge over a range set in the property.  The edge is ghost-drawn and
attached to the mouse pointer during the move.  Unlike some other move
operations in {\Xic}, only dragging is allowed, clicking on a grip
will do nothing special.  If the associated parameter has a constraint
string defined, the highlighting will be visible only for allowed
values of the parameter.

!!SEEALSO
pc_abut
xic:pcells

!!REDIRECT prpty:ab_class       pc_abut#ab_class
!!REDIRECT prpty:ab_rules       pc_abut#ab_rules
!!REDIRECT prpty:ab_directs     pc_abut#ab_directs
!!REDIRECT prpty:ab_shapename   pc_abut#ab_shapename
!!REDIRECT prpty:ab_pinsize     pc_abut#ab_pinsize
!!REDIRECT prpty:ab_inst        pc_abut#ab_inst
!!REDIRECT prpty:ab_prior       pc_abut#ab_prior
!!REDIRECT prpty:ab_copy        pc_abut#ab_copy

!! 102614
!!KEYWORD
pc_abut
!!TITLE
PCell Abutment
!!HTML
    Auto-abutment is most commonly used in MOS transistor pcells.  If
    one overlays two compatible transistor instances, the two instances
    reconfigure themselves into a dual-gate configuration, eliminating
    redundant geometry.

    <p>
    At this time, the only available example pcell that implements
    auto-abutment is the Nmos2 pcell in the IPL_cni130 library
    supplied with the Synopsys (Ciranova) <a href="pycell">PyCell
    Studio</a> download.  This is an OpenAccess Python portable pcell
    which is part if the IPL (<a
    href="https://www.iplnow.com">IPLnow.com</a>) library of
    open-source portable pcells.

!!IFDEF OpenAccess
    <p>
    The following procedure illustrates auto-abutment.
    <ol>
    <li>Download and install the Synopsys PyCell Studio package.  This
    is free from Synopsys, but requires registration and a password
    mailback.  Versions are available for Linux and Windows, though the
    Windows version is not currently supported in <i>Xic</i>.

    <p>
    <li>Start <i>Xic</i> in an <a
    href="pycell#connect">environment</a> that will load the
    OpenAccess libraries and Python from the PyStudio.  Use "<tt>-Tcni</tt>"
    to reference the appropriate technology file.  Edit an empty cell.

    <p>
    <li>Select the <a href="xic:oalib"><b>OpenAccess Libs</b></a> button
    in the <b>File Menu</b>, which will bring up the libraries list.

    <p>
    <li>Select the <tt>IPL_cni130</tt> library by clicking on the name.
    Then press the <b>Contents</b> button.  A new listing window will
    appear.

    <p>
    <li>Scroll down in the new window and click on the <tt>Nmos2</tt>
    entry.

    <p>
    <li>Then click the <b>Place</b> button in the bottom-right corner
    of the same window.  The <a href="xic:place"><b>Cell Placement
    Control</b></a> panel will appear.  Press the <b>Place</b> button
    in this panel.

    <p>
    <li>The <a href="xic:pcparams">Parameters</a> panel will appear,
    and the cell placement icon will be attached to the mouse pointer. 
    Click twice in a drawing window to place two instances of the
    cell, far enough apart that they don't overlap.  Press <b>Esc</b>
    to exit placement mode.

    <p>
    <li>Use the <a href="xic:expnd"><b>Expand</b></a> feature from the
    <b>View Menu</b> to set the display depth so that the instance
    content will be shown.

    <p>
    <li>Now for the fun part.  Pop down any pop-up windows or
    otherwise move them out of the way.  Select one of the cell
    instances, and move it over the other, so that the right contact
    area of one touches the left contact area of the other.  Both
    instances will reconfigure themselves, and the overlapped contact
    will be gone!  The structure represents a dual-gate transistor.

    <p>
    <li>Move one of the instances well away from the other.  Note that
    they revert to their original form.

    <p>
    <li>
    Click the <a href="xic:pcctl"><b>PCell Control</b></a> button in
    the <b>Edit Menu</b>.  In the panel that appears, select <b>Mode 2
    (with contact)</b> for <b>Auto-abutment mode</b>.

    <p>
    <li>As before, move one of the instances so that the contacts
    overlap.  In this case, note that one of the instances retains the
    contact.  This mode inplements trasistors with a shared contact.
    </ol>
!!ELSE
    <p>
    Unfortunately, this requires OpenAccess to obtain, so is not
    currently available.  Support for auto-abutment, as decribed in
    Ciranova documentation, is implemented within <i>Xic</i>.  An
    example native abutting pcell will be provided at some point.
!!ENDIF

    <p>
    The abutment protocol adheres as closely as possible to the
    description from the <tt>eda_tool_integration.pdf</tt> document
    supplied with the PyCell Studio.  There is one very significant
    difference, in that Synopsys incorporates the logic into a
    separate non-visual pcell, which is created transiently to handle
    abutment events.  In <i>Xic</i>, the logic is built into the
    program.  Thus, auto-abutment can be used in native language and
    Tcl pcells in <i>Xic</i>, as well as Python pcells.  In
    <i>Xic</i>, the internal logic handles abutment events, the
    separate pcell is not used.

    <p>
    Auto-abutment is enabled in a cell through application of a number
    of object properties that define aspects of the abutment.  These are
    applied to objects created in the sub-master (or inherited from the
    super-master).  The <i>Xic</i> properties as described below correspond
    to the properties described for abutment in PyCells, with generally
    identical syntax.

    <a name="ab_class"></a>
    <dl>
    <dt><b>ab_class</b><dd>
    This is equivalent to the Ciranova <tt>pycAbutClass</tt> property. 
    It is applied to pin shapes to specify that two pin shapes from
    different cells can be abutted.  Only pins with the same
    <b>ab_class</b> property string can trigger auto-abutment.
    </dl>
    
    <a name="ab_rules"></a>
    <dl>
    <dt><b>ab_rules</b><dd>
    This is equivalent to the Ciranova <tt>pycAbutRules</tt> property. 
    The property is applied to each pin shape that can be abutted, and
    the string specifies how the pcell parameters are modified for
    different abutment modes.
    </dl>

    <a name="ab_directs"></a>
    <dl>
    <dt><b>ab_directs</b><dd>
    This is equivalent to the Ciranova <tt>pycAbutDirects</tt> property. 
    The property is applied to each pin shape that can be abutted, and
    the string contains a comma-separated list of one or more of the
    string tokens <tt>left</tt>, <tt>bottom</tt>, <tt>right</tt>, and
    <tt>top</tt>.  These specify the valid abutment directions.
    </dl>

    <a name="ab_shapename"></a>
    <dl>
    <dt><b>ab_shapename</b><dd>
    This is equivalent to the Ciranova <tt>pycAbutShapeName</tt>
    property.  This property is assigned by the pcell developer to
    each pin shape which can be abutted.  It assigns a unique name to
    the shape.
    </dl>

    <a name="ab_pinsize"></a>
    <dl>
    <dt><b>ab_pinsize</b><dd>
    This is equivalent to the Ciranova <tt>pycAbutPinSize</tt>
    The property is applied to each pin shape which can be abutted,
    and supplies an orientation-independent width parameter.
    </dl>

    <a name="ab_inst"></a>
    <dl>
    <dt><b>ab_inst</b><dd>
    This property is applied to instances of abutable cells, and contains
    an instance name.  <i>Xic</i> normally does not generate or use
    instance names.
    </dl>

    <a name="ab_prior"></a>
    <dl>
    <dt><b>ab_prior</b><dd>
    This property of a pcell instance indicates that the instance is
    abutted, and this property contains pre-abutment parameter values
    for use in reverting abutment.
    </dl>

    <a name="ab_copy"></a>
    <dl>
    <dt><b>ab_copy</b><dd>
    This property is applied to instances with <b>ab_prior</b>
    properties that have just been copied.  This will allow parameter
    reversion of the copy without touching the partner of the
    original.
    </dl>
!!LATEX pc_abut pcells.tex
Auto-abutment is most commonly used in MOS transistor pcells.  If one
overlays two compatible transistor instances, the two instances
reconfigure themselves into a dual-gate configuration, eliminating
redundant geometry.

At this time, the only available example pcell that implements
auto-abutment is the Nmos2 pcell in the IPL\_cni130 library supplied
with the Synopsys (Ciranova) PyCell Studio download.  This is an
OpenAccess Python portable pcell which is part if the IPL (IPLnow.com)
library of open-source portable pcells.

%\ifoa
The following procedure illustrates auto-abutment.

\begin{enumerate}
\item{Download and install the Synopsys PyCell Studio package.  This
is free from Synopsys, but requires registration and a password
mailback.  Versions are available for Linux and Windows, though the
Windows version is not currently supported in {\Xic}.}

\item{Start {\Xic} in an environment that will load the OpenAccess
libraries and Python from the PyStudio.  Use ``{\vt -Tcni}'' to
reference the appropriate technology file.  Edit an empty cell.}

\item{Select the {\cb OpenAccess Libs} button in the {\cb File Menu},
which will bring up the libraries list.}

\item{Select the {\vt IPL\_cni130} library by clicking on the name. 
Then press the {\cb Contents} button.  A new listing window will
appear.}

\item{Scroll down in the new window and click on the {\vt Nmos2}
entry.}

\item{Then click the {\cb Place} button in the bottom-right corner of
the same window.  The {\cb Cell Placement Control} panel will appear. 
Press the {\cb Place} button in this panel.}

\item{The {\cb Parameters} panel will appear, and the cell placement
icon will be attached to the mouse pointer.  Click twice in a drawing
window to place two instances of the cell, far enough apart that they
don't overlap.  Press {\cb Esc} to exit placement mode.}

\item{Use the {\cb Expand} feature from the {\cb View Menu} to set the
display depth so that the instance content will be shown.}

\item{Now for the fun part.  Pop down any pop-up windows or otherwise
move them out of the way.  Select one of the cell instances, and move
it over the other, so that the right contact area of one touches the
left contact area of the other.  Both instances will reconfigure
themselves, and the overlapped contact will be gone!  The structure
represents a dual-gate transistor.}

\item{Move one of the instances well away from the other.  Note that
they revert to their original form.}

\item{Click the {\cb PCell Control} button in the {\cb Edit Menu}.  In
the panel that appears, select {\cb Mode 2 (with contact)} for {\cb
Auto-abutment mode}.}

\item{As before, move one of the instances so that the contacts
overlap.  In this case, note that one of the instances retains the
contact.  This mode inplements trasistors with a shared contact.}
\end{enumerate}

%\else
%
%Unfortunately, this requires OpenAccess to obtain, so is not currently
%available.  Support for auto-abutment, as decribed in Ciranova
%documentation, is implemented within {\Xic}.  An example native
%abutting pcell will be provided at some point.
%\fi

The abutment protocol adheres as closely as possible to the
description from the {\vt eda\_tool\_integration.pdf} document
supplied with the PyCell Studio.  There is one very significant
difference, in that Synopsys incorporates the logic into a separate
non-visual pcell, which is created transiently to handle abutment
events.  In {\Xic}, the logic is built into the program.  Thus,
auto-abutment can be used in native language and Tcl pcells in {\Xic},
as well as Python pcells.  In {\Xic}, the internal logic handles
abutment events, the separate pcell is not used.

Auto-abutment is enabled in a cell through application of a number of
object properties that define aspects of the abutment.  These are
applied to objects created in the sub-master (or inherited from the
super-master).  The {\Xic} properties as described below correspond to
the properties described for abutment in PyCells, with generally
identical syntax.

\begin{description}
\index{properties!ab\_class}
\index{ab\_class property}
\item{\et ab\_class}\\
This is equivalent to the Ciranova {\et pycAbutClass} property.  It is
applied to pin shapes to specify that two pin shapes from different
cells can be abutted.  Only pins with the same {\et ab\_class}
property string can trigger auto-abutment.

\index{properties!ab\_rules}
\index{ab\_rules property}
\item{\et ab\_rules}\\
This is equivalent to the Ciranova {\et pycAbutRules} property.  The
property is applied to each pin shape that can be abutted, and the
string specifies how the pcell parameters are modified for different
abutment modes.

\index{properties!ab\_directs}
\index{ab\_directs property}
\item{\et ab\_directs}\\
This is equivalent to the Ciranova {\et pycAbutDirects} property.  The
property is applied to each pin shape that can be abutted, and the
string contains a comma-separated list of one or more of the string
tokens {\vt left}, {\vt bottom}, {\vt right}, and {\vt top}.  These
specify the valid abutment directions.

\index{properties!ab\_shapename}
\index{ab\_shapename property}
\item{\et ab\_shapename}\\
This is equivalent to the Ciranova {\et pycAbutShapeName} property. 
This property is assigned by the pcell developer to each pin shape
which can be abutted.  It assigns a unique name to the shape.

\index{properties!ab\_pinsize}
\index{ab\_pinsize property}
\item{\et ab\_pinsize}\\
This is equivalent to the Ciranova {\et pycAbutPinSize} The property
is applied to each pin shape which can be abutted, and supplies an
orientation-independent width parameter.

\index{properties!ab\_inst}
\index{ab\_inst property}
\item{\et ab\_inst}\\
This property is applied to instances of abutable cells, and contains
an instance name.  {\Xic} normally does not generate or use instance
names.

\index{properties!ab\_prior}
\index{ab\_prior property}
\item{\et ab\_prior}\\
This property of a pcell instance indicates that the instance is
abutted, and this property contains pre-abutment parameter values for
use in reverting abutment.

\index{properties!ab\_copy}
\index{ab\_copy property}
\item{\et ab\_copy}\\
This property is applied to instances with {\et ab\_prior} properties
that have just been copied.  This will allow parameter reversion of
the copy without touching the partner of the original.
\end{description}

!!SEEALSO
pc_stretch
xic:pcells

!!IFDEF OpenAccess
!! 022513
!!KEYWORD
pycell pycells
!!TITLE
Synopsys (Ciranova) PyCell Studio
!!HTML
    <b>jump to</b> <a href="pycell#connect"><b>Connecting to PyCell
    Studio</b></a>

    <p>
    Most parameterized cells (pcells) have been written in the Cadence
    Virtuoso environment, using the proprietary Skill scripting
    language found only in that environment.  These pcells can only be
    used in a Virtuoso environment.

    <p>
    Ciranova, Inc., now owned by Synopsys, developed and championed
    the idea of portable pcells, pcells that would have published
    interfaces and use a common programming language, that could work
    in any design environment.  The company provides a free <a
    href="http://www.synopsys.com/Tools/Implementation/CustomImplementation/Pages/pycell-studio.aspx">
    downloadable</a> "PyCell Studio" design kit.  The concept is made
    possible by the use of OpenAccess, which has a well-defined
    framework for pcell support, is well documented, and source code is
    published.  Cadence Virtuoso and most modern tools use OpenAccess.

    <p>
    Though OpenAccess provides support for pcell interfacing and
    management, actual execution of the pcell script is exported to
    external code supplied as a plug-in.  The plug-in provides an
    interface to the language interpreter or compiler and other things
    required to execute the script.  This plug-in is supplied by the
    system vendor or user.  For example, in a Virtuoso installation, a
    Skill plug-in is provided.  OpenAccess comes with example plug-ins
    for Tcl and C++.

    <p>
    Ciranova developed a Python plug-in for OpenAccess, with a set of
    interface functions for creating geometry and related purposes
    within OpenAccess.  Python is a very popular, modern, open source
    scripting language.  It is present on any standard Linux system,
    and is available for most other operating systems.  Ciranova calls
    portable Python-based pcells that use the Ciranova plug-in
    "PyCells".

    <p>
    The PyCell Studio design kit contains tools for viewing, testing, and
    creating PyCells.  An example library of PyCells is provided,
    complete with technology and display resource files.  It also
    provides OpenAccess and Python, so the package is quite complete. 
    There is comprehensive documentation and tutorials.

    <p>
    Though Ciranova has been bought by Synopsys, the PyCell Studio remains
    available and apparently is still under development.  An industry
    group, <a href="https://www.iplnow.com">IPLnow.com</a> which
    includes TSMC and other foundries and some tool vendors, is
    pushing the cause of "interoperable" PDK libraries based on
    portable pcells.

    <p>
    Whiteley Research fully supports this effort, and <i>Xic</i>
    will be interoperable with the PyCell Studio design kit and PyCells
    as much as possible.

    <a name="connect"></a>
    <h2>Connecting to PyCell Studio</h2>

    This section describes how <i>Xic</i> can directly interface to
    the PyCell Studio example library and technology.  PyCells
    from the library, or authored by the user, can be instantiated
    in <i>Xic</i> cells.

    <p>
    It will be assumed in this discussion that the PyCell Studio has
    been <a
    href="http://www.synopsys.com/Tools/Implementation/CustomImplementation/Pages/pycell-studio.aspx">
    downloaded</a> from Synopsys, and installed on your system, which
    also has <i>Xic</i> installed.  The PyCell Studio works with Red
    Hat Enterprise Linux releases 5 and 6 (and equivalent).  You must
    choose the same word size (32 or 64 bits) as your <i>Xic</i>
    installation.  The installation location for PyCell Studio is
    selected by the user, and we will refer to this location as
    "<tt>$CNI_ROOT</tt>".  For example, <tt>$CNI_ROOT</tt> might be
    <tt>/usr/local/ciranova</tt>.

    <p>
    Although your system will almost certainly have Python installed,
    it appears necessary to use the Python provided with the Studio. 
    In Red Hat EL6, the Ciranova and stock Python version numbers are
    the same, but the libraries are apparently built with different
    options, and attempts at using the stock Python have failed
    (perhaps Synopsys will fix this?).  You can, however, use your own
    OpenAccess installation if you have one and it is reasonably
    recent.  You can probably also use OpenAccess from Cadence.

    <p>
    The first step is to make sure that the PyCell Studio installation
    is correct by following the steps in the
    <tt>$CNI_ROOT/quickstart/README.txt</tt> file.

    <p>
    Part of this procedure (step 3) is to source one of the startup
    files provided.  This step sets the value of several environment
    variables, and forces the system to find the Ciranova Python
    instead of a local Python.  It also installs the OpenAccess
    plug-in for Python.  The user can customize this script if
    desired.  It is necessary to source this file, or otherwise setup
    the environment as per the file, before starting <i>Xic</i>. 
    After finishing, you will want to revert the environment to the
    previous state.  Unfortunately, this is difficult.  You may kill
    the window and start a new one.

    <p>
    A better way to run <i>Xic</i> in the Ciranova environment would be
    to write a script such as the following.  Call it "<tt>xic.cni</tt>".

    <pre>
    #! /bin/sh

    CNI_ROOT=/usr/local/ciranova
    source $CNI_ROOT/quickstart/bashrc; xic -Tcni $*
    </pre>

    The <tt>CNI_ROOT</tt> line should be changed to the actual
    Ciranova installation location.  After creating the file, make it
    executable with
    <blockquote>
    <tt>chmod 755 xic.cni</tt>
    </blockquote>

    Then, to run <i>Xic</i> in the Ciranova environment, just run this
    script instead.  Since it runs in a sub-shell, the environment
    of the main shell is not corrupted.  Any command line arguments
    are passed through.
    
    <p>
    Note that above <i>Xic</i> is started with a "<tt>-Tcni</tt>"
    option, which specifies to use the <tt>xic_tech.cni</tt> example
    technology file provided with <i>Xic</i>.  This uses the <a
    href="ReadDRF"><tt>ReadDRF</tt></a> and <a
    href="ReadCniTech"><tt>ReadCniTech</tt></a> directives to read
    display resource and technology files from the Ciranova
    installation.  However, Ciranova provides a number of technology
    files, any you may want to try them.  You will probably want to
    copy the <tt>xic_tech.cni</tt> file to your local directory, so
    that it can be edited easily.

    <p>
    Finally, you will need to set up your OpenAccess <tt>lib.defs</tt>
    to include the Ciranova libraries.  The <tt>lib.defs</tt> file is
    a listing of the OpenAccess libraries available, very similar to the
    <tt>cds.lib</tt> file in Cadence.  If no <tt>lib.defs</tt> file exists
    in the current directory, using a text editor create the file with
    a single line
    <blockquote>
    <tt>INCLUDE</tt> <i>path/to/ciranova</i><tt>/quickstart/lib.defs</tt>
    </blockquote>
    The <i>path/to/ciranova</i> is the installation location, what we have
    called <tt>$CNI_ROOT</tt>.  If there already is a <tt>lib.defs</tt>
    file, the line above should be added.

    <p>
    Once setup is complete, we can test it.
    <ol>
    <li><tt>prompt>  ./xic.cni</tt><br>
    <i>Xic</i> should start, and the "Using OpenAccess" and "Using
    Python" messages should appear in the console.  The layer table
    will show perhaps unfamiliar layers, these have been obtained from
    the Ciranova technology file.  There shouldn't be any error or
    warning message pop-ups.

    <p>
    <li>Switch the editing context to a new, empty cell, if the current
    cell is not empty or is otherwise of value.

    <p>
    <li>Click the <b>OpenAccess Libs</b> button in the <b>File Menu</b>,
    which will exist if OpenAccess is connected (the "Using OpenAccess" message
    appeared).  This will bring up the
    <a href="xic:oalib"><b>OpenAccess Libraries</b></a> panel.  The
    following libraries will be listed.
    <blockquote>
    <tt>IPL_cni130</tt><br>
    <tt>cnVPcellLib</tt>
    </blockquote>

    <p>
    <li>Click on the <tt>IPL_cni130</tt> line to select it, and press
    the <b>Contents</b> button.  The <b>Listing</b> panel should
    appear, loaded up with names.

    <p>
    <li>In the <b>Contents</b>, find the <tt>Nmos2</tt> entry, and
    click on it to select it.

    <p>
    <li>Press the <b>Place</b> button in the <b>Contents</b> listing. 
    The <a href="xic:place"><b>Cell Placement Control</b></a> panel
    will appear.  Press the <b>Place</b> button in this panel, and the
    <a href="xic:pcparams"><b>Parameters</b></a> pop-up will appear. 
    There will be a double-line box "attached" to the mouse pointer.

    <p>
    <li>Have a quick look at the <b>Parameters</b> panel.  These are
    the pcell parameters that can be set.  Feel free to enter some new
    values.  The documentation for the <tt>Nmos2</tt> pcell will
    explain what the parameters are, though a few, such as
    <tt>fingers</tt>, <tt>l</tt>, and <tt>w</tt>, are obvious.

    <p>
    <li>Click anywhere in the drawing window to place an instance. 
    You should expand the view to show the instance content, press
    <b>Ctrl-x</b> for this.  You can place more instances, perhaps
    with different parameters set.  Press the <b>Esc</b> key when
    done.

    <p>
    <li>Click on one of the instances to select it.  Note that some of
    the sides of certain features are highlighted.  These are <a
    href="pc_stretch">stretch handles</a> that can be dragged, to
    change the size of the feature.  Try dragging a handle and note
    the effect.

    <p>
    <li>Place a second instance of <tt>Nmos2</tt> so that it doesn't
    overlap the first.

    <p>
    <li>Move the second instance, place it so that one of the S/D
    contacts overlaps a contact of the first instance.  Note that the
    overlapping contact has disappeared in both instances.  This is <a
    href="pc_abut">auto-abutment</a>.  the two instances can be
    repositioned so as to exactly share the common edge, which
    implements a dual-gate transistor.

    <p>
    <li>Press the <b>PCell Control</b> button in the <b>Edit Menu</b>,
    which will display the <a href="xic:pcctl"><b>PCell Control</b></a>
    pop-up.  In the pop-up, change the <b>Auto-abutment mode</b> to
    <b>Mode 2 (with contact)</b>.

    <p>
    <li>Move one of the cell instances well away from the other, note
    that both instances revert to the original form.  Now drag and
    drop one of the instances over the other so that they share a
    contact, as before.  This time, however, note that a common
    contact is retained.
    </ol>

    This should be enough to get started, have fun!
!!LATEX pycell pcells.tex
Most parameterized cells (pcells) have been written in the Cadence
Virtuoso environment, using the proprietary Skill scripting language
found only in that environment.  These pcells can only be used in a
Virtuoso environment.

Ciranova, Inc., now owned by Synopsys, developed and championed the
idea of portable pcells, pcells that would have published interfaces
and use a common programming language, that could work in any design
environment.  The company provides a free downloadable ``PyCell
Studio'' design kit.  The concept is made possible by the use of
OpenAccess, which has a well-defined framework for pcell support, is
well documented, and source code is published.  Cadence Virtuoso and
most modern tools use OpenAccess.

Though OpenAccess provides support for pcell interfacing and
management, actual execution of the pcell script is exported to
external code supplied as a plug-in.  The plug-in provides an
interface to the language interpreter or compiler and other things
required to execute the script.  This plug-in is supplied by the
system vendor or user.  For example, in a Virtuoso installation, a
Skill plug-in is provided.  OpenAccess comes with example plug-ins for
Tcl and C++.

Ciranova developed a Python plug-in for OpenAccess, with a set of
interface functions for creating geometry and related purposes within
OpenAccess.  Python is a very popular, modern, open source scripting
language.  It is present on any standard Linux system, and is
available for most other operating systems.  Ciranova calls portable
Python-based pcells that use the Ciranova plug-in ``PyCells''.

The PyCell Studio design kit contains tools for viewing, testing, and
creating PyCells.  An example library of PyCells is provided, complete
with technology and display resource files.  It also provides
OpenAccess and Python, so the package is quite complete.  There is
comprehensive documentation and tutorials.

Though Ciranova has been bought by Synopsys, the PyCell Studio remains
available and apparently is still under development.  An industry
group, IPLnow.com, which includes TSMC and other foundries and some
tool vendors, is pushing the cause of ``interoperable'' PDK libraries
based on portable pcells.

Whiteley Research fully supports this effort, and {\Xic} will be
interoperable with the PyCell Studio design kit and PyCells as much as
possible.

\subsection{Connecting to PyCell Studio}

This section describes how {\Xic} can directly interface to the PyCell
Studio example library and technology.  PyCells from the library, or
authored by the user, can be instantiated in {\Xic} cells.

It will be assumed in this discussion that the PyCell Studio has been
downloaded from Synopsys, and installed on your system, which also has
{\Xic} installed.  The PyCell Studio works with Red Hat Enterprise
Linux releases 5 and 6 (and equivalent).  You must choose the same
word size (32 or 64 bits) as your {\Xic} installation.  The
installation location for PyCell Studio is selected by the user, and
we will refer to this location as ``{\vt \$CNI\_ROOT}''.  For example,
{\vt \$CNI\_ROOT} might be {\vt /usr/local/ciranova}.

Although your system will almost certainly have Python installed, it
appears necessary to use the Python provided with the Studio.  In Red
Hat EL6, the Ciranova and stock Python version numbers are the same,
but the libraries are apparently built with different options, and
attempts at using the stock Python have failed (perhaps Synopsys will
fix this?).  You can, however, use your own OpenAccess installation if
you have one and it is reasonably recent.  You can probably also use
OpenAccess from Cadence.

The first step is to make sure that the PyCell Studio installation is
correct by following the steps in the {\vt
\$CNI\_ROOT/quickstart/README.txt} file.

Part of this procedure (step 3) is to source one of the startup files
provided.  This step sets the value of several environment variables,
and forces the system to find the Ciranova Python instead of a local
Python.  It also installs the OpenAccess plug-in for Python.  The user
can customize this script if desired.  It is necessary to source this
file, or otherwise setup the environment as per the file, before
starting {\Xic}.  After finishing, you will want to revert the
environment to the previous state.  Unfortunately, this is difficult. 
You may kill the window and start a new one.

A better way to run {\Xic} in the Ciranova environment would be to
write a script such as the following.  Call it ``{\vt xic.cni}''.

\begin{verbatim}
#! /bin/sh

CNI_ROOT=/usr/local/ciranova
source \$CNI_ROOT/quickstart/bashrc; xic -Tcni \$*
\end{verbatim}

The {\vt CNI\_ROOT} line should be changed to the actual Ciranova
installation location.  After creating the file, make it executable
with
\begin{quote}
\vt chmod 755 xic.cni
\end{quote}

Then, to run {\Xic} in the Ciranova environment, just run this script
instead.  Since it runs in a sub-shell, the environment of the main
shell is not corrupted.  Any command line arguments are passed
through.

Note that above {\Xic} is started with a ``{\vt -Tcni}'' option, which
specifies to use the {\vt xic\_tech.cni} example technology file
provided with {\Xic}.  This uses the {\vt ReadDRF} and {\vt
ReadCniTech} directives to read display resource and technology files
from the Ciranova installation.  However, Ciranova provides a number
of technology files, any you may want to try them.  You will probably
want to copy the {\vt xic\_tech.cni} file to your local directory, so
that it can be edited easily.

Finally, you will need to set up your OpenAccess {\vt lib.defs} to
include the Ciranova libraries.  The {\vt lib.defs} file is a listing
of the OpenAccess libraries available, very similar to the {\vt
cds.lib} file in Cadence.  If no {\vt lib.defs} file exists in the
current directory, using a text editor create the file with a single
line
\begin{quote}
{\vt INCLUDE} {\it path/to/ciranova\/}{\vt /quickstart/lib.defs}
\end{quote}
The {\it path/to/ciranova} is the installation location, what we have
called {\vt \$CNI\_ROOT}.  If there already is a {\vt lib.defs} file,
the line above should be added.

Once setup is complete, we can test it.
\begin{enumerate}
\item{{\vt prompt$>$  ./xic.cni}\\
{\Xic} should start, and the ``Using OpenAccess'' and ``Using Python''
messages should appear in the console.  The layer table will show
perhaps unfamiliar layers, these have been obtained from the Ciranova
technology file.  There shouldn't be any error or warning message
pop-ups.}

\item{Switch the editing context to a new, empty cell, if the current
cell is not empty or is otherwise of value.}

\item{Click the {\cb OpenAccess Libs} button in the {\cb File Menu},
which will exist if OpenAccess is connected (the ``Using OpenAccess''
message appeared).  This will bring up the {\cb OpenAccess Libraries}
panel.  The following libraries will be listed.
\begin{quote}\vt
IPL\_cni130\\
cnVPcellLib
\end{quote} }

\item{Click on the {\vt IPL\_cni130} line to select it, and press the
{\cb Contents} button.  The {\cb Listing} panel should appear, loaded
up with names.}

\item{In the {\cb Contents}, find the {\et Nmos2} entry, and click on
it to select it.}

\item{Press the {\cb Place} button in the {\cb Contents} listing.  The
{\cb Cell Placement Control} panel will appear.  Press the {\cb Place}
button in this panel, and the {\cb Parameters} pop-up will appear. 
There will be a double-line box ``attached'' to the mouse pointer.}

\item{Have a quick look at the {\cb Parameters} panel.  These are the
pcell parameters that can be set.  Feel free to enter some new values. 
The documentation for the {\vt Nmos2} pcell will explain what the
parameters are, though a few, such as {\vt fingers}, {\vt l}, and {\vt
w}, are obvious.}

\item{Click anywhere in the drawing window to place an instance.  You
should expand the view to show the instance content, press {\kb
Ctrl-x} for this.  You can place more instances, perhaps with
different parameters set.  Press the {\kb Esc} key when done.}

\item{Click on one of the instances to select it.  Note that some of
the sides of certain features are highlighted.  These are stretch
handles that can be dragged, to change the size of the feature.  Try
dragging a handle and note the effect.}

\item{Place a second instance of {\vt Nmos2} so that it doesn't
overlap ther first.}

\item{Move the second instance, place it so that one of the S/D
contacts overlaps a contact of the first instance.  Note that the
overlapping contact has disappeared in both instances.  This is
auto-abutment.  the two instances can be repositioned so as to exactly
share the common edge, which implements a dual-gate transistor.}

\item{Press the {\cb PCell Control} button in the {\cb Edit Menu},
which will display the {\cb PCell Control} pop-up.  In the pop-up,
change the {\cb Auto-abutment mode} to {\cb Mode 2 (with contact)}.}

\item{Move one of the cell instances well away from the other, note
that both instances revert to the original form.  Now drag and drop
one of the instances over the other so that they share a contact, as
before.  This time, however, note that a common contact is retained.}
\end{enumerate}

This should be enough to get started, have fun!

!!SEEALSO
xic:pcells
!!ENDIF

!! 022816
!!KEYWORD
stdvia
!!TITLE
Standard Vias
!!HTML
    <i>Xic</i> provides a feature for creating and managing via
    objects used to connect between conducting layers in physical
    layouts.  Although ordinary cells or cut-layer objects can be used
    for this purpose, use of standard vias offers some important
    advantages in many designs.

    <ul>
    <li>The vias can contain the structure necessary so that proper
    use automatically satisfies design rule constraints.

    <li>The vias are designed to allow a zero <a
    href="ViaSearchDepth">search depth</a> for extraction, speeding
    this process.

    <li>The creation of the "sub-master" cells that implement the vias
    is handled transparently by the system, removing the often large number
    of ordinary via cells from the cell listings.  The via cells are no
    longer written in output, reducing file size and complexity.

    <li>The vias are easily created from the <a
    href="xic:crvia"><b>Via Creation</b></a> panel in the <b>Edit
    Menu</b> and can be placed immediately, which is quick and
    efficient.
    </ul>

    In order for this feature to be available, one or more <a
    href="techfile:stdvia">standard vias definitions</a> must appear
    in the technology file.  These will also be imported from a
    Cadence Virtuoso ASCII technology file if the <a
    href="ReadCdsTech"><tt>ReadCdsTech</tt></a> keyword is used, and
    the Cadence database contains <tt>standardViaDefs</tt> definitions. 
    The implementation of standard vias in <i>Xic</i> closely follows
    the implementation in OpenAccess, and tools such as Virtuoso that
    use OpenAccess.

    <p>
    The standard vias that are defined in the technology provide the
    default definitions for a via structure.  Although commonly instantiated
    directly, more commonly variations are implemented.  There are a number
    of parameters that define the via, and these can be changed by the user
    to produce a variant most suitable in the context where it will be used.
    For example, the cut can be arrayed when lower contact resistance is
    required.

    <p>
    The mechanism is similar to a <a href="xic:pcells">parameterized
    cell</a> (pcell).  The standard vias defined in the technology can
    be considered as the super-masters.  When a via of a certain
    configuration is requested, a "sub-master" cell for that
    configuration is created in memory, if it hasn't been created
    previously.  The instances of the via will reference that
    sub-master.  Like pcells, the masters are not written to disk. 
    Instead, when a file containing via placements is read, the via
    sub-masters are created in memory as needed.

    <p>
    An exception is when shipping a layout to another system, such as
    to a mask vendor.  The <a href="xic:exprt"><b>Export
    Control</b></a> panel from the <b>Convert Menu</b> is used for
    this purpose.  If the <b>Strip For Export</b> check box is checked
    or equivalently if the <a
    href="StripForExport"><b>StripForExport</b></a> variable is set,
    which should be true in this situation, the via (and pcell)
    sub-masters are included in the layout file.  The foreign system
    will see these as ordinary cells.  The <b>Include standard via
    cell sub-masters</b> check box or equivalently the <a
    href="ViaKeepSubMasters"><b>ViaKeepSubMasters</b></a> variable
    will likewise cause inclusion of the via sub-masters in output
    when set.

    <p>
    A standard via definition provides values for a number of
    parameters.  Of these, the numerical values can be changed by the
    user to form a variant.  The layers involved are immutable.  Each
    standard via definition has a unique name assigned in the
    technology.  This name can be any text which is suitable as a cell
    name.  One convention is to use the layer names of the two
    conductors, top layer first, separated by an underscore, e.g.,
    "<tt>M2_M1</tt>".  The parameters and their effects are described
    with the <a href="xic:crvia"><b>Via Creation</b></a> panel, from
    which the parameters can be set, and variants created and placed.

    <a name="prpty"></a>
    <h4>The Standard Via Property String</h4>

    The <b>stdvia</b> property (number 7160) is applied to standard
    via instances and sub-masters.
!!IFDEF OpenAccess
    The OpenAccess translator will transparently convert these to the
    corresponding OpenAccess forms when writing to OpenAccess, and
    <i>vice-versa</i>.
!!ENDIF
    A string with very similar format to the property string is used
    by the <a href="OpenViaSubMaster"><tt>OpenViaSubMaster</tt></a>
    script function.  The property string syntax is described here.

    <p>
    There are actually two formats, that will be referred to as the
    old and new formats.  The old format uses OpenAccess keywords and
    is friendly for humans, the new format uses a code and is more
    compact.  <i>Xic</i> will always write the new format, but will
    read either format.

    <p>
    The property string consists of one or more space-separated text
    tokens.  In either case, the first token is the name of the
    standard via, as given in the definition in the technology file. 
    The remaining terms represent the numerical parameters that are
    different from the defaults given in the standard via definition. 
    There need not be any additional tokens, in which case the via has
    all default values.  More commonly, tokens follow the via name
    that provide alternate values.

    <p>
    In the old format, a token takes one of the forms
    <blockquote>
    <i>keyword</i><tt>:</tt><i>value</i><br>
    <i>keyword</i><tt>:</tt><i>value</i><tt>,</tt><i>value</i>
    </blockquote>
    The <i>value</i> indicates an integer representing a dimension
    in internal units.

    <p>
    The new format assigns each numeric value a lower-case letter.
    A token consists of the letter, followed immediately by the
    numeric value in nanometers.  The number is printed in a format
    which removes trailing zeros and decimal points.

    <blockquote>
    <table border=1 cellpadding=2 bgcolor="#ffffee">
    <tr><th>new format key letter(s)</th> <th>old format keyword</th></tr>
    <tr><td><tt>a</tt></td>   <td><tt>CutWidth</tt></td></tr>
    <tr><td><tt>b</tt></td>   <td><tt>CutHeight</tt></td></tr>
    <tr><td><tt>c</tt></td>   <td><tt>CutRows</tt></td></tr>
    <tr><td><tt>d</tt></td>   <td><tt>CutColumns</tt></td></tr>
    <tr><td><tt>e,f</tt></td> <td><tt>CutSpacing</tt></td></tr>
    <tr><td><tt>g,h</tt></td> <td><tt>Layer1Enc</tt></td></tr>
    <tr><td><tt>i,j</tt></td> <td><tt>Layer1Off</tt></td></tr>
    <tr><td><tt>k,l</tt></td> <td><tt>Layer2End</tt></td></tr>
    <tr><td><tt>m,n</tt></td> <td><tt>Layer2Off</tt></td></tr>
    <tr><td><tt>o,p</tt></td> <td><tt>OriginOff</tt></td></tr>
    <tr><td><tt>q,r</tt></td> <td><tt>Implant1Enc</tt></td></tr>
    <tr><td><tt>s,t</tt></td> <td><tt>Implant2Enc</tt></td></tr>
    </table>
    </blockquote>

    The new and old formats can <b>not</b> be mixed, all tokens must
    follow one format or the other.  The cases with two letters
    correspond to the keywords with two values, and the values
    represent dimensions in the X and Y directions.

    <p>
    Examples:
    <blockquote>
    <tt>M2_M1 CutRows:2 CutColumns:2 Layer1Enc:40,60</tt><br>
    <tt>M2_M1 c2 d2 h60</tt>
    </blockquote>

    <p>
    The two strings are equivalent if 1) the database resolution is
    1000 so that the internal unit is nanomenters, and 2) the
    default layer 1 enclosure in the X direction is 40nm.

    <p>
    When a sub-master is created, it is given a cell name that is
    the same as a new format property string with the space stripped
    out, and the characters '-' (minus) and '.' (period) replaced
    by 'm' and 'p', respectively.

    <p>
    The <a href="OpenViaSubMaster"><tt>OpenViaSubMaster</tt></a>
    script function takes a string in almost the same format,
    the only difference is that the via name token is not present.
    Effectively, the via name is passed as the first argument, and the
    rest of the string (if anything) is passed as the second argument.
    Either new or old format is acceptable.
!!LATEX stdvia pcells.tex
{\Xic} provides a feature for creating and managing via objects used
to connect between conducting layers in physical layouts.  Although
ordinary cells or cut-layer objects can be used for this purpose, use
of standard vias offers some important advantages in many designs.

\begin{itemize}
\item{The vias can contain the structure necessary so that proper use
automatically satisfies design rule constraints.}

\item{The vias are designed to allow a zero search depth for
extraction, speeding this process.}

\item{The creation of the ``sub-master'' cells that implement the vias
is handled transparently by the system, removing the often large
number of ordinary via cells from the cell listings.  The via cells
are no longer written in output, reducing file size and complexity.}

\item{The vias are easily created from the {\cb Via Creation} panel in
the {\cb Edit Menu} and can be placed immediately, which is quick and
efficient.}
\end{itemize}

In order for this feature to be available, one or more standard vias
definitions must appear in the technology file.  These will also be
imported from a Cadence Virtuoso ASCII technology file if the {\vt
ReadCdsTech} keyword is used, and the Cadence database contains {\vt
standardViaDefs} definitions.  The implementation of standard vias in
{\Xic} closely follows the implementation in OpenAccess, and tools
such as Virtuoso that use OpenAccess.

The standard vias that are defined in the technology provide the
default definitions for a via structure.  Although commonly
instantiated directly, more commonly variations are implemented. 
There are a number of parameters that define the via, and these can be
changed by the user to produce a variant most suitable in the context
where it will be used.  For example, the cut can be arrayed when lower
contact resistance is required.

The mechanism is similar to a parameterized cell (pcell).  The
standard vias defined in the technology can be considered as the
super-masters.  When a via of a certain configuration is requested, a
``sub-master'' cell for that configuration is created in memory, if it
hasn't been created previously.  The instances of the via will
reference that sub-master.  Like pcells, the masters are not written
to disk.  Instead, when a file containing via placements is read, the
via sub-masters are created in memory as needed.

An exception is when shipping a layout to another system, such as to a
mask vendor.  The {\cb Export Control} panel from the {\cb Convert
Menu} is used for this purpose.  If the {\cb Strip For Export} check
box is checked or equivalently if the {\et StripForExport} variable is
set, which should be true in this situation, the via (and pcell)
sub-masters are included in the layout file.  The foreign system will
see these as ordinary cells.  The {\cb Include standard via cell
sub-masters} check box or equivalently the {\et ViaKeepSubMasters}
variable will likewise cause inclusion of the via sub-masters in
output when set.

A standard via definition provides values for a number of parameters. 
Of these, the numerical values can be changed by the user to form a
variant.  The layers involved are immutable.  Each standard via
definition has a unique name assigned in the technology.  This name
can be any text which is suitable as a cell name.  One convention is
to use the layer names of the two conductors, top layer first,
separated by an underscore, e.g., ``{\vt M2\_M1}''.  The parameters
and their effects are described with the {\cb Via Creation} panel,
from which the parameters can be set, and variants created and placed.

\subsection{The Standard Via Property String}
\label{stdviaprp}

The {\et stdvia} property (number 7160) is applied to standard via
instances and sub-masters.
%\ifoa
The OpenAccess translator will transparently convert these to the
corresponding OpenAccess forms when writing to OpenAccess, and {\it
vice-versa\/}.
%\fi
A string with very similar format to the property string is used by
the {\vt OpenViaSubMaster} script function.  The property string
syntax is described here.

There are actually two formats, that will be referred to as the old
and new formats.  The old format uses OpenAccess keywords and is
friendly for humans, the new format uses a code and is more compact. 
{\Xic} will always write the new format, but will read either format.

The property string consists of one or more space-separated text
tokens.  In either case, the first token is the name of the standard
via, as given in the definition in the technology file.  The remaining
terms represent the numerical parameters that are different from the
defaults given in the standard via definition.  There need not be any
additional tokens, in which case the via has all default values.  More
commonly, tokens follow the via name that provide alternate values.

In the old format, a token takes one of the forms
\begin{quote}
{\it keyword\/}{\vt :}{\it value\/}\\
{\it keyword\/}{\vt :}{\it value\/}{\vt ,}{\it value}
\end{quote}
The {\it value} indicates an integer representing a dimension in
internal units.

The new format assigns each numeric value a lower-case letter.  A
token consists of the letter, followed immediately by the numeric
value in nanometers.  The number is printed in a format which removes
trailing zeros and decimal points.

\begin{tabular}{|l|l|} \hline
\bf new format key letter(s) & \bf old format keyword\\ \hline\hline
\vt a &   \vt CutWidth\\ \hline
\vt b &   \vt CutHeight\\ \hline
\vt c &   \vt CutRows\\ \hline
\vt d &   \vt CutColumns\\ \hline
\vt e,f & \vt CutSpacing\\ \hline
\vt g,h & \vt Layer1Enc\\ \hline
\vt i,j & \vt Layer1Off\\ \hline
\vt k,l & \vt Layer2End\\ \hline
\vt m,n & \vt Layer2Off\\ \hline
\vt o,p & \vt OriginOff\\ \hline
\vt q,r & \vt Implant1Enc\\ \hline
\vt s,t & \vt Implant2Enc\\ \hline
\end{tabular}

The new and old formats can {\bf not} be mixed, all tokens must follow
one format or the other.  The cases with two letters correspond to the
keywords with two values, and the values represent dimensions in the X
and Y directions.

Examples:\\
\begin{quote}\vt
M2\_M1 CutRows:2 CutColumns:2 Layer1Enc:40,60\\
M2\_M1 c2 d2 h60
\end{quote}

The two strings are equivalent if 1) the database resolution is 1000
so that the internal unit is nanomenters, and 2) the default layer 1
enclosure in the X direction is 40nm.

When a sub-master is created, it is given a cell name that is the same
as a new format property string with the space stripped out, and the
characters `$-$' (minus) and `.' (period) replaced by `{\vt m}' and
`{\vt p}', respectively.

The {\vt OpenViaSubMaster} script function takes a string in almost
the same format, the only difference is that the via name token is not
present.  Effectively, the via name is passed as the first argument,
and the rest of the string (if anything) is passed as the second
argument.  Either new or old format is acceptable.

