% -----------------------------------------------------------------------------
% Xic Manual
% (C) Copyright 2009, Whiteley Research Inc., Sunnyvale CA
% $Id: usermenu.tex,v 1.21 2014/10/23 04:37:40 stevew Exp $
% -----------------------------------------------------------------------------

% -----------------------------------------------------------------------------
% xic:usermenu 081824
\chapter{The User Menu:  User Commands and {\Xic} Scripts}
\label{chpscript}

The {\cb User Menu} contains built-in commands listed in the table below.

\begin{tabular}{|l|l|l|l|} \hline
\multicolumn{4}{|c|}{\kb User Menu}\\ \hline
\kb Label & \kb Name & \kb Pop-up & \kb Function\\ \hline\hline
\et Debugger & \vt debug & \cb Script Debugger & Debug scripts\\ \hline
\et Rehash & \vt hash & none & Rebuild {\cb User Menu}\\ \hline
others &  --- & --- & User scripts and menus\\ \hline
\end{tabular}

Other buttons which appear in the {\cb User Menu} execute
user-generated scripts, or pop up menus of user-generated scripts. 
{\Xic} provides a powerful native language, from which the user can
automate various tasks.  The {\cb User Menu} is the primary means to
execute scripts, though the {\cb !exec} command provides a
non-graphical alternative.

The default system-wide location for scripts is in the
directory\newline {\vt /usr/local/xictools/xic/scripts}, however
this can be reset with the {\et XIC\_SCR\_PATH} environment variable,
or defined in the technology file with the {\vt ScriptPath} keyword. 
The syntax is the same as for other {\Xic} search paths, for example:

\begin{quote}
{\vt ScriptPath (} {\it directory directory1}{\vt  ... )}
\end{quote}

This path can also be set with the {\et ScriptPath} variable using the
{\cb !set} command.  A script path set with the {\et ScriptPath}
variable takes precedence over a script path defined in the
environment using the {\et XIC\_SCR\_PATH} environment variable.  If no
script path is specified in the technology file, the effective path
used will consist of the single default directory.

Each directory in the search path is expected to contain script files,
which must have an extension ``{\vt .scr}'', function libraries which
are named ``{\vt library}'', and script menu files, which will produce
a drop-down sub-menu in the {\cb User Menu}.  {\Xic} provides a library
capability which allows code to be shared between scripts.  Script
menu files must have an extension ``{\vt .scm}''.  In addition,
auxiliary files such a images, data, or documentation files may also
be present, for use in certain scripts.  These will be ignored when
searching for scripts.

The default button label in the {\cb User Menu} for a script found in
the search path is the base name of the script file, i.e., the file
name with the {\vt .scr} stripped off.  However, if the first
non-blank line of the script file is of the form

\begin{quote}
{\vt \#menulabel} {\it label}
\end{quote}

then the {\cb User Menu} button will use the text in {\it label}.  If
the {\it label} text contains white space, it must be quoted.  This
text can contain punctuation, though some characters may be stripped
or replaced internally.  The {\it label} text must be unique in the
top level of the {\cb User Menu}, duplicate entries will not be added.

Scripts can also be included in the technology file itself.  These
scripts will also appear as buttons in the {\cb User Menu}, as with
other scripts.  This can be useful for including simple
technology-specific commands, such as those that create special
extraction layers.  However, scripts defined in the technology file
can not be loaded into the debugger.

The {\cb !script} command is yet another means by which scripts can be
placed into the {\cb User Menu}.  This command associates a label,
which will appear on the menu button, with an arbitrary path to a
script file.  Commands registered in this way can also be removed with
the {\cb !script} command.

Each command button label in the {\cb User Menu} is unique in the menu
or sub-menu where it resides.  If a duplicate label is found during
the search along the search path, that script will not be added to the
menu, and the existing entry will be retained.  However, scripts added
from the technology file and with the {\cb !script} command are stored
somewhat differently, so label text clashes can occur.  The following
priority is observed in this case.

\begin{enumerate}
\item{Scripts defined with the {\cb !script} command.}
\item{Scripts found in the script search path and menus.}
\item{Scripts found in the technology file.}
\end{enumerate}

An encryption capability for scripts is provided.  This allows the
content of scripts to be hidden from users.

\section{Example Scripts in User Menu}
The {\Xic} installation provides some example scripts, which will
appear in the {\cb User Menu}.  To use these buttons (or any menu
buttons) while in help mode, press {\kb Shift} while pressing the
menu button.

\begin{description}
\index{blackbg script}
\item{\cb blackbg}: Use a black drawing window background.\\
This reverts drawing window colors to use a black background,
which is the default.

\index{fullcursor script}
\item{\cb fullcursor}: Set/unset full-window cursor.\\
This command executes a script that toggles whether the {\et
FullWinCursor} variable is set.  When set, the default cursor consists
of horizontal and vertical lines that extend completely across the
drawing window.  The lines intersect at the nearest snap point in the
current window.

\index{paths script}
\item{\cb paths}: Set search-path script.\\
This command executes a script which allows the search path variables
to be edited graphically.  These variables are otherwise set with the
{\cb !set} command, or from the technology file.

\index{spiral script}
\item{\cb spiral}: Spiral generator demo script.\\
This is a text-based command for creating a spiral feature.  A series
of prompts is given on in the prompt line, where the user supplies
dimensions, number of turns, etc.  When the prompts are complete, an
outline of the spiral is attached to the mouse pointer, and will be
instantiated in the drawing window where the user clicks, on the
current layer.

\index{spiralform script}
\item{\cb spiralform}: Form-based spiral generator demo script.\\
This is a graphical version of the {\cb spiral} script, where the user
fills in a form instead of responding to prompts.  This is a
demonstration of the capability of {\Xic} to use HTML forms as a
front-end to command scripts.

\index{whitebg script}
\item{\cb whitebg}: Use a white drawing window background.\\
Switch to use of a white background color in drawing windows.
This adjusts certain attribute colors for greater contrast,
and is intended for schematics.

\index{whitebw script}
\item{\cb whitebw}: Use black on white in drawing windows.\\
    Similar to {\cb whitebg} except that non-background is black.
This is intetended for export of schematics to black and white
media.

\index{yank script}
\item{\cb yank}: Copy geometry to new cell demo script.\\
This example script allows the user to copy all geometry in a
rectangular area, independent of hierarchy, to a new flat cell.  The
user clicks twice to define the area, and responds to the prompt for a
new cell name.  All geometry in the area is copied, clipped to the
area, and added to the new cell.  The original objects are not
affected.
\end{description}


% -----------------------------------------------------------------------------
% submenu 020611
\section{Script Menus: User-Defined Sub-Menus}

Sub-menus in the {\cb User Menu} are produced by a type of library
file, ``script menus'', which (at the top level) are found in the
directories in the script search path.  The script menus {\it must}
have an extension ``{\vt .scm}'' (``script menu'').  The format is
similar to library files:

\begin{quote}
    {\vt (Library {\it libname\/});}\\
    {\vt \#} {\it any comments}\\
    \\
    {\vt \#} {\it optional keywords to implement conditional flow}\\
    {\vt Define} [{\vt eval}] {\it name} [{\it value\/}]\\
    {\vt If} {\it expression}\\
    {\vt IfDef} {\it name}\\
    {\vt IfnDef} {\it name}\\
    {\vt Else}\\
    {\vt Endif}\\
    \\
    $[${\vt nosort}$]$\\
    {\it name1   path\_to\_script}\\
    ...\\
    $[${\it name2\/}$]$   {\it path\_to\_menu}\\
    ...
\end{quote}

The first line must be a CIF comment line in the same format as other
library files.  The {\it libname} contains the text which will appear
in the menu button which will pop up the menu.  This text may contain
white space and/or punctuation, though some special characters, such
as `/', may be stripped or replaced internally.  The text can be
quoted, though this is optional.  The text can also not appear at all,
in which case the label used will be the base name (the file name,
stripped of the {\vt .scm} extension) of the menu file.

Blank lines and lines starting with `{\vt \#}' are ignored.  If a line
containing the single word ``{\vt nosort}'' is found, then the menu
entries will be in the same order as in the file, otherwise they will
be alphabetically sorted.  The {\cb User Menu} itself is always
sorted.

All library files (including the device library) support a limited
macro capability.  The macro capability makes use of the generic macro
preprocessor provided in {\Xic}, which is described in \ref{macro}. 
The reader should refer to this section for a full description of the
preprocessor capabilities.  The preprocessor provides a few predefined
macros used for testing (and customizing for) release number,
operating system, etc.  The keyword names, which correspond to the
generic names as described for the macro preprocessor, are
case-insensitive and listed in the following table.

\begin{tabular}{ll}
\bf Keyword & \bf Function\\
\vt Define & Define a macro.\\
\vt If & Conditional evaluated test.\\
\vt IfDef & Conditional definition test.\\
\vt IfnDef & Conditional non-definition test.\\
\vt Else & Conditional else clause.\\
\vt Endif & Conditional end clause.\\
\end{tabular}

These can be used to conditionally determine which parts of the file
are actually loaded when the library is read.  The paths (but not the
names) are macro expanded, and the conditional keywords can be used to
implement flow control as the file is read.  They work the same as
similar keywords in the technology file (see \ref{techmacros}) and in
scripts (see \ref{preproc}), and are reminiscent of the preprocessor
directives in the C/C++ programming language.

The {\vt Define eval} construct can access functions found in a script
library file (see \ref{scrlib}) found in the same script search path
component directory as the menu file file, or from library files found
earlier in the search path.  When traversing the script search path,
the library file, if any, is loaded before the script files and menu
files are read.

The remaining lines in the file are name/path pairs, where the {\it
name} is the label that will appear on the button in the pop-up menu,
and the {\it path} is a {\it full} path to a script file (with ``{\vt
.scr}'' extension) or another script menu file (with ``{\vt .scm}''
extension) for a sub-menu.  If the path is to a menu file, the pop-up
menu will contain a button which will produce another pop-up menu
containing the referenced menu file's entries.  There is no limit on
the depth of the references.  In this case, the {\it name} can be
omitted, in which case the referenced menu file will supply the button
text.  If a {\it name} is given, it will supersede the button text
defined in the referenced menu file.

A {\it name} must always be given for a path to a script file.  If the
label text in {\it name} contains white space, it must be quoted. 
Punctuation is allowed, though some characters may be stripped or
replaced internally.  Each {\it name} text should be unique in the
menu, duplicates are ignored.

Scripts referenced through a menu file should not be kept in the
script search path directories, as they would be added to the main
{\cb User Menu} as well as the pop-up menu.  They can be placed, for
example, in a subdirectory of the directory containing the menu file,
which is not itself in the script path.

Only scripts which are defined in separate files can be referenced
through a script library, not those defined in the technology file. 
Scripts defined in the technology file, and those added with the {\cb
!script} command, will appear in the main {\cb User Menu}.

{\bf Example:}

Suppose that you have a {\vt submenu.scm} file, and you want to be
able to set the command paths at program startup, depending on some
factors.  One way to do this is to white a function and place it in
the script {\vt library} file, that will return a path to a
directory containing the menu functions, e.g.,

\begin{quote}
{\vt function func\_loc()}\\
\hspace*{2ex}{\vt if (}{\it something\/}{\vt )}\\
\hspace*{4ex}{\vt return ("/home/bob/commands")}\\
\hspace*{2ex}{\vt else}\\
\hspace*{4ex}{\vt return ("/home/joe/commands")}\\
\hspace*{2ex}{\vt end}\\
{\vt endfunc}
\end{quote}

In the {\vt submenu.scm} file, one has lines like

\begin{quote} \vt
define eval FUNC\_LOC func\_loc()\\
cmd1 FUNC\_LOC/cmd1.scr\\
cmd2 FUNC\_LOC/cmd2.scr\\
...
\end{quote}

In this example, the menu appearance is always the same, however the
functions executed when a button is pressed depend on the {\vt
func\_loc()} return.


% -----------------------------------------------------------------------------
% scr:library 062808
\section{Script Libraries: Code Sharing}
\label{scrlib}
\index{library file}
\index{function library}

Scripts are executed in {\Xic} using a high-performance compilation
technique whereby the entire script is first compiled, then executed.
Looping constructs within the script execute very quickly.  Further,
scripts can call user-defined functions that have been saved in a
library, avoiding the tiny compilation overhead and allowing the
user to build a collection of sharable function blocks.

Files named ``{\vt library}'' in the script search path are read and
processed when {\Xic} starts, and during a {\cb Rehash} command. 
These files should contain function definitions.  The functions will
be ``compiled'' and saved within {\Xic}.  Any executable lines that
are not part of a function block will be executed once only as the
library is read.  This can provide initialization, if needed.

Functions that are saved will be available for calling from scripts,
avoiding having to parse them each time the script is run.  This also
facilitates using the same functions in several scripts.

The functions saved within {\Xic} can be maintained with two `!'
commands:  {\cb !listfuncs} provides a pop-up listing of the functions
stored, and {\cb !rmfunc} allows the user to remove functions from
memory.


% -----------------------------------------------------------------------------
% scr:crypt 062808
\section{Encrypted Scripts}

Script encryption allows script files to be encoded so as to be
unreadable without a password.  This allows OEMs to provide script
packages to users while maintaining confidentiality of the script
content.

The encryption method is strong enough to foil most attempts at
breaking the code by average users, however it is probably easily
broken by experts.  The encryption algorithm is not export-restricted.

Encryption and decryption of script files is implemented with two
utilities, which are provided in the Accessories distribution.  Also
provided with the accessories is a utility for changing the default
password compiled into the {\Xic} executable.  There is also a related
script function, and a related command-line argument to {\Xic}.

The encryption/decryption utilities are:
\begin{quote}
{\vt wrencode} {\it file} [{\it files} ...]\\
{\vt wrdecode} {\it file} [{\it files} ...]
\end{quote}

Both programs take as arguments lists of files to encode or decode. 
At least one file must be specified.

The {\vt wrencode} program will prompt the user for a password, and
for a repetition of the password.  The files on the command line will
be encrypted using this password.\\
{\cb WARNING}:  since the encryption is done in-place, be sure to save
a non-encrypted backup of the files.

The {\vt wrdecode} program will prompt once for a password, and will
decrypt the files listed in the command line which have been encrypted
with this password.  They are not touched otherwise.

The encryption/decryption should be portable between all systems that
can run these two utilities.

{\Xic} will read plain-text and encrypted scripts.  Encrypted scripts
can be read only if {\Xic} has the correct password, i.e., the one
used in the {\vt wrencode} utility to encrypt the scripts.  At
present, {\Xic} can only retain one password at a time.

{\Xic} has a built-in default password, which is active if no other
password is specified.  This is built into the {\Xic} executable file
(in encrypted form) and can be changed with the {\vt wrsetpass}
utility.  The ``factory'' default password is:
\begin{quote}
Default password: {\vt qwerty}
\end{quote}

The password can be given to {\Xic} on the command line with the {\vt
-K} option:
\begin{quote}
{\vt -K}{\it password}
\end{quote}
Note that there is no space between the ``{\vt -K}'' and the password. 
As the password can contain almost any character, if the password
contains characters which could be misinterpreted by the shell, the
password should be quoted, e.g., {\vt -K'}{\it password}{\vt '}.  The
password set with the {\vt -K} option overrides the default password.

If the {\vt .xicinit} or {\vt .xicstart} file, or the function library
file, or a script run from batch mode, is encrypted, the encryption
password must be given to {\Xic} with the {\vt -K} option, or be the
default password.  As the password can be changed with the {\vt
SetKey} script function, {\cb User Menu} scripts can in principle use
different passwords, which must be set before the script is executed.

It is possible the change the password when {\Xic} is running with the
{\vt SetKey} script function:
\begin{quote}
(int) {\vt SetKey}({\it password\/})
\end{quote}

This function sets the key used by {\Xic} to decrypt encrypted
scripts.  The password must be the same as that used to encrypt the
scripts.  This function returns 1 on success, i.e., the key has been
set, or 0 on failure, which shouldn't happen as even an empty string
is a valid password.

At most one password is active at a time.  If the file can not be
opened with the current password, {\Xic} will behave as if the file
was empty.


% -----------------------------------------------------------------------------
% xic:debug 041413
\section{The {\cb Debug} Button: Enter Script Debugger}

\index{scripts!debugging}
The {\cb Debugger} button in the {\cb User Menu}, which unlike most of
the other commands in this menu is an internal command, brings up a
panel which facilitates script development.  The panel contains
debugging options such as breakpoints, single-stepping, and text
editing.

The text window displays the text of the currently loaded script.  In
editing mode, the verbatim text is shown.  When not in editing mode,
the text is shifted to the right by two columns, so that the first
column can be used to indicate breakpoints and the current line.

The current mode (editing or executing) is switched by the button to
the left of the title bar.  The label of this button switches between
``{\vt Run}'' and ``{\vt Edit}'' to indicate the mode to switch to. 
In edit mode, the {\cb Execute} menu is not available.  In execute
mode, the {\cb Edit} menu is not available, and some functions in the
{\cb File} menu, such as {\cb New} and {\cb Load}, will switch back to
edit mode.

\index{scripts!editing}
\index{scripts!debugging!File menu}
While in editing mode, the text in the window can be edited, using the
same keyboard commands as the text editor pop-up.  The text is shown
as it appears in the buffer, without the first two columns reserved
for breakpoint indication as used outside of edit mode.

The following command buttons appear in the {\cb File} menu.

\begin{description}
\index{scripts!new script}
\item{\cb New}\\
This button will clear the present contents of the text window,
allowing a new script to be keyed in.  If the present script is
modified and not saved, a message will inform the user, and the text
will not be cleared.  Pressing the {\cb New} button a second time will
clear the text, and the previous changes will be lost.

\index{scripts!debugging!load}
\item{\cb Load}\\
The {\cb Load} button will prompt for the name
of a script file, which will be loaded into the debugger.  A full path
must be given to the file, if the file is not in the script search
path.  If, while the load pop-up is active, a script is selected in
the {\cb User Menu}, that script name will be loaded into the load
dialog text area.

\index{scripts!debugging!print}
\item{\cb Print}\\
The {\cb Print} button brings up a control panel for sending the
contents of the text window to a printer, or to a file.

\item{\cb Save As}\\
This button allows the contents of the text window to be saved in a
file.  The user is prompted for the name of the file, the default
being the original file name, if any.  A pre-existing file of the same
name will be retained with a ``{\vt .bak}'' extension.

\item{\cb Write CRLF}\\
This menu item appears only in the Windows version.  It controls the
line termination format used in files written using {\cb Save As}. 
The default is to use the archaic Windows two-byte (DOS) termination. 
If this button is unset, the more modern and efficient Unix-style
termination is used.  Older Windows programs such as Notepad require
two-byte termination.  Most newer objects and programs can use either
format, as can the {\XicTools} programs.

\item{\cb Quit}\\
The {\cb Quit} button will retire the debug panel, which is the same
effect as pressing the {\cb Debugger} button in the {\cb User Menu} a
second time.  If there is unsaved text, a message will alert the user,
and the panel will not be withdrawn.  Pressing the {\cb Quit} button a
second time will retire the panel without saving changes.  The
debugger can also be dismissed with the window manager ``delete
window'' function, which has the same effect as the {\cb Quit} button.
\end{description}

The debugger text window serves as a drop receiver.  Files can be
loaded by dragging from the {\cb File Selection} panel or another drag
source, and dropping into the text window of the debugger, or the
small ``load'' dialog window that receives the file name.  The file
name will be transferred to the load dialog, which will appear if not
already present.

If, while in editing mode, the {\kb Ctrl} key is held during the drop,
the text will instead be inserted into the document at the insertion
point.

\index{scripts!debugging!Edit menu}
The {\cb Edit} menu contains commands specific to editing mode, and is
disabled while in execute mode.

\begin{description}
\item{\cb Undo}
This will undo the last modification, progressively.  The number of
operations that can be undone is limited to 25 in Windows, but is
unlimited in Unix/Linux.

\item{\cb Redo}
This will redo previously undone operations, progressively.
\end{description}

The remaining entries allow copying of selected text to and from other
windows.  These work with the clipboard provided by the operating
system, which is a means of transferring a data item between windows
on the desktop (see \ref{clipboard}).

\begin{description}
\item{\cb Cut to Clipboard}\\
Delete selected text to the clipboard.  The accelerator {\kb Ctrl-x}
also performs this operation.  This function is not available if the
text is read-only.

\item{\cb Copy to Clipboard}\\
Copy selected text to the clipboard.  The accelerator {\kb Ctrl-c}
also performs this operation.  This function is available whether or
not the text is read-only.

\item{\cb Paste from Clipboard}\\
Paste the contents of the clipboard into the document at the cursor
location.  The accelerator {\kb Ctrl-v} also performs this operation. 
This function is not available if the text is read-only.

\item{\cb Paste Primary} (Unix/Linux only)\\
Paste the contents of the primary selection register into the document
at the cursor location.  The accelerator {\kb Alt-p} also performs
this operation.  This function is not available if the text is
read-only.
\end{description}

\index{scripts!debugging!Execute menu}
The {\cb Execute} menu contains commands for executing the script in a
controlled fashion.  Displaying this menu switches to execute mode. 
The text is shifted to the right by two columns.  The first column is
used to indicate the next line to execute, and breakpoints.

\index{scripts!debugging!breakpoints}
The current line, which would be executed next, is shown with a
colored `{\vt >}' in the first column.  Clicking on this line will
cause the line to be executed, and the `{\vt >}' will advance to the
next executable line (the same as the {\cb Step} menu item).  Clicking
on any other executable line of text in the text window will set a
breakpoint, or clear the breakpoint if a breakpoint is already set on
that line.  A line containing a breakpoint is shown with a `{\vt B}'
in the first column.  Execution, initiated with the {\cb Run} button,
will pause before the next line containing a breakpoint, after the
current line.

\begin{description}
\index{scripts!debugging!execution}
\item{\cb Run}\\
The {\cb Run} button will cause lines of the script to be executed
until a line containing a breakpoint or the end of the script is
reached.  Pressing {\kb Ctrl-c} when a drawing window has the focus
will cause the script to pause at the next line.

\index{scripts!debugging!single-stepping}
\item{\cb Step}\\
The {\cb Step} button causes the current line to be executed, and the
current line pointer will be advanced to the next line.

\index{scripts!debugging!reset}
\item{\cb Step}\\
The {\cb Reset} button will reset the current line to the start of the
script.
\end{description}

In addition to the accelerators listed in the {\cb Execute} menu,
there are hard-coded accelerators for the menu functions.

\begin{tabular}{|l|l|} \hline
{\kb t}, {\kb Space}     & single step\\ \hline
\kb r                    & run\\ \hline
{\kb e}, {\kb Backspace} & reset\\ \hline
\end{tabular}

A problem with the menu accelerators is that they require the {\kb
Ctrl} key to be pressed, which may fool scripts that are sensitive to
the {\kb Ctrl} key.

\begin{description}
\index{scripts!debugging!monitor}
\item{\cb Monitor}\\
The {\cb Monitor} button allows variables to be monitored and set.
\end{description}

After the {\cb Monitor} button is pressed, the user is prompted for
the names of variables from the {\Xic} prompt line.  A list of
variable names (space separated) is entered.  A pop-up window will
appear which lists these variables and their present values.  If the
variable is undefined or not in scope, the value will be ``???''.  The
values are updated after each line is executed.  If, in response to
the prompt for a list of variables, one enters ``{\vt all}'' or ``{\vt
*}'' or ``{\vt .}'', all of the variables currently in scope will be
monitored.

Variables being displayed in the monitor window can be set to an
arbitrary value by clicking on the variable name in the monitor
window.  The value will be prompted for on the {\Xic} prompt line. 
Only variables that are in scope will accept a value.  This feature
can be used to alter program operation as the program is being run. 
Variables will continue to be monitored until the monitor window is
dismissed.

The monitor window in the script debugger can handle multi-dimensional
arrays.  When specifying an array variable, the variable name can be
followed by a range specification, enclosed in square brackets, as
follows:
\begin{quote}
[{\it rmin\/}$-${\it rmax\/},{\it dim2\/},{\it dim3\/}]
\end{quote}

This is entirely optional, as are the individual entries.  The three
comma separated fields correspond to the three dimensions (maximum) of
the array.  The lowest dimension can be a range, where {\it rmin} and
{\it rmax} set the range of indices to print or set.  The remaining
two fields are indices into the higher dimensions.  These indices are
taken as 0 if not given.  One of the range values can be omitted, with
the following interpretations:

\begin{tabular}{ll}\\
{\vt [}{\it rmin\/}, ... & Use the single index {\it rmin}.\\
{\vt [}{\it rmin\/}$-$, ... & Use the range {\it rmin} to the length of the
  lowest dimension.\\
{\vt [}$-${\it rmax\/}, ... & Use the range 0 -- {\it rmax}.\\
\end{tabular}

White space can appear, and the commas are optional, except in the
second form above where a comma must follow the `--'.

If the {\it rmax} value is less than {\it rmin}, the printing order of
the elements is reversed, as is the order of elements accepted when
the variable is being set.

A similar range specification can be applied to string variables.  In
this case, only the first field is relevant, and the range applies to
character positions.

The following commands are found in the {\cb Options} menu of the
editor.  These commands are always available.

\begin{description}
\item{\cb Search}\\
Pop up a dialog which solicits a regular expression to search for in
the document.  The up and down arrow buttons will perform the search,
in the direction of the arrows.  If the {\cb No Case} button is
active, case will be ignored in the search.  The next matching text in
the document will be highlighted.  If there is no match, ``not found''
will be displayed in the message area of the pop-up.

The search starts at the current text insertion point (the
location of the I-beam cursor).  This may not be visible in
execute mode, but can be set by clicking with button 1 (which may
set a breakpoint, so you will have to click again to remove it).
The search does not wrap.

\item{Font}\\
This brings up a tool for selecting the font to use in the text
window.  Selecting a font will change the present font, and will
set the default fixed-pitch font used in pop-up text windows.
\end{description}


% -----------------------------------------------------------------------------
% xic:hash 062808
\section{The {\cb Rehash} Button: Rebuild User menu}

\index{scripts!rehash}
The {\cb Rehash} button in the {\cb User Menu} will rebuild the {\cb
User Menu}, taking script and menu files found along the script search
path and creating the corresponding entries in the {\cb User Menu}. 
This command should be executed if a new script is added to the path. 
It is implicitly executed whenever the script path is changed.  This
function will also load the contents of files named ``{\vt library}''
found in the script search path.  These files contain function
definitions only.  Like the {\cb Debugger} button but unlike other
buttons in the {\cb User Menu}, this is an internal command.

